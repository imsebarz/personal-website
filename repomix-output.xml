This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__tests__/
  daily-filter-service.test.ts
  meal-plan-service.test.ts
  notion-todoist-service.test.ts
  todoist-webhook-service.test.ts
  webhook-service.test.ts
  webhook.test.js
.github/
  copilot-instructions.md
docs/
  webhook-vercel-fix.md
public/
  images/
    hero (1).webp:Zone.Identifier
    sebas (1).webp:Zone.Identifier
    wave-bg.svg
  site.webmanifest
scripts/
  test-dynamic-projects.js
  test-mention-removal.js
  test-todoist-webhook.js
  test-vercel-webhook.js
  test-webhook.js
  test-workspace-tokens.ts
src/
  app/
    api/
      daily-filter/
        route.ts
      daily-tasks/
        route.ts
      meal-plan/
        route.ts
      notion-webhook/
        route.ts
      todoist-webhook/
        route.ts
    layout.tsx
    page.tsx
  components/
    common/
      Icon.tsx
    AboutMe.tsx
    Contact.tsx
    FeaturedProject.tsx
    FeaturedProjects.tsx
    FloatMail.tsx
    FloatSocial.tsx
    Footer.tsx
    Hero.tsx
    MyWork.tsx
    Nav.tsx
    Project.tsx
  config/
    constants.ts
  data/
    aboutme.json
    contact.json
    nav.json
    projects.json
  hooks/
    useData.ts
  lib/
    animation.ts
    api-response.ts
    config.ts
    helpers.ts
    index.ts
    logger.ts
  middleware/
    error-handler.ts
  services/
    webhooks/
      notion-todoist.service.ts
      notion-webhook.service.ts
      todoist-webhook.service.ts
    daily-filter.service.ts
    health-check.service.ts
    index.ts
    meal-plan.service.ts
  styles/
    aboutme.scss
    colors.scss
    contact.scss
    featuredproject.scss
    featuredprojects.scss
    floatmail.scss
    floatsocial.scss
    footer.scss
    globals.scss
    hero.scss
    mixins.scss
    mywork.scss
    nav.scss
    project.scss
  types/
    assets.d.ts
    index.ts
    notion-todoist.ts
  utils/
    notion-client.ts
    notion-webhook-validator.ts
    openai-client.ts
    tag-helpers.ts
    todoist-client.ts
    todoist-webhook-validator.ts
    webhook-logger.ts
.env.example
.eslintrc.json
.gitignore
jest.config.js
jest.setup.js
next.config.js
package.json
README.md
site.webmanifest
test-notion-id.js
TODO
tsconfig.json
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__tests__/daily-filter-service.test.ts">
import { DailyFilterService } from '@/services/daily-filter.service';
import { logger } from '@/lib/logger';

// Mock dependencies
jest.mock('@/lib/logger', () => ({
  logger: {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
  },
}));

// Mock global fetch
global.fetch = jest.fn();
const mockFetch = fetch as jest.MockedFunction<typeof fetch>;

describe('DailyFilterService', () => {
  let service: DailyFilterService;
  const mockToken = 'test-token';
  const mockProjectId = 'test-project-id';

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Mock environment variables
    process.env.TODOIST_API_TOKEN = mockToken;
    process.env.TODOIST_DAILY_PROJECT_ID = mockProjectId;
    
    service = new DailyFilterService();
  });

  afterEach(() => {
    delete process.env.TODOIST_API_TOKEN;
    delete process.env.TODOIST_DAILY_PROJECT_ID;
  });

  describe('constructor', () => {
    it('should throw error if no token is provided', () => {
      delete process.env.TODOIST_API_TOKEN;
      delete process.env.TODOIST_API_TOKEN;
      
      expect(() => new DailyFilterService()).toThrow('TODOIST_API_TOKEN or TODOIST_API_TOKEN is required');
    });

    it('should throw error if no project ID is provided', () => {
      delete process.env.TODOIST_DAILY_PROJECT_ID;
      
      expect(() => new DailyFilterService()).toThrow('TODOIST_DAILY_PROJECT_ID is required');
    });

    it('should fallback to TODOIST_API_TOKEN if TODOIST_API_TOKEN is not available', () => {
      delete process.env.TODOIST_API_TOKEN;
      process.env.TODOIST_API_TOKEN = 'fallback-token';
      
      expect(() => new DailyFilterService()).not.toThrow();
    });
  });

  describe('processDailyFilter', () => {
    const mockSections = [
      { id: 'section-1', name: 'Lunes', project_id: mockProjectId },
      { id: 'section-2', name: 'Martes', project_id: mockProjectId },
      { id: 'section-3', name: 'Miércoles', project_id: mockProjectId },
    ];

    const mockTasks = [
      {
        id: 'task-1',
        content: 'Tarea de prueba 1',
        description: 'Descripción 1',
        section_id: 'section-1',
        project_id: mockProjectId,
        is_completed: false,
      },
      {
        id: 'task-2',
        content: 'Tarea de prueba 2',
        description: 'Descripción 2',
        section_id: 'section-1',
        project_id: mockProjectId,
        is_completed: true,
      },
    ];

    beforeEach(() => {
      // Mock Date to return Monday (day 1)
      jest.spyOn(Date.prototype, 'getDay').mockReturnValue(1);
      // Mock project info fetch (siempre responde con nombre de proyecto)
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ id: mockProjectId, name: 'Test Project' }),
      } as Response);
    });

    afterEach(() => {
      jest.restoreAllMocks();
    });

    it('should successfully process daily filter for Monday', async () => {

      // Mock sections API call
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockSections,
      } as Response);

      // Mock tasks API call
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockTasks,
      } as Response);

      const result = await service.processDailyFilter();

      expect(result.success).toBe(true);
      expect(result.day).toBe('lunes');
      expect(result.sectionId).toBe('section-1');
      expect(result.sectionName).toBe('Lunes');
      expect(result.tasksCount).toBe(1); // Only non-completed tasks
      expect(result.tasks).toHaveLength(1);
      expect(result.tasks[0].is_completed).toBe(false);
    });

    it('should return error when no section found for the day', async () => {
      // Mock sections without Monday
      const sectionsWithoutMonday = [
        { id: 'section-2', name: 'Martes', project_id: mockProjectId },
        { id: 'section-3', name: 'Miércoles', project_id: mockProjectId },
      ];

      // Mock project info fetch
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ id: mockProjectId, name: 'Test Project' }),
      } as Response);
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => sectionsWithoutMonday,
      } as Response);

      const result = await service.processDailyFilter();

      expect(result.success).toBe(false);
      expect(result.error).toContain('No se encontró sección para el día: lunes');
      expect(result.sectionId).toBeNull();
      expect(result.tasksCount).toBe(0);
    });

    it('should handle API errors gracefully', async () => {
      // Mock project info fetch
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ id: mockProjectId, name: 'Test Project' }),
      } as Response);
      mockFetch.mockRejectedValueOnce(new Error('API Error'));

      const result = await service.processDailyFilter();

      expect(result.success).toBe(false);
      expect(result.error).toBe('API Error');
      expect(logger.error).toHaveBeenCalledWith('Error processing daily filter', expect.any(Object));
    });

    it('should handle network errors for sections fetch', async () => {
      // Mock project info fetch
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ id: mockProjectId, name: 'Test Project' }),
      } as Response);
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
      } as Response);

      const result = await service.processDailyFilter();

      expect(result.success).toBe(false);
      expect(result.error).toContain('Failed to fetch sections: 500');
    });

    it('should handle different day names correctly', async () => {

      // Test for Tuesday (day 2)
      jest.spyOn(Date.prototype, 'getDay').mockReturnValue(2);
      // Mock project info fetch
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ id: mockProjectId, name: 'Test Project' }),
      } as Response);

      const tuesdaySections = [
        { id: 'section-2', name: 'Martes', project_id: mockProjectId },
      ];

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => tuesdaySections,
      } as Response);

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => [],
      } as Response);

      const result = await service.processDailyFilter();

      expect(result.success).toBe(true);
      expect(result.day).toBe('martes');
      expect(result.sectionName).toBe('Martes');
    });

    it('should filter out completed tasks', async () => {

      // Mock project info fetch
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ id: mockProjectId, name: 'Test Project' }),
      } as Response);

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockSections,
      } as Response);

      // All tasks completed
      const allCompletedTasks = mockTasks.map(task => ({ ...task, is_completed: true }));
      
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => allCompletedTasks,
      } as Response);

      const result = await service.processDailyFilter();

      expect(result.success).toBe(true);
      expect(result.tasksCount).toBe(0);
      expect(result.tasks).toHaveLength(0);
    });
  });

  describe('getProjectInfo', () => {
    it('should fetch project info successfully', async () => {
      const mockProject = {
        id: mockProjectId,
        name: 'Test Project',
      };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockProject,
      } as Response);

      const result = await service.getProjectInfo();

      expect(result).toEqual(mockProject);
      expect(mockFetch).toHaveBeenCalledWith(
        `https://api.todoist.com/rest/v2/projects/${mockProjectId}`,
        expect.objectContaining({
          headers: expect.objectContaining({
            'Authorization': `Bearer ${mockToken}`,
          }),
        })
      );
    });

    it('should return null on API error', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 404,
        statusText: 'Not Found',
      } as Response);

      const result = await service.getProjectInfo();

      expect(result).toBeNull();
      expect(logger.error).toHaveBeenCalledWith(
        'Error fetching project info',
        expect.objectContaining({ projectId: mockProjectId })
      );
    });
  });
});
</file>

<file path="__tests__/todoist-webhook-service.test.ts">
/**
 * Tests para TodoistWebhookService
 */

import { TodoistWebhookService } from '@/services/webhooks/todoist-webhook.service';
import * as todoistValidator from '@/utils/todoist-webhook-validator';
import * as notionClient from '@/utils/notion-client';

// Mock de dependencias
jest.mock('@/utils/todoist-webhook-validator');
jest.mock('@/utils/notion-client');
jest.mock('@/lib/logger', () => ({
  logger: {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
  },
}));

const mockTodoistValidator = todoistValidator as jest.Mocked<typeof todoistValidator>;
const mockNotionClient = notionClient as jest.Mocked<typeof notionClient>;

describe('TodoistWebhookService', () => {
  let service: TodoistWebhookService;

  beforeEach(() => {
    service = new TodoistWebhookService();
    jest.clearAllMocks();
  });

  describe('processWebhook', () => {
    const mockPayload = {
      event_name: 'item:completed',
      user_id: '123456',
      event_data: {
        id: 'task123',
        content: 'Test task',
        description: 'Test description with https://notion.so/12345678-1234-1234-1234-123456789abc',
        project_id: 'project123',
        section_id: null,
        parent_id: null,
        order: 1,
        labels: [],
        priority: 1,
        url: 'https://todoist.com/task/123',
        comment_count: 0,
        created_at: '2025-01-15T10:00:00Z',
        creator_id: '123456',
        assignee_id: null,
        assigner_id: null,
        is_completed: true,
        completed_at: '2025-01-15T11:00:00Z',
        added_at: '2025-01-15T10:00:00Z',
        added_by_uid: '123456',
        assigned_by_uid: null,
        responsible_uid: null,
        checked: true,
        child_order: 1,
        collapsed: false,
        deadline: null,
        is_deleted: false,
        user_id: '123456'
      },
      initiator: {
        email: 'test@example.com',
        full_name: 'Test User',
        id: '123456',
        is_premium: false
      },
      triggered_at: '2025-01-15T11:00:00Z',
      version: '10'
    };

    const mockHeaders = {
      'content-type': 'application/json',
      'user-agent': 'Todoist-Webhooks',
      'x-todoist-hmac-sha256': 'valid-signature',
      'x-todoist-delivery-id': 'delivery-123'
    };

    it('should successfully process a valid task completion', async () => {
      // Setup mocks
      mockTodoistValidator.isValidTodoistPayload.mockReturnValue(true);
      mockTodoistValidator.isValidTodoistWebhook.mockReturnValue(true);
      mockTodoistValidator.shouldProcessTodoistEvent.mockReturnValue(true);
      mockTodoistValidator.extractNotionPageId.mockReturnValue('12345678-1234-1234-1234-123456789abc');
      mockTodoistValidator.getCompletedStatusForNotion.mockReturnValue('Completado');
      mockNotionClient.updateNotionPageStatus.mockResolvedValue();

      const result = await service.processWebhook(mockPayload, mockHeaders, JSON.stringify(mockPayload));

      expect(result).toEqual({
        message: 'Task completion synced to Notion successfully',
        taskId: 'task123',
        notionPageId: '12345678-1234-1234-1234-123456789abc',
        eventType: 'item:completed'
      });

      expect(mockNotionClient.updateNotionPageStatus).toHaveBeenCalledWith(
        '12345678-1234-1234-1234-123456789abc',
        'Completado'
      );
    });

    it('should throw ValidationError for invalid payload structure', async () => {
      mockTodoistValidator.isValidTodoistPayload.mockReturnValue(false);

      await expect(
        service.processWebhook(mockPayload, mockHeaders, JSON.stringify(mockPayload))
      ).rejects.toThrow('Invalid Todoist webhook payload structure');
    });

    it('should throw ValidationError for invalid webhook signature', async () => {
      process.env.TODOIST_WEBHOOK_SECRET = 'test-secret';
      
      mockTodoistValidator.isValidTodoistPayload.mockReturnValue(true);
      mockTodoistValidator.isValidTodoistWebhook.mockReturnValue(false);

      await expect(
        service.processWebhook(mockPayload, mockHeaders, JSON.stringify(mockPayload))
      ).rejects.toThrow('Invalid Todoist webhook signature');

      delete process.env.TODOIST_WEBHOOK_SECRET;
    });

    it('should skip events that should not be processed', async () => {
      mockTodoistValidator.isValidTodoistPayload.mockReturnValue(true);
      mockTodoistValidator.isValidTodoistWebhook.mockReturnValue(true);
      mockTodoistValidator.shouldProcessTodoistEvent.mockReturnValue(false);

      const result = await service.processWebhook(mockPayload, mockHeaders, JSON.stringify(mockPayload));

      expect(result).toEqual({
        message: 'Event skipped - not relevant for Notion sync',
        eventType: 'item:completed',
        taskId: 'task123'
      });

      expect(mockNotionClient.updateNotionPageStatus).not.toHaveBeenCalled();
    });

    it('should handle task completion without Notion page ID', async () => {
      mockTodoistValidator.isValidTodoistPayload.mockReturnValue(true);
      mockTodoistValidator.isValidTodoistWebhook.mockReturnValue(true);
      mockTodoistValidator.shouldProcessTodoistEvent.mockReturnValue(true);
      mockTodoistValidator.extractNotionPageId.mockReturnValue(null);

      const result = await service.processWebhook(mockPayload, mockHeaders, JSON.stringify(mockPayload));

      expect(result).toEqual({
        message: 'Task completed but no Notion page ID found in description',
        taskId: 'task123',
        eventType: 'item:completed'
      });

      expect(mockNotionClient.updateNotionPageStatus).not.toHaveBeenCalled();
    });

    it('should handle errors when updating Notion page status', async () => {
      const notionError = new Error('Failed to update Notion page');
      
      mockTodoistValidator.isValidTodoistPayload.mockReturnValue(true);
      mockTodoistValidator.isValidTodoistWebhook.mockReturnValue(true);
      mockTodoistValidator.shouldProcessTodoistEvent.mockReturnValue(true);
      mockTodoistValidator.extractNotionPageId.mockReturnValue('12345678-1234-1234-1234-123456789abc');
      mockTodoistValidator.getCompletedStatusForNotion.mockReturnValue('Completado');
      mockNotionClient.updateNotionPageStatus.mockRejectedValue(notionError);

      await expect(
        service.processWebhook(mockPayload, mockHeaders, JSON.stringify(mockPayload))
      ).rejects.toThrow('Failed to sync task completion to Notion: Failed to update Notion page');
    });

    it('should process webhook without signature validation when secret is not configured', async () => {
      // Asegurarse de que no hay secret configurado
      const originalSecret = process.env.TODOIST_WEBHOOK_SECRET;
      delete process.env.TODOIST_WEBHOOK_SECRET;

      mockTodoistValidator.isValidTodoistPayload.mockReturnValue(true);
      mockTodoistValidator.shouldProcessTodoistEvent.mockReturnValue(true);
      mockTodoistValidator.extractNotionPageId.mockReturnValue('12345678-1234-1234-1234-123456789abc');
      mockTodoistValidator.getCompletedStatusForNotion.mockReturnValue('Completado');
      mockNotionClient.updateNotionPageStatus.mockResolvedValue();

      const result = await service.processWebhook(mockPayload, mockHeaders, JSON.stringify(mockPayload));

      expect(result.message).toBe('Task completion synced to Notion successfully');
      expect(mockTodoistValidator.isValidTodoistWebhook).not.toHaveBeenCalled();

      // Restaurar el valor original
      if (originalSecret) {
        process.env.TODOIST_WEBHOOK_SECRET = originalSecret;
      }
    });
  });

  describe('Edge cases', () => {
    it('should handle payloads with missing optional fields', async () => {
      const minimalPayload = {
        event_name: 'item:completed',
        user_id: '123456',
        event_data: {
          id: 'task123',
          content: 'Minimal task',
          description: 'https://notion.so/12345678-1234-1234-1234-123456789abc',
          project_id: 'project123',
          order: 1,
          labels: [],
          priority: 1,
          url: 'https://todoist.com/task/123',
          comment_count: 0,
          created_at: '2025-01-15T10:00:00Z',
          creator_id: '123456',
          is_completed: true,
          completed_at: '2025-01-15T11:00:00Z',
          added_at: '2025-01-15T10:00:00Z',
          added_by_uid: '123456',
          checked: true,
          child_order: 1,
          collapsed: false,
          is_deleted: false,
          user_id: '123456'
        },
        initiator: {
          email: 'test@example.com',
          full_name: 'Test User',
          id: '123456',
          is_premium: false
        },
        triggered_at: '2025-01-15T11:00:00Z',
        version: '10'
      };

      const mockHeaders = {
        'content-type': 'application/json',
        'user-agent': 'Todoist-Webhooks',
        'x-todoist-delivery-id': 'delivery-123'
      };

      mockTodoistValidator.isValidTodoistPayload.mockReturnValue(true);
      mockTodoistValidator.shouldProcessTodoistEvent.mockReturnValue(true);
      mockTodoistValidator.extractNotionPageId.mockReturnValue('12345678-1234-1234-1234-123456789abc');
      mockTodoistValidator.getCompletedStatusForNotion.mockReturnValue('Completado');
      mockNotionClient.updateNotionPageStatus.mockResolvedValue();

      const result = await service.processWebhook(minimalPayload, mockHeaders, JSON.stringify(minimalPayload));

      expect(result.message).toBe('Task completion synced to Notion successfully');
    });
  });
});
</file>

<file path=".github/copilot-instructions.md">
# AI Agent Instructions for Sebastian Ruiz Personal Website

## 🎯 Project Overview

Modern portfolio website with **Next.js 15**, **React 19**, **TypeScript**, and **SCSS**. Features a **Notion-Todoist integration system** with webhook automation.

**Live Site**: [imsebarz.vercel.app](https://imsebarz.vercel.app)

## 🛠️ Technology Stack

- **Framework**: Next.js 15 with App Router
- **Runtime**: React 19 (TypeScript strict mode)
- **Styling**: SCSS with CSS custom properties
- **Animations**: Framer Motion + react-intersection-observer
- **Deployment**: Vercel
- **Testing**: Jest with TypeScript
- **Key Dependencies**: `@notionhq/client`, `openai`, `framer-motion`, `sass`

## 🏗️ Core Principles

- **Service-Oriented**: Clear separation in `src/services/`
- **Type Safety**: Comprehensive TypeScript interfaces
- **Test-Driven**: TDD approach with 80%+ coverage
- **Performance**: Optimized for Vercel serverless
- **Native Node.js**: Prefer built-in APIs over dependencies

## 📁 Project Structure Deep Dive

```
src/
├── app/                          # Next.js 15 App Router
│   ├── layout.tsx               # Root layout with metadata
│   ├── page.tsx                 # Homepage component
│   └── api/                     # API routes (serverless functions)
│       ├── notion-webhook/      # Notion webhook handler
│       └── todoist-webhook/     # Todoist webhook handler
│
├── components/                   # React components
│   ├── common/                  # Reusable components
│   │   └── Icon.tsx            # SVG icon wrapper
│   ├── Hero.tsx                # Landing section
│   ├── AboutMe.tsx             # About section
│   ├── FeaturedProjects.tsx    # Featured project showcase
│   ├── FeaturedProject.tsx     # Individual featured project
│   ├── MyWork.tsx              # All projects grid
│   ├── Project.tsx             # Individual project card
│   ├── Contact.tsx             # Contact form section
│   ├── Nav.tsx                 # Navigation component
│   └── Footer.tsx              # Site footer
│
├── config/                      # Configuration files
│   └── constants.ts            # App-wide constants
│
├── data/                        # Static JSON data
│   ├── aboutme.json           # Personal information
│   ├── contact.json           # Contact information
│   ├── nav.json               # Navigation links
│   └── projects.json          # Project portfolio data
│
├── hooks/                       # Custom React hooks
│   └── useData.ts             # Data fetching hook
│
├── lib/                         # Core utilities and configuration
│   ├── animation.ts           # Framer Motion variants
│   ├── api-response.ts        # API response helpers
│   ├── config.ts              # Environment configuration
│   ├── helpers.ts             # General utility functions
│   ├── logger.ts              # Centralized logging
│   └── index.ts               # Library exports
│
├── middleware/                  # Express-style middleware
│   └── error-handler.ts       # Global error handling
│
├── services/                    # Business logic services
│   ├── health-check.service.ts           # Health monitoring
│   ├── index.ts                          # Service exports
│   └── webhooks/                         # Webhook-specific services
│       ├── notion-todoist.service.ts     # Core integration logic
│       ├── notion-webhook.service.ts     # Notion webhook processing
│       └── todoist-webhook.service.ts    # Todoist webhook processing
│
├── styles/                      # SCSS stylesheets
│   ├── globals.scss           # Global styles and CSS variables
│   ├── colors.scss            # Color palette definitions
│   ├── mixins.scss            # SCSS mixins and functions
│   └── [component].scss       # Component-specific styles
│
├── types/                       # TypeScript definitions
│   ├── index.ts               # Common types (Project, PersonalInfo, etc.)
│   ├── notion-todoist.ts      # Integration-specific types
│   └── assets.d.ts            # Asset type declarations
│
└── utils/                       # Utility functions
    ├── notion-client.ts       # Notion API wrapper
    ├── todoist-client.ts      # Todoist API wrapper
    ├── openai-client.ts       # OpenAI integration
    ├── webhook-logger.ts      # Webhook-specific logging
    ├── tag-helpers.ts         # Tag manipulation utilities
    ├── notion-webhook-validator.ts    # Notion webhook validation
    └── todoist-webhook-validator.ts   # Todoist webhook validation
```

## 🔗 Notion-Todoist Integration System

### Architecture Overview
The integration system automatically synchronizes Notion pages with Todoist tasks, supporting multiple workspaces and AI-enhanced task management with three main flows:

1. **Notion → Todoist**: Creates/updates tasks when pages are mentioned or modified
2. **Todoist → Notion**: Updates page status when tasks are completed/uncompleted  
3. **Multi-workspace support**: Automatic workspace detection with dynamic project creation

### Key Integration Patterns

#### Webhook Processing Architecture
```typescript
// All webhooks follow this debounced processing pattern
const recentlyProcessed = new Map<string, number>();
const pendingEvents = new Map<string, { payload: any; timeoutId: NodeJS.Timeout }>();

// Process only the LATEST event after debounce period
setTimeout(() => {
  // Process the final event for this pageId
}, config.webhooks.debounceTime);
```

#### Multi-Workspace Token Resolution
Environment variables follow the pattern: `NOTION_TOKEN_[WORKSPACE_NAME_UPPERCASE]`
```typescript
// Example: workspace "Corabella Pets" → NOTION_TOKEN_CORABELLA_PETS
const token = process.env[`NOTION_TOKEN_${workspaceName.toUpperCase().replace(/\s+/g, '_')}`] 
  || process.env.NOTION_TOKEN; // fallback to default
```

#### Service Layer Pattern
All business logic lives in `src/services/` with clear separation:
- `NotionWebhookService`: Handles webhook validation, debouncing, mention detection
- `NotionTodoistService`: Core integration logic (create/update/delete tasks)
- `TodoistWebhookService`: Processes task completion events back to Notion

### Environment Variables Pattern
```env
# Default Notion Configuration
NOTION_TOKEN=your_default_token
NOTION_VERIFICATION_TOKEN=your_verification_token
NOTION_USER_ID=your_user_id
NOTION_WEBHOOK_SECRET=your_webhook_secret

# Multi-Workspace Support (Format: NOTION_TOKEN_[WORKSPACE_NAME_UPPERCASE])
NOTION_TOKEN_PERSONAL=your_personal_workspace_token
NOTION_TOKEN_CORABELLA_PETS=your_company_workspace_token

# Todoist Configuration
TODOIST_API_TOKEN=your_todoist_api_token
TODOIST_PROJECT_ID=fallback_project_id  # Optional fallback
TODOIST_WEBHOOK_SECRET=your_todoist_webhook_secret
TODOIST_CLIENT_ID=your_client_id
TODOIST_CLIENT_SECRET=your_client_secret

# OpenAI Enhancement (Optional)
OPENAI_API_KEY=your_openai_api_key
ENABLE_AI_ENHANCEMENT=true
```

### Integration Points & Data Flow

#### Notion Webhook Events
- `page.content_updated`, `page.properties_updated` → Update existing task
- `page.created` → Create new task  
- User mention removal → Delete task

#### Workspace Detection Flow
1. Extract `workspace_name` from webhook payload
2. Resolve token: `NOTION_TOKEN_${workspaceName}` or fallback
3. Create/find Todoist project matching workspace name
4. Tag task with `workspace:${workspaceName.toLowerCase()}`

#### Task State Synchronization
Completed statuses: `['Listo', 'Done', 'Completed', 'Completado', 'Terminado', 'Finished']`
- Notion page status change → Complete Todoist task
- Todoist task completion → Update Notion page status

### Project-Specific Conventions

#### Task Description Format
Tasks always include Notion page URL for bidirectional sync:
```typescript
description: `${content}\n\nNotion: ${url}`;
```

#### Workspace Tagging
Every task gets a workspace tag: `workspace:workspacename` (lowercase)

#### AI Enhancement
Optional OpenAI integration enhances task descriptions while preserving original titles:
```typescript
finalContent = {
  ...pageContent,
  title: pageContent.title, // Keep original title
  content: aiEnhancement.enhancedDescription,
  // ... other AI suggestions
};
```

## 🎨 Styling Architecture

### SCSS Organization
- **colors.scss**: Centralized color palette using CSS custom properties
- **mixins.scss**: Reusable SCSS mixins for common patterns
- **globals.scss**: Global styles, typography, and layout utilities
- **Component styles**: Each component has its own SCSS file with BEM methodology

### Design System
```scss
:root {
  // Color Palette
  --color-green: #04a175;      // Primary brand color
  --color-mint: #f0fdf9;       // Light accent
  --color-black: #1a1a1a;     // Text primary
  --color-pepper: #666666;     // Text secondary
  
  // Typography
  --font-recoleta: 'Recoleta', 'Roboto', sans-serif;  // Display font
  --font-roboto: 'Roboto', sans-serif;                // Body font
  
  // Spacing System
  --spacing-xs: 0.5em;
  --spacing-sm: 1em;
  --spacing-md: 2em;
  --spacing-lg: 3em;
  --spacing-xl: 4em;
  --spacing-xxl: 6em;
  
  // Transitions
  --transition-fast: all 0.2s ease;
  --transition-normal: all 0.3s ease;
  --transition-slow: all 0.5s ease;
}
```

### Responsive Breakpoints
- **Mobile**: < 600px
- **Tablet**: 600px - 900px  
- **Desktop**: > 900px

## 🧪 Testing Architecture & TDD

### Test Structure
```
__tests__/                       # Unit tests
├── notion-todoist-service.test.ts    # Service layer tests
├── todoist-webhook-service.test.ts   # Webhook processing tests
└── webhook-service.test.ts           # Integration tests

scripts/                         # Test utilities and scripts
├── test-webhook.js             # Webhook testing utilities
├── test-dynamic-projects.js    # Project creation testing
└── test-mention-removal.js     # Mention removal testing
```

### Testing Configuration
```javascript
// jest.config.js
{
  testEnvironment: 'node',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',  // Path mapping
  },
  extensionsToTreatAsEsm: ['.jsx'],
  transform: {
    '^.+\\.(ts|tsx)$': ['ts-jest', { useESM: true }]
  },
  testTimeout: 10000,
  forceExit: true,
  detectOpenHandles: true
}
```

### Test-Driven Development (TDD) Approach
This project follows TDD principles: Red (write failing test) → Green (make it pass) → Refactor.

#### TDD Guidelines for New Features
```typescript
// Always start with test
describe('NewService', () => {
  beforeEach(() => {
    mockNotionClient = jest.fn()
    mockTodoistClient = jest.fn()
    service = new NewService(mockConfig)
  })

  it('should handle error gracefully when API fails', async () => {
    mockNotionClient.mockRejectedValue(new Error('API Error'))
    await expect(service.processData(input)).rejects.toThrow('API Error')
    expect(logger.error).toHaveBeenCalledWith('Service error', expect.any(Object))
  })
})

// Mock external dependencies consistently
jest.mock('@/utils/notion-client', () => ({
  getNotionPageContent: jest.fn(),
  isUserMentioned: jest.fn(),
}));
```

## 🚀 Development Guidelines

### Critical Development Workflows

#### Testing Webhook Integration
```bash
# Use dedicated test scripts (not generic testing)
npm run test:webhook          # Test webhook functionality
npm run test:webhook:real     # Test with real APIs
npm run test:projects         # Test project creation
npm run test:projects:cleanup # Cleanup test projects
```

#### Error Handling Pattern
All API routes use `withErrorHandler` middleware:
```typescript
export const POST = withErrorHandler(async (request: NextRequest) => {
  // Business logic here
  return createSuccessResponse(result);
});
```

### Adding New Features

#### 1. **New Components**
```typescript
// src/components/NewComponent.tsx
'use client'

import { motion, useAnimation } from 'framer-motion'
import { useInView } from 'react-intersection-observer'
import { ContainerVariants } from '@/lib/animation'
import '@/styles/new-component.scss'

interface NewComponentProps {
  // Define props with TypeScript interfaces
}

const NewComponent: React.FC<NewComponentProps> = ({ ...props }) => {
  const [ref, inView] = useInView()
  const animation = useAnimation()

  useEffect(() => {
    if (inView) {
      animation.start('visible')
    } else {
      animation.start('hidden')
    }
  }, [inView, animation])

  return (
    <motion.div
      ref={ref}
      variants={ContainerVariants}
      initial="hidden"
      animate={animation}
      className="new-component"
    >
      {/* Component content */}
    </motion.div>
  )
}

export default NewComponent
```

#### 2. **New Services**
```typescript
// src/services/new-service.ts
import { logger } from '@/lib/logger'
import { config } from '@/lib/config'

export class NewService {
  constructor(private readonly config: ServiceConfig) {}
  
  async processData(input: InputType): Promise<OutputType> {
    try {
      logger.info('Processing data', { input })
      // Service logic here
      return result
    } catch (error) {
      logger.error('Service error', { error, input })
      throw error
    }
  }
}
```

### Code Style Guidelines

#### Native Node.js First (Vercel-Optimized)
- **Prefer Native APIs**: Always use native Node.js APIs when possible over external dependencies
- **Serverless Optimization**: Minimize bundle size and cold start time for Vercel functions
- **Latest Node APIs**: Use the most recent stable Node.js APIs (Node 18+ features)
- **Built-in Modules**: Prioritize `fetch()`, `crypto`, `url`, `querystring`, `buffer` over external packages
- **Examples**: 
  - Use native `fetch()` instead of `axios` when possible
  - Use `crypto.createHmac()` for webhook validation instead of external crypto libs
  - Use `URL` constructor for URL parsing instead of external parsers
  - Use `Buffer` for encoding/decoding instead of external utilities

#### TypeScript Usage
- **Strict Mode**: Always use strict TypeScript settings
- **Interfaces**: Define interfaces for all props and data structures
- **Type Guards**: Use type guards for runtime type checking
- **Utility Types**: Leverage TypeScript utility types (Partial, Pick, etc.)

#### Component Patterns
- **Functional Components**: Use React functional components exclusively
- **Custom Hooks**: Extract complex logic to custom hooks
- **Props Drilling**: Avoid deep props drilling; use context when needed
- **Memoization**: Use React.memo for performance optimization when needed

#### Error Handling
- **Try-Catch**: Wrap async operations in try-catch blocks
- **Logging**: Use centralized logger for all error reporting
- **User Feedback**: Provide meaningful error messages
- **Graceful Degradation**: Handle failures gracefully

#### Test-First Development
- **Write Tests First**: Always write tests before implementation (TDD)
- **Test Coverage**: Minimum 80% coverage for new features
- **Mock External Dependencies**: Use Jest mocks for API calls and external services
- **Test Edge Cases**: Include tests for error scenarios and boundary conditions
- **Regression Testing**: Add tests for bug fixes to prevent regressions

#### Documentation Policy
- **No Feature Documentation**: Never create documentation for new features or functionalities
- **Code Self-Documentation**: Write self-documenting code with clear variable/function names
- **TypeScript Types**: Rely on TypeScript interfaces and types for API contracts
- **Comments**: Only add comments for complex business logic, not feature explanations

## 🚨 Important Constraints & Considerations

### Serverless Environment (Vercel)
- **Timeout Limits**: API routes have 30-second maximum execution time
- **Memory Constraints**: Optimize for memory usage in webhook processing
- **Cold Starts**: Minimize initialization overhead and bundle size in API routes
- **Stateless**: All services must be stateless between requests
- **Native Node.js Priority**: Use built-in Node.js modules to reduce bundle size and improve cold start performance
- **Latest Runtime**: Target Node.js 18+ features and APIs for optimal Vercel performance

### External API Rate Limits
- **Notion API**: Respect rate limits with proper error handling
- **Todoist API**: Implement exponential backoff for retries
- **OpenAI API**: Handle quota limits gracefully, fail silently

### Security Considerations
- **Webhook Validation**: Always validate webhook signatures
- **Environment Variables**: Never expose secrets in client-side code
- **CORS**: Configure proper CORS settings for API routes
- **Input Validation**: Validate all external inputs

## 🧰 Available Scripts

```bash
# Development
npm run dev                    # Start development server
npm run type-check            # TypeScript type checking
npm run type-check:watch      # Watch mode type checking

# Building & Deployment
npm run build                 # Build for production
npm run start                 # Start production server
npm run preview               # Build and preview locally

# Code Quality
npm run lint                  # Run ESLint
npm run lint:fix              # Fix ESLint issues

# Testing
npm run test                  # Run Jest tests
npm run test:watch            # Watch mode testing
npm run test:coverage         # Generate coverage report

# Webhook Testing
npm run test:webhook          # Test webhook functionality
npm run test:webhook:real     # Test with real APIs
npm run test:projects         # Test project creation
npm run test:projects:cleanup # Cleanup test projects
```

## 📁 Critical Files to Understand

- `src/services/webhooks/notion-webhook.service.ts` - Debouncing & validation logic
- `src/services/webhooks/notion-todoist.service.ts` - Core integration business logic  
- `src/utils/notion-client.ts` - Multi-workspace token resolution
- `src/utils/todoist-client.ts` - Dynamic project creation
- `scripts/test-*.js` - Integration testing utilities

## 🎯 Key Success Metrics

When working with this codebase, ensure:

1. **Type Safety**: All new code must be fully typed with TypeScript
2. **Test Coverage**: Minimum 80% test coverage for new features, 100% for critical paths
3. **TDD Compliance**: All new features developed using Test-Driven Development
4. **Performance**: Maintain Lighthouse scores (>90 for Performance, Accessibility, SEO)
5. **Responsive Design**: Test on all breakpoint ranges
6. **Animation Smoothness**: Ensure 60fps animations on supported devices
7. **Webhook Reliability**: Integration tests must pass consistently
8. **Error Handling**: All error paths must be tested and logged
9. **Accessibility**: Maintain WCAG 2.1 AA compliance
10. **Test Quality**: Tests must be readable, maintainable, and provide meaningful assertions

## 🚨 Development Anti-Patterns to Avoid

❌ Don't hardcode project IDs - use dynamic workspace-based project creation
❌ Don't process every webhook event - implement proper debouncing  
❌ Don't expose webhook secrets in client-side code
❌ Don't mock individual utilities in tests - mock at the API boundary
❌ Don't modify AI-enhanced titles - preserve original Notion titles
❌ Don't add external dependencies when native Node.js APIs are sufficient
❌ Don't create documentation files for new features - let code be self-documenting
❌ Don't use outdated APIs when newer Node.js built-ins are available

## 📧 Getting Help

- **GitHub Issues**: [Create an issue](https://github.com/imsebarz/personal-website/issues)
- **Documentation**: Check the `docs/` directory for specific guides
- **Contact**: imsebarz@gmail.com

---

**Remember**: This codebase prioritizes clean architecture, type safety, performance, and Test-Driven Development. When in doubt, follow the existing patterns and maintain consistency with the established code style. Always write tests first, especially for webhook integrations where reliability is critical.
</file>

<file path="docs/webhook-vercel-fix.md">
# Actualización del Sistema de Webhooks para Vercel

## Problema Identificado

El webhook de Notion estaba recibiendo eventos correctamente pero no creaba tareas en Todoist debido a incompatibilidades con el entorno serverless de Vercel:

1. **Timeout de Funciones Serverless**: Las funciones de Vercel tienen un tiempo de ejecución limitado
2. **setTimeout en Serverless**: Los timeouts diferidos no funcionan correctamente en entornos serverless
3. **Debouncing Inadecuado**: El tiempo de debounce de 60 segundos era demasiado largo para Vercel

## Cambios Realizados

### 1. **Refactorización del Sistema de Debouncing**

**Antes**: 
- Los eventos se programaban con `setTimeout` para ejecutarse después de 60 segundos
- La función respondía inmediatamente pero el procesamiento real nunca ocurría

**Ahora**:
- **Procesamiento inmediato** cuando no hay conflicto de debounce
- **Debounce inteligente** solo cuando es necesario
- **Procesamiento de eventos pendientes** en cada nueva petición

### 2. **Reducción del Tiempo de Debounce**

```typescript
// Antes
debounceTime: 60000, // 60 segundos

// Ahora  
debounceTime: 10000, // 10 segundos
```

### 3. **Configuración de Vercel**

Se agregó `vercel.json` para configurar timeouts apropiados:

```json
{
  "functions": {
    "src/app/api/notion-webhook/route.ts": {
      "maxDuration": 30
    },
    "src/app/api/todoist-webhook/route.ts": {
      "maxDuration": 30
    }
  }
}
```

### 4. **Nuevo Flujo de Procesamiento**

```mermaid
graph TD
    A[Webhook Recibido] --> B[Validar Webhook]
    B --> C[Procesar Eventos Pendientes]
    C --> D{¿Hay Debounce?}
    D -->|No| E[Procesar Inmediatamente]
    D -->|Sí| F[Guardar para Próximo Webhook]
    E --> G[Crear Tarea en Todoist]
    F --> H[Responder con Status Debounced]
```

## Comportamiento Actual

### Primer Evento para una Página
- ✅ Se procesa **inmediatamente**
- ✅ Se crea la tarea en Todoist
- ✅ Respuesta: `"Event processed successfully"`

### Eventos Subsecuentes (dentro de 10 segundos)
- ⏰ Se aplica debounce
- 💾 Se guarda para el próximo webhook
- ✅ Respuesta: `"Event debounced - will be processed on next webhook or after cooldown"`

### Próximo Webhook (después de 10 segundos)
- 🔄 Se procesan eventos pendientes automáticamente
- ✅ Se actualiza la tarea en Todoist

## Testing

### Tests Unitarios Actualizados
```bash
npm test
```

### Test de Integración para Vercel
```bash
# Para ambiente local
npm run test:webhook:vercel

# Para ambiente de producción
WEBHOOK_URL=https://tu-dominio.com/api/notion-webhook npm run test:webhook:vercel
```

## Beneficios de los Cambios

1. **🚀 Procesamiento Inmediato**: Las tareas se crean inmediatamente cuando no hay conflictos
2. **⚡ Compatibilidad con Serverless**: Eliminación de dependencias de setTimeout diferidos
3. **🛡️ Debouncing Eficiente**: Solo se aplica cuando es realmente necesario
4. **🔄 Auto-recuperación**: Los eventos pendientes se procesan automáticamente
5. **📊 Mejor Logging**: Logs más claros sobre el estado del procesamiento

## Monitoreo

Los logs ahora muestran claramente:
- ✅ `"Processing event immediately - no recent processing detected"`
- ⏰ `"Page recently processed, scheduling latest event"`
- 🔄 `"Processing pending event that exceeded debounce time"`

## Variables de Entorno Requeridas

Asegúrate de que estén configuradas en Vercel:
- `TODOIST_API_TOKEN`
- `NOTION_USER_ID` (opcional)
- `TODOIST_PROJECT_ID` (opcional)
- `OPENAI_API_KEY` (opcional)

## Próximos Pasos

1. ✅ Deploy a Vercel con los nuevos cambios
2. 🧪 Probar con webhooks reales de Notion
3. 📊 Monitorear logs para verificar funcionamiento
4. 🔧 Ajustar tiempo de debounce si es necesario (actualmente 10 segundos)
</file>

<file path="public/images/hero (1).webp:Zone.Identifier">
[ZoneTransfer]
ZoneId=3
HostUrl=https://squoosh.app/
</file>

<file path="public/images/sebas (1).webp:Zone.Identifier">
[ZoneTransfer]
ZoneId=3
HostUrl=https://squoosh.app/
</file>

<file path="public/images/wave-bg.svg">
<svg id="visual" viewBox="0 0 900 600" width="900" height="600" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1"><rect x="0" y="0" width="900" height="600" fill="#e4fdeb"></rect><defs><linearGradient id="grad1_0" x1="33.3%" y1="0%" x2="100%" y2="100%"><stop offset="20%" stop-color="#004747" stop-opacity="1"></stop><stop offset="80%" stop-color="#004747" stop-opacity="1"></stop></linearGradient></defs><defs><linearGradient id="grad1_1" x1="33.3%" y1="0%" x2="100%" y2="100%"><stop offset="20%" stop-color="#004747" stop-opacity="1"></stop><stop offset="80%" stop-color="#759e92" stop-opacity="1"></stop></linearGradient></defs><defs><linearGradient id="grad1_2" x1="33.3%" y1="0%" x2="100%" y2="100%"><stop offset="20%" stop-color="#e4fdeb" stop-opacity="1"></stop><stop offset="80%" stop-color="#759e92" stop-opacity="1"></stop></linearGradient></defs><defs><linearGradient id="grad2_0" x1="0%" y1="0%" x2="66.7%" y2="100%"><stop offset="20%" stop-color="#004747" stop-opacity="1"></stop><stop offset="80%" stop-color="#004747" stop-opacity="1"></stop></linearGradient></defs><defs><linearGradient id="grad2_1" x1="0%" y1="0%" x2="66.7%" y2="100%"><stop offset="20%" stop-color="#759e92" stop-opacity="1"></stop><stop offset="80%" stop-color="#004747" stop-opacity="1"></stop></linearGradient></defs><defs><linearGradient id="grad2_2" x1="0%" y1="0%" x2="66.7%" y2="100%"><stop offset="20%" stop-color="#759e92" stop-opacity="1"></stop><stop offset="80%" stop-color="#e4fdeb" stop-opacity="1"></stop></linearGradient></defs><g transform="translate(900, 0)"><path d="M0 405.6C-74.9 397.3 -149.8 389 -202.8 351.3C-255.8 313.6 -286.8 246.4 -317 183C-347.1 119.6 -376.4 59.8 -405.6 0L0 0Z" fill="#acccbd"></path><path d="M0 270.4C-49.9 264.9 -99.9 259.3 -135.2 234.2C-170.5 209 -191.2 164.3 -211.3 122C-231.4 79.7 -250.9 39.9 -270.4 0L0 0Z" fill="#41716b"></path><path d="M0 135.2C-25 132.4 -49.9 129.7 -67.6 117.1C-85.3 104.5 -95.6 82.1 -105.7 61C-115.7 39.9 -125.5 19.9 -135.2 0L0 0Z" fill="#004747"></path></g><g transform="translate(0, 600)"><path d="M0 -405.6C72.7 -396 145.4 -386.5 202.8 -351.3C260.2 -316.1 302.2 -255.3 333.4 -192.5C364.7 -129.7 385.1 -64.8 405.6 0L0 0Z" fill="#acccbd"></path><path d="M0 -270.4C48.5 -264 97 -257.6 135.2 -234.2C173.5 -210.7 201.5 -170.2 222.3 -128.3C243.1 -86.5 256.8 -43.2 270.4 0L0 0Z" fill="#41716b"></path><path d="M0 -135.2C24.2 -132 48.5 -128.8 67.6 -117.1C86.7 -105.4 100.7 -85.1 111.1 -64.2C121.6 -43.2 128.4 -21.6 135.2 0L0 0Z" fill="#004747"></path></g></svg>
</file>

<file path="public/site.webmanifest">
{"name":"","short_name":"","icons":[{"src":"/android-chrome-192x192.png","sizes":"192x192","type":"image/png"},{"src":"/android-chrome-512x512.png","sizes":"512x512","type":"image/png"}],"theme_color":"#ffffff","background_color":"#ffffff","display":"standalone"}
</file>

<file path="scripts/test-dynamic-projects.js">
#!/usr/bin/env node

/**
 * Script de prueba para la funcionalidad de creación dinámica de proyectos
 */

import { findOrCreateProjectByWorkspace, getProjects } from '../src/utils/todoist-client.js';

// Configuración de prueba
const testWorkspaces = [
  'Test Workspace 1',
  'Mi Empresa',
  'Cliente ABC',
  'Personal Project'
];

async function testDynamicProjectCreation() {
  console.log('🧪 Iniciando pruebas de creación dinámica de proyectos\n');
  
  // Verificar que tenemos el token de API
  if (!process.env.TODOIST_API_TOKEN) {
    console.error('❌ Error: TODOIST_API_TOKEN no está configurado');
    process.exit(1);
  }
  
  console.log('✅ Token de API configurado');
  
  try {
    // Probar listado de proyectos existentes
    console.log('\n📋 Listando proyectos existentes...');
    const existingProjects = await getProjects();
    console.log(`📁 Encontrados ${existingProjects.length} proyectos:`);
    existingProjects.forEach(project => {
      console.log(`  - ${project.name} (ID: ${project.id})`);
    });
    
    console.log('\n🚀 Probando creación dinámica de proyectos...');
    
    // Probar cada workspace de prueba
    for (const workspace of testWorkspaces) {
      console.log(`\n🔍 Procesando workspace: "${workspace}"`);
      
      try {
        const projectId = await findOrCreateProjectByWorkspace(workspace);
        const expectedName = workspace; // Sin prefijo "Notion - "
        
        console.log(`✅ Proyecto encontrado/creado: ${expectedName} (ID: ${projectId})`);
        
        // Verificar que el proyecto existe en la lista actualizada
        const updatedProjects = await getProjects();
        const foundProject = updatedProjects.find(p => p.id === projectId);
        
        if (foundProject) {
          console.log(`✅ Verificación: Proyecto "${foundProject.name}" existe en Todoist`);
        } else {
          console.log(`⚠️  Advertencia: No se pudo verificar el proyecto en la lista`);
        }
        
      } catch (error) {
        console.log(`❌ Error procesando workspace "${workspace}": ${error.message}`);
      }
    }
    
    console.log('\n📊 Resumen final...');
    const finalProjects = await getProjects();
    const workspaceProjects = finalProjects.filter(p => 
      testWorkspaces.some(workspace => p.name.toLowerCase() === workspace.toLowerCase())
    );
    
    console.log(`📁 Total de proyectos: ${finalProjects.length}`);
    console.log(`🏢 Proyectos de workspace: ${workspaceProjects.length}`);
    
    if (workspaceProjects.length > 0) {
      console.log('\n🏢 Proyectos de workspace encontrados:');
      workspaceProjects.forEach(project => {
        console.log(`  - ${project.name} (ID: ${project.id})`);
      });
    }
    
    console.log('\n✅ Pruebas completadas exitosamente!');
    
  } catch (error) {
    console.error(`❌ Error durante las pruebas: ${error.message}`);
    process.exit(1);
  }
}

// Función de limpieza opcional
async function cleanupTestProjects() {
  console.log('\n🧹 ¿Deseas limpiar los proyectos de prueba creados? (y/N)');
  
  // Esta función requeriría implementar deleteTodoistProject
  // Por ahora solo mostramos los proyectos que se podrían limpiar
  const projects = await getProjects();
  const testProjects = projects.filter(p => 
    p.name.includes('Test Workspace') || 
    p.name.includes('Cliente ABC') ||
    testWorkspaces.some(workspace => p.name.toLowerCase() === workspace.toLowerCase())
  );
  
  if (testProjects.length > 0) {
    console.log('🗑️  Proyectos que podrían ser eliminados:');
    testProjects.forEach(project => {
      console.log(`  - ${project.name} (ID: ${project.id})`);
    });
    console.log('\nNota: Elimina manualmente desde Todoist si es necesario.');
  }
}

// Ejecutar pruebas
async function main() {
  try {
    await testDynamicProjectCreation();
    
    // Preguntar si se desea limpiar (opcional)
    if (process.argv.includes('--cleanup')) {
      await cleanupTestProjects();
    }
    
  } catch (error) {
    console.error(`❌ Error fatal: ${error.message}`);
    process.exit(1);
  }
}

// Solo ejecutar si es llamado directamente
if (process.argv[1].endsWith('test-dynamic-projects.js')) {
  main();
}
</file>

<file path="scripts/test-mention-removal.js">
#!/usr/bin/env node
/**
 * Script de prueba para verificar la nueva funcionalidad de eliminación de menciones
 * Ejecutar con: node scripts/test-mention-removal.js
 */

import path from 'path';
import fs from 'fs';

// Cargar variables de entorno manualmente
const envPath = path.join(__dirname, '..', '.env.local');
if (fs.existsSync(envPath)) {
  const envContent = fs.readFileSync(envPath, 'utf8');
  envContent.split('\n').forEach(line => {
    const [key, value] = line.split('=');
    if (key && value) {
      process.env[key.trim()] = value.trim();
    }
  });
}

// Simulación simplificada del servicio para testing
class TestNotionTodoistService {
  async handleMentionRemoval(pageId) {
    console.log(`🔍 Buscando tarea para página: ${pageId}`);
    
    // Simular búsqueda en Todoist
    try {
      const response = await fetch(`https://api.todoist.com/rest/v2/tasks?project_id=${process.env.TODOIST_PROJECT_ID}`, {
        headers: {
          'Authorization': `Bearer ${process.env.TODOIST_API_TOKEN}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`Error de API: ${response.status}`);
      }
      
      const tasks = await response.json();
      const task = tasks.find(t => t.description && t.description.includes(pageId));
      
      if (task) {
        console.log(`📋 Tarea encontrada: ${task.content} (ID: ${task.id})`);
        return {
          taskDeleted: false, // No eliminaremos realmente en el test
          taskId: task.id,
          message: 'Tarea encontrada (no eliminada en modo test)'
        };
      } else {
        return {
          taskDeleted: false,
          message: 'No se encontró tarea asociada'
        };
      }
    } catch (error) {
      return {
        taskDeleted: false,
        error: error.message
      };
    }
  }
}

async function testMentionRemoval() {
  console.log('🧪 Iniciando test de eliminación de menciones...\n');

  // Verificar configuración
  const requiredEnvVars = ['NOTION_TOKEN', 'TODOIST_API_TOKEN', 'TODOIST_PROJECT_ID'];
  const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
  
  if (missingVars.length > 0) {
    console.error('❌ Variables de entorno faltantes:', missingVars.join(', '));
    console.error('Asegúrate de tener configurado tu archivo .env.local');
    process.exit(1);
  }

  console.log('✅ Variables de entorno configuradas correctamente');
  console.log(`📁 Proyecto de Todoist: ${process.env.TODOIST_PROJECT_ID}\n`);

  const service = new TestNotionTodoistService();

  // Test 1: Verificar manejo cuando no hay tarea que eliminar
  console.log('Test 1: Página sin tarea asociada');
  try {
    const result1 = await service.handleMentionRemoval('test-page-no-task-12345');
    console.log('📄 Resultado:', JSON.stringify(result1, null, 2));
    
    if (!result1.taskDeleted) {
      console.log('✅ Test 1 pasó: Correctamente manejó página sin tarea\n');
    } else {
      console.log('⚠️  Test 1 inesperado: Se reportó eliminación de tarea inexistente\n');
    }
  } catch (error) {
    console.log('❌ Test 1 falló:', error.message, '\n');
  }

  // Test 2: Verificar con un pageId que podrías tener en tu entorno real
  // (Solo ejecutar si tienes una página de prueba)
  if (process.env.TEST_NOTION_PAGE_ID) {
    console.log('Test 2: Página de prueba real');
    console.log(`📝 Usando página: ${process.env.TEST_NOTION_PAGE_ID}`);
    try {
      const result2 = await service.handleMentionRemoval(process.env.TEST_NOTION_PAGE_ID);
      console.log('📄 Resultado:', JSON.stringify(result2, null, 2));
      
      if (result2.taskDeleted) {
        console.log('✅ Test 2: Se eliminó una tarea existente');
        console.log(`🗑️  Tarea eliminada: ${result2.taskId}\n`);
      } else {
        console.log('✅ Test 2: No había tarea que eliminar\n');
      }
    } catch (error) {
      console.log('❌ Test 2 falló:', error.message, '\n');
    }
  } else {
    console.log('⏭️  Test 2 omitido: No se configuró TEST_NOTION_PAGE_ID\n');
    console.log('💡 Para probar con una página real, agrega TEST_NOTION_PAGE_ID a tu .env.local\n');
  }

  console.log('🎉 Tests completados!');
  console.log('\n📋 Resumen de la funcionalidad:');
  console.log('   • ✅ La función handleMentionRemoval está funcionando');
  console.log('   • ✅ Maneja correctamente páginas sin tareas asociadas');
  console.log('   • ✅ La integración con la API de Todoist está configurada');
  console.log('\n🚀 La funcionalidad está lista para usar en producción!');
}

// Ejecutar el test
testMentionRemoval().catch(error => {
  console.error('💥 Error ejecutando tests:', error);
  process.exit(1);
});
</file>

<file path="scripts/test-todoist-webhook.js">
#!/usr/bin/env node

/**
 * Script para probar el webhook de Todoist
 * Simula eventos de completado de tareas de Todoist
 */

import https from 'https';
import http from 'http';
import crypto from 'crypto';

// Configuración
const config = {
  // URL de tu webhook local
  webhookUrl: process.env.APP_URL || 'http://localhost:3000',
  
  // Secret del webhook (debe coincidir con TODOIST_WEBHOOK_SECRET)
  webhookSecret: process.env.TODOIST_WEBHOOK_SECRET || 'your_todoist_webhook_secret_here',
  
  // ID de página de Notion de prueba (formato válido)
  sampleNotionPageId: '12345678-1234-1234-1234-123456789abc',
};

// Payloads de prueba
const testPayloads = {
  taskCompleted: {
    event_name: "item:completed",
    user_id: "2671355",
    event_data: {
      added_by_uid: "2671355",
      assigned_by_uid: null,
      checked: true,
      child_order: 3,
      collapsed: false,
      content: "Revisar propuesta de diseño",
      description: `Revisar la propuesta de diseño para el nuevo proyecto.\n\nReferencia: https://notion.so/${config.sampleNotionPageId}`,
      added_at: "2025-01-15T10:33:38.000000Z",
      completed_at: "2025-01-15T14:25:12.000000Z",
      due: null,
      deadline: null,
      id: "6XR4GqQQCW6Gv9h4",
      is_deleted: false,
      labels: ["work", "design"],
      parent_id: null,
      priority: 3,
      project_id: "6XR4H993xv8H5qCR",
      responsible_uid: null,
      section_id: null,
      url: "https://app.todoist.com/app/task/6XR4GqQQCW6Gv9h4",
      user_id: "2671355",
      comment_count: 0,
      created_at: "2025-01-15T10:33:38.000000Z",
      creator_id: "2671355",
      assignee_id: null,
      assigner_id: null,
      is_completed: true,
      added_by_uid: "2671355",
      assigned_by_uid: null,
      responsible_uid: null,
      deadline: null,
      is_deleted: false
    },
    initiator: {
      email: "usuario@ejemplo.com",
      full_name: "Usuario de Prueba",
      id: "2671355",
      image_id: "ad38375bdb094286af59f1eab36d8f20",
      is_premium: true
    },
    triggered_at: "2025-01-15T14:25:12.000000Z",
    version: "10"
  },
  
  taskCompletedWithoutNotion: {
    event_name: "item:completed",
    user_id: "2671355",
    event_data: {
      id: "7YS5HrRRDX7Hw0i5",
      content: "Comprar leche",
      description: "Ir al supermercado y comprar leche",
      project_id: "6XR4H993xv8H5qCR",
      section_id: null,
      parent_id: null,
      order: 1,
      labels: ["personal"],
      priority: 1,
      due: null,
      url: "https://app.todoist.com/app/task/7YS5HrRRDX7Hw0i5",
      comment_count: 0,
      created_at: "2025-01-15T09:00:00.000000Z",
      creator_id: "2671355",
      assignee_id: null,
      assigner_id: null,
      is_completed: true,
      completed_at: "2025-01-15T15:30:00.000000Z",
      added_at: "2025-01-15T09:00:00.000000Z",
      added_by_uid: "2671355",
      assigned_by_uid: null,
      responsible_uid: null,
      checked: true,
      child_order: 1,
      collapsed: false,
      deadline: null,
      is_deleted: false,
      user_id: "2671355"
    },
    initiator: {
      email: "usuario@ejemplo.com",
      full_name: "Usuario de Prueba",
      id: "2671355",
      image_id: "ad38375bdb094286af59f1eab36d8f20",
      is_premium: true
    },
    triggered_at: "2025-01-15T15:30:00.000000Z",
    version: "10"
  },

  nonCompletionEvent: {
    event_name: "item:added",
    user_id: "2671355",
    event_data: {
      id: "8ZT6IsSSEY8Ix1j6",
      content: "Nueva tarea agregada",
      description: "Esta es una nueva tarea",
      project_id: "6XR4H993xv8H5qCR",
      is_completed: false,
      added_at: "2025-01-15T16:00:00.000000Z"
    },
    initiator: {
      email: "usuario@ejemplo.com",
      full_name: "Usuario de Prueba",
      id: "2671355"
    },
    triggered_at: "2025-01-15T16:00:00.000000Z",
    version: "10"
  }
};

// Función para crear firma HMAC
function createSignature(payload, secret) {
  return crypto
    .createHmac('sha256', secret)
    .update(payload, 'utf8')
    .digest('base64');
}

// Función para realizar petición HTTP
function makeRequest(url, data, headers = {}) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url);
    const options = {
      hostname: urlObj.hostname,
      port: urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80),
      path: urlObj.pathname,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(data),
        ...headers
      }
    };
    const req = (urlObj.protocol === 'https:' ? https : http).request(options, (res) => {
      let body = '';
      res.on('data', (chunk) => body += chunk);
      res.on('end', () => {
        resolve({
          status: res.statusCode,
          headers: res.headers,
          data: body ? JSON.parse(body) : null
        });
      });
    });

    req.on('error', reject);
    req.write(data);
    req.end();
  });
}

// Función para colorear texto en consola
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function colorLog(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

// Función principal de prueba
async function runTests() {
  colorLog('\n🧪 Iniciando pruebas del webhook de Todoist\n', 'cyan');
  
  const webhookEndpoint = `${config.webhookUrl}/api/todoist-webhook`;
  
  // Verificar que la URL esté configurada
  if (!config.webhookUrl || config.webhookUrl.includes('localhost') && process.env.NODE_ENV === 'production') {
    colorLog('⚠️  Advertencia: Usando URL localhost en producción', 'yellow');
  }

  // Prueba 1: Tarea completada con referencia a Notion
  try {
    colorLog('📝 Prueba 1: Tarea completada con referencia a Notion', 'blue');
    
    const payload = JSON.stringify(testPayloads.taskCompleted);
    const signature = createSignature(payload, config.webhookSecret);
    
    const headers = {
      'User-Agent': 'Todoist-Webhooks',
      'X-Todoist-Hmac-SHA256': signature,
      'X-Todoist-Delivery-ID': 'test-delivery-1'
    };
    
    const response = await makeRequest(webhookEndpoint, payload, headers);
    
    colorLog(`   Estado: ${response.status}`, response.status === 200 ? 'green' : 'red');
    colorLog(`   Mensaje: ${response.data?.data?.message || response.data?.message || 'Sin mensaje'}`, 'cyan');
    if (response.data?.data?.notionPageId) {
      colorLog(`   Página de Notion: ${response.data.data.notionPageId}`, 'magenta');
    }
    
  } catch (error) {
    colorLog(`   ❌ Error: ${error.message}`, 'red');
  }

  // Prueba 2: Tarea completada sin referencia a Notion
  try {
    colorLog('\n📝 Prueba 2: Tarea completada sin referencia a Notion', 'blue');
    
    const payload = JSON.stringify(testPayloads.taskCompletedWithoutNotion);
    const signature = createSignature(payload, config.webhookSecret);
    
    const headers = {
      'User-Agent': 'Todoist-Webhooks',
      'X-Todoist-Hmac-SHA256': signature,
      'X-Todoist-Delivery-ID': 'test-delivery-2'
    };
    
    const response = await makeRequest(webhookEndpoint, payload, headers);
    
    colorLog(`   Estado: ${response.status}`, response.status === 200 ? 'green' : 'red');
    colorLog(`   Mensaje: ${response.data?.data?.message || response.data?.message || 'Sin mensaje'}`, 'cyan');
    
  } catch (error) {
    colorLog(`   ❌ Error: ${error.message}`, 'red');
  }

  // Prueba 3: Evento que no es de completado
  try {
    colorLog('\n📝 Prueba 3: Evento que no es de completado (debería ser ignorado)', 'blue');
    
    const payload = JSON.stringify(testPayloads.nonCompletionEvent);
    const signature = createSignature(payload, config.webhookSecret);
    
    const headers = {
      'User-Agent': 'Todoist-Webhooks',
      'X-Todoist-Hmac-SHA256': signature,
      'X-Todoist-Delivery-ID': 'test-delivery-3'
    };
    
    const response = await makeRequest(webhookEndpoint, payload, headers);
    
    colorLog(`   Estado: ${response.status}`, response.status === 200 ? 'green' : 'red');
    colorLog(`   Mensaje: ${response.data?.data?.message || response.data?.message || 'Sin mensaje'}`, 'cyan');
    
  } catch (error) {
    colorLog(`   ❌ Error: ${error.message}`, 'red');
  }

  // Prueba 4: Webhook sin firma (si el secret está configurado)
  if (config.webhookSecret && config.webhookSecret !== 'your_todoist_webhook_secret_here') {
    try {
      colorLog('\n📝 Prueba 4: Webhook sin firma válida (debería fallar)', 'blue');
      
      const payload = JSON.stringify(testPayloads.taskCompleted);
      
      const headers = {
        'User-Agent': 'Todoist-Webhooks',
        'X-Todoist-Delivery-ID': 'test-delivery-4'
        // Sin firma HMAC
      };
      
      const response = await makeRequest(webhookEndpoint, payload, headers);
      
      colorLog(`   Estado: ${response.status}`, response.status >= 400 ? 'green' : 'red');
      colorLog(`   Mensaje: ${response.data?.error || response.data?.message || 'Sin mensaje'}`, 'cyan');
      
    } catch (error) {
      colorLog(`   ❌ Error: ${error.message}`, 'red');
    }
  }

  // Prueba 5: Health check
  try {
    colorLog('\n🏥 Prueba 5: Health check', 'blue');
    
    // Hacer petición GET al endpoint
    const urlObj = new URL(webhookEndpoint);
    const options = {
      hostname: urlObj.hostname,
      port: urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80),
      path: urlObj.pathname,
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    };

    const healthResponse = await new Promise((resolve, reject) => {
      const req = (urlObj.protocol === 'https:' ? https : http).request(options, (res) => {
        let body = '';
        res.on('data', (chunk) => body += chunk);
        res.on('end', () => {
          resolve({
            status: res.statusCode,
            data: body ? JSON.parse(body) : null
          });
        });
      });
      req.on('error', reject);
      req.end();
    });
    
    colorLog(`   Estado: ${healthResponse.status}`, healthResponse.status === 200 ? 'green' : 'red');
    colorLog(`   Mensaje: ${healthResponse.data?.message || 'Health check OK'}`, 'cyan');
    
  } catch (error) {
    colorLog(`   ❌ Error en health check: ${error.message}`, 'red');
  }

  colorLog('\n✅ Pruebas completadas', 'green');
  colorLog('\n📋 Para configurar el webhook en Todoist:', 'yellow');
  colorLog(`   URL del webhook: ${webhookEndpoint}`, 'cyan');
  colorLog(`   Eventos a configurar: item:completed`, 'cyan');
  if (config.webhookSecret !== 'your_todoist_webhook_secret_here') {
    colorLog(`   Secret configurado: ${config.webhookSecret.substring(0, 10)}...`, 'cyan');
  }
}

// Ejecutar pruebas
runTests()

export { runTests, testPayloads, createSignature };
</file>

<file path="scripts/test-vercel-webhook.js">
#!/usr/bin/env node

/**
 * Script de prueba para webhooks de Notion con debouncing mejorado para Vercel
 */

import { config } from '../src/lib/config.js';

const WEBHOOK_URL = process.env.WEBHOOK_URL || 'http://localhost:3000/api/notion-webhook';
const TEST_PAGE_ID = process.env.TEST_PAGE_ID || 'test-page-id-123';

/**
 * Crea un payload de webhook de prueba
 */
function createTestPayload(pageId, eventType = 'page.updated') {
  return {
    entity: {
      id: pageId,
      type: 'page'
    },
    type: eventType,
    workspace_name: 'Test Workspace',
    timestamp: new Date().toISOString()
  };
}

/**
 * Envía un webhook de prueba
 */
async function sendWebhook(payload, label) {
  try {
    console.log(`🚀 Enviando webhook: ${label}`);
    
    const response = await fetch(WEBHOOK_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'notion-api',
        'X-Notion-Signature': 'test-signature'
      },
      body: JSON.stringify(payload)
    });

    const result = await response.json();
    console.log(`✅ Respuesta (${response.status}):`, {
      message: result.message,
      pageId: result.pageId,
      eventAction: result.eventAction,
      debounceTimeMs: result.debounceTimeMs
    });

    return result;
  } catch (error) {
    console.error(`❌ Error enviando webhook ${label}:`, error.message);
    return null;
  }
}

/**
 * Prueba de procesamiento inmediato
 */
async function testImmediateProcessing() {
  console.log('\n📋 Test 1: Procesamiento inmediato (sin debounce)');
  console.log('=' .repeat(60));
  
  const payload = createTestPayload(`${TEST_PAGE_ID}-immediate`);
  const result = await sendWebhook(payload, 'Evento único');
  
  if (result && result.message.includes('processed successfully')) {
    console.log('✅ Test PASÓ: Evento procesado inmediatamente');
  } else {
    console.log('❌ Test FALLÓ: Evento no procesado inmediatamente');
  }
}

/**
 * Prueba de debouncing
 */
async function testDebouncing() {
  console.log('\n📋 Test 2: Debouncing (eventos rápidos)');
  console.log('=' .repeat(60));
  
  const pageId = `${TEST_PAGE_ID}-debounce`;
  
  // Primer evento - debería procesarse inmediatamente
  console.log('\n🔸 Enviando primer evento...');
  const firstResult = await sendWebhook(createTestPayload(pageId), 'Primer evento');
  
  // Esperar un poco y enviar segundo evento - debería aplicar debounce
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  console.log('\n🔸 Enviando segundo evento (debería aplicar debounce)...');
  const secondResult = await sendWebhook(createTestPayload(pageId), 'Segundo evento');
  
  if (firstResult && firstResult.message.includes('processed successfully') &&
      secondResult && secondResult.message.includes('debounced')) {
    console.log('✅ Test PASÓ: Debouncing funcionando correctamente');
  } else {
    console.log('❌ Test FALLÓ: Debouncing no funcionando como esperado');
    console.log('  Primer resultado:', firstResult?.message);
    console.log('  Segundo resultado:', secondResult?.message);
  }
}

/**
 * Prueba de múltiples páginas
 */
async function testMultiplePages() {
  console.log('\n📋 Test 3: Múltiples páginas (sin interferencia)');
  console.log('=' .repeat(60));
  
  const promises = [];
  for (let i = 1; i <= 3; i++) {
    const pageId = `${TEST_PAGE_ID}-multi-${i}`;
    const payload = createTestPayload(pageId);
    promises.push(sendWebhook(payload, `Página ${i}`));
  }
  
  const results = await Promise.all(promises);
  const allProcessed = results.every(r => r && r.message.includes('processed successfully'));
  
  if (allProcessed) {
    console.log('✅ Test PASÓ: Múltiples páginas procesadas correctamente');
  } else {
    console.log('❌ Test FALLÓ: No todas las páginas fueron procesadas');
  }
}

/**
 * Función principal
 */
async function main() {
  console.log('🧪 Iniciando pruebas de webhook con debouncing mejorado para Vercel');
  console.log('=' .repeat(80));
  console.log(`📍 URL del webhook: ${WEBHOOK_URL}`);
  console.log(`🆔 ID de página base: ${TEST_PAGE_ID}`);
  console.log(`⏱️  Tiempo de debounce configurado: ${config.webhooks.debounceTime}ms`);
  
  try {
    await testImmediateProcessing();
    await testDebouncing();
    await testMultiplePages();
    
    console.log('\n🎉 Todas las pruebas completadas');
    console.log('=' .repeat(80));
    
  } catch (error) {
    console.error('💥 Error durante las pruebas:', error);
    process.exit(1);
  }
}

// Ejecutar si es llamado directamente
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
</file>

<file path="scripts/test-workspace-tokens.ts">
/**
 * Test script to verify workspace token resolution
 * Run this to test the multi-workspace functionality
 */

// Mock environment variables for testing
process.env.NOTION_TOKEN = 'default_token_12345';
process.env.NOTION_TOKEN_CORABELLA_PETS = 'corabella_pets_token_67890';
process.env.NOTION_TOKEN_TEST_WORKSPACE = 'test_workspace_token_abcde';

// Import the function after setting env vars
import { getNotionPageContent } from '../src/utils/notion-client';

async function testWorkspaceTokenResolution() {
  console.log('🧪 Testing Workspace Token Resolution\n');
  
  // Test workspace name to environment variable conversion
  const testCases = [
    { workspace: 'Corabella Pets', expectedEnvVar: 'NOTION_TOKEN_CORABELLA_PETS' },
    { workspace: 'Test Workspace', expectedEnvVar: 'NOTION_TOKEN_TEST_WORKSPACE' },
    { workspace: 'My-Company Name', expectedEnvVar: 'NOTION_TOKEN_MY_COMPANY_NAME' },
    { workspace: undefined, expectedEnvVar: 'NOTION_TOKEN' },
  ];
  
  for (const testCase of testCases) {
    console.log(`📝 Testing workspace: "${testCase.workspace || 'undefined'}"`);
    console.log(`   Expected env var: ${testCase.expectedEnvVar}`);
    
    try {
      // This will show in logs which token is being used
      // Note: This will fail since we don't have a real page ID, but it will show the token selection logic
      await getNotionPageContent('test-page-id', testCase.workspace);
    } catch (error) {
      // Expected to fail, but we'll see the logs
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.log(`   ✅ Token selection logged (error expected: ${errorMessage.substring(0, 50)}...)`);
    }
    console.log('');
  }
  
  console.log('🎉 Test completed! Check the logs above to see which tokens were selected.');
}

// Only run if this file is executed directly
if (require.main === module) {
  testWorkspaceTokenResolution().catch(console.error);
}

export { testWorkspaceTokenResolution };
</file>

<file path="src/app/api/daily-filter/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { DailyFilterService } from '@/services/daily-filter.service';
import { createSuccessResponse, createErrorResponse } from '@/lib/api-response';
import { withErrorHandler } from '@/middleware/error-handler';
import { logger } from '@/lib/logger';

/**
 * API endpoint para obtener las tareas del día actual
 * Ejecuta el filtro dinámico que busca la sección correspondiente al día de la semana
 */
export const GET = withErrorHandler(async (_request: NextRequest) => {
  try {
    logger.info('Processing daily filter request');

    const service = new DailyFilterService();
    const result = await service.processDailyFilter();

    if (!result.success) {
      const errorResponse = createErrorResponse(result.error || 'Error processing daily filter');
      return NextResponse.json(errorResponse, { status: 400 });
    }

    logger.info('Daily filter completed successfully', {
      day: result.day,
      sectionName: result.sectionName,
      tasksCount: result.tasksCount
    });

    const successResponse = createSuccessResponse({
      message: `Filtro del día ${result.day} procesado exitosamente`,
      data: {
        day: result.day,
        section: {
          id: result.sectionId,
          name: result.sectionName
        },
        filter: {
          id: result.filterId,
          query: result.filterQuery,
          updated: result.filterUpdated
        },
        tasks: {
          count: result.tasksCount,
          items: result.tasks.map(task => ({
            id: task.id,
            content: task.content,
            description: task.description,
            due: task.due
          }))
        },
        project: {
          id: result.projectId
        }
      }
    });

    return NextResponse.json(successResponse);

  } catch (error) {
    logger.error('Error in daily filter endpoint', { error });
    const errorResponse = createErrorResponse('Error interno del servidor');
    return NextResponse.json(errorResponse, { status: 500 });
  }
});

/**
 * API endpoint para ejecutar manualmente el filtro dinámico
 * Permite forzar la ejecución sin esperar el cronjob
 */
export const POST = withErrorHandler(async (_request: NextRequest) => {
  try {
    logger.info('Manual daily filter execution triggered');

    const service = new DailyFilterService();
    
    // Obtener información del proyecto
    const projectInfo = await service.getProjectInfo();
    
    // Ejecutar el filtro
    const result = await service.processDailyFilter();

    if (!result.success) {
      const errorResponse = createErrorResponse(result.error || 'Error executing daily filter');
      return NextResponse.json(errorResponse, { status: 400 });
    }

    logger.info('Manual daily filter executed successfully', {
      day: result.day,
      sectionName: result.sectionName,
      tasksCount: result.tasksCount
    });

    const successResponse = createSuccessResponse({
      message: `Filtro manual ejecutado para ${result.day}`,
      executedAt: new Date().toISOString(),
      data: {
        day: result.day,
        section: {
          id: result.sectionId,
          name: result.sectionName
        },
        filter: {
          id: result.filterId,
          query: result.filterQuery,
          updated: result.filterUpdated
        },
        tasks: {
          count: result.tasksCount,
          items: result.tasks.map(task => ({
            id: task.id,
            content: task.content,
            description: task.description,
            due: task.due
          }))
        },
        project: {
          id: result.projectId,
          name: projectInfo?.name || 'Unknown'
        }
      }
    });

    return NextResponse.json(successResponse);

  } catch (error) {
    logger.error('Error in manual daily filter execution', { error });
    const errorResponse = createErrorResponse('Error ejecutando filtro manual');
    return NextResponse.json(errorResponse, { status: 500 });
  }
});
</file>

<file path="src/app/api/daily-tasks/route.ts">
import { NextResponse } from 'next/server';
import { DailyFilterService } from '@/services/daily-filter.service';
import { createSuccessResponse, createErrorResponse } from '@/lib/api-response';
import { withErrorHandler } from '@/middleware/error-handler';
import { logger } from '@/lib/logger';

/**
 * API endpoint específico para Vercel Cron Jobs
 * Ejecuta el filtro dinámico diariamente en la mañana
 * 
 * Esta función será llamada automáticamente por Vercel según la configuración de cron
 * definida en vercel.json
 */
export const GET = withErrorHandler(async () => {
  try {


    logger.info('Cron job daily filter execution started');

    const service = new DailyFilterService();
    const result = await service.processDailyFilter();

    if (!result.success) {
      logger.error('Cron job daily filter failed', { error: result.error });
      const errorResponse = createErrorResponse(result.error || 'Cron job failed');
      return NextResponse.json(errorResponse, { status: 500 });
    }

    logger.info('Cron job daily filter completed successfully', {
      day: result.day,
      sectionName: result.sectionName,
      tasksCount: result.tasksCount,
      executedAt: new Date().toISOString()
    });

    const successResponse = createSuccessResponse({
      message: `Cron job ejecutado exitosamente para ${result.day}`,
      executedAt: new Date().toISOString(),
      cronJob: true,
      data: {
        day: result.day,
        section: {
          id: result.sectionId,
          name: result.sectionName
        },
        filter: {
          id: result.filterId,
          query: result.filterQuery,
          updated: result.filterUpdated
        },
        tasks: {
          count: result.tasksCount,
          processed: result.tasksCount
        },
        project: {
          id: result.projectId
        }
      }
    });

    return NextResponse.json(successResponse);

  } catch (error) {
    logger.error('Error in cron job daily filter execution', { error });
    const errorResponse = createErrorResponse('Error en ejecución del cron job');
    return NextResponse.json(errorResponse, { status: 500 });
  }
});
</file>

<file path="src/app/api/meal-plan/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { MealPlanService } from '@/services/meal-plan.service';
import { withErrorHandler } from '@/middleware/error-handler';
import { createSuccessResponse, createErrorResponse } from '@/lib/api-response';
import { logger } from '@/lib/logger';

export const GET = withErrorHandler(async (_request: NextRequest) => {
  logger.info('Meal plan API endpoint called');

  try {
    const mealPlanService = new MealPlanService();
    const result = await mealPlanService.processMealPlan();

    if (!result.success) {
      logger.error('Meal plan processing failed', { result });
      const errorResponse = createErrorResponse(result.error || 'Error processing meal plan');
      return NextResponse.json(errorResponse, { status: 500 });
    }

    logger.info('Meal plan processed successfully', {
      currentDay: result.currentDay,
      nextDay: result.nextDay,
      tasksCount: result.tasksCount,
      filterUpdated: result.filterUpdated
    });

    const successResponse = createSuccessResponse({
      message: `Meal plan para ${result.nextDay} procesado exitosamente`,
      data: {
        currentDay: result.currentDay,
        nextDay: result.nextDay,
        section: {
          id: result.sectionId,
          name: result.sectionName
        },
        filter: {
          id: result.filterId,
          query: result.filterQuery,
          updated: result.filterUpdated
        },
        tasks: {
          count: result.tasksCount,
          items: result.tasks.map(task => ({
            id: task.id,
            content: task.content,
            description: task.description,
            labels: task.labels,
            due: task.due
          }))
        },
        projectInfo: await mealPlanService.getProjectInfo()
      }
    });

    return NextResponse.json(successResponse);
  } catch (error) {
    logger.error('Unexpected error in meal plan API', { error });
    const errorResponse = createErrorResponse('Internal server error');
    return NextResponse.json(errorResponse, { status: 500 });
  }
});
</file>

<file path="src/app/api/todoist-webhook/route.ts">
/**
 * API Route para webhooks de Todoist
 * Maneja eventos de completado de tareas que deben sincronizarse con Notion
 */

import { NextRequest, NextResponse } from 'next/server';
import { withErrorHandler } from '@/middleware/error-handler';
import { logger } from '@/lib/logger';
import { validateEnvironment } from '@/lib/config';
import { TodoistWebhookService } from '@/services/webhooks/todoist-webhook.service';
import { HealthCheckService } from '@/services/health-check.service';

// Validar configuración al inicio
validateEnvironment();

// Servicios
const webhookService = new TodoistWebhookService();
const healthService = new HealthCheckService();

/**
 * POST - Procesar webhook de Todoist
 */
const handlePost = withErrorHandler(async (request: NextRequest): Promise<NextResponse> => {
  // Extraer raw body para validación de signature
  const rawBody = await request.text();
  let payload;
  
  try {
    payload = JSON.parse(rawBody);
  } catch (error) {
    logger.error('Failed to parse JSON payload', error as Error);
    return NextResponse.json(
      { error: 'Invalid JSON payload' },
      { status: 400 }
    );
  }

  // Extraer headers relevantes
  const headers = {
    'content-type': request.headers.get('content-type'),
    'user-agent': request.headers.get('user-agent'),
    'x-todoist-hmac-sha256': request.headers.get('x-todoist-hmac-sha256'),
    'x-todoist-delivery-id': request.headers.get('x-todoist-delivery-id'),
  };

  logger.info('Processing Todoist webhook request', { 
    hasPayload: !!payload,
    userAgent: headers['user-agent'],
    hasSignature: !!headers['x-todoist-hmac-sha256'],
    deliveryId: headers['x-todoist-delivery-id'],
    eventName: payload?.event_name
  });

  // Procesar webhook
  const result = await webhookService.processWebhook(payload, headers, rawBody);
  
  // Retornar respuesta exitosa (HTTP 200 requerido por Todoist)
  return NextResponse.json({
    success: true,
    data: result,
    meta: {
      timestamp: new Date().toISOString()
    }
  });
});

/**
 * GET - Health check
 */
const handleGet = withErrorHandler(async (): Promise<NextResponse> => {
  const health = healthService.getHealthStatus();
  return NextResponse.json({
    ...health,
    endpoint: 'todoist-webhook',
    message: 'Todoist-Notion Webhook API is running'
  });
});

export { handlePost as POST, handleGet as GET };
</file>

<file path="src/components/common/Icon.tsx">
'use client'

import React from 'react'

export type IconType = 
  | 'github'
  | 'twitter'
  | 'linkedin'
  | 'instagram'
  | 'external-link'
  | 'folder'

interface IconProps {
  type: IconType
  width?: number
  height?: number
  className?: string
  fill?: string
}

const iconPaths = {
  github: "M12.5516 0.454773C5.92157 0.454773 0.551575 5.82477 0.551575 12.4548C0.551575 17.7648 3.98657 22.2498 8.75657 23.8398C9.35657 23.9448 9.58157 23.5848 9.58157 23.2698C9.58157 22.9848 9.56658 22.0398 9.56658 21.0348C6.55157 21.5898 5.77157 20.2998 5.53157 19.6248C5.39657 19.2798 4.81157 18.2148 4.30157 17.9298C3.88157 17.7048 3.28157 17.1498 4.28657 17.1348C5.23157 17.1198 5.90157 17.9898 6.12657 18.3498C7.31657 20.2848 9.19157 19.7148 9.62157 19.3998C9.74157 18.6198 10.0516 18.0348 10.3916 17.7348C7.69657 17.4348 4.87157 16.3948 4.87157 11.7748C4.87157 10.4548 5.39657 9.36477 6.15657 8.51477C6.02157 8.21477 5.61157 6.97477 6.29157 5.23477C6.29157 5.23477 7.40657 4.91977 9.58157 6.37477C10.6316 6.10477 11.7516 5.96977 12.8716 5.96977C13.9916 5.96977 15.1116 6.10477 16.1616 6.37477C18.3366 4.90477 19.4516 5.23477 19.4516 5.23477C20.1316 6.97477 19.7216 8.21477 19.5866 8.51477C20.3466 9.36477 20.8716 10.4398 20.8716 11.7748C20.8716 16.4098 18.0316 17.4348 15.3366 17.7348C15.7616 18.1098 16.1466 18.8298 16.1466 19.9398C16.1466 21.5448 16.1316 22.8348 16.1316 23.2698C16.1316 23.5848 16.3566 23.9598 16.9566 23.8398C21.0166 22.2348 24.4516 17.7498 24.4516 12.4548C24.4516 5.82477 19.0816 0.454773 12.5516 0.454773Z",
  
  twitter: "M22.869 2.41503C22.034 2.78503 21.137 3.03503 20.194 3.14803C21.167 2.56582 21.8949 1.64949 22.242 0.570028C21.3278 1.11302 20.3273 1.49522 19.284 1.70003C18.5824 0.950893 17.653 0.454354 16.6403 0.287502C15.6276 0.12065 14.5881 0.29282 13.6832 0.777281C12.7784 1.26174 12.0588 2.03139 11.6361 2.96673C11.2135 3.90207 11.1115 4.95078 11.346 5.95003C9.49367 5.85702 7.68121 5.39363 6.01626 4.58629C4.3513 3.77895 2.87283 2.64421 1.67 1.25003C1.269 1.92003 1.041 2.70103 1.041 3.53303C1.04062 4.2878 1.24706 5.02843 1.63717 6.67643C2.02728 7.32443 2.58768 7.85719 3.261 8.22003C2.55178 8.19503 1.86052 7.99465 1.253 7.63503V7.69203C1.25281 8.78176 1.63165 9.83647 2.32421 10.6821C3.01676 11.5278 3.97731 12.1066 5.047 12.316C4.39994 12.5002 3.71878 12.5313 3.058 12.407C3.37091 13.3426 3.97538 14.1564 4.78823 14.7291C5.60108 15.3018 6.57993 15.6035 7.587 15.591C5.85885 16.9491 3.70726 17.6992 1.486 17.725C1.13034 17.7277 0.775114 17.7059 0.423 17.66C2.69549 19.0969 5.36504 19.8721 8.094 19.888C16.1 19.888 20.511 12.561 20.511 6.26803C20.511 6.08403 20.507 5.89803 20.499 5.71403C21.3958 5.05779 22.1678 4.25133 22.777 3.33403L22.869 2.41503Z",
  
  linkedin: "M2.7206e-07 1.838C2.7206e-07 1.35053 0.193646 0.883032 0.538338 0.53834C0.88303 0.193648 1.35053 2.45031e-06 1.838 2.45031e-06H20.16C20.4016 -0.000392101 20.6409 0.0468654 20.8641 0.139069C21.0874 0.231273 21.2903 0.366612 21.4612 0.537339C21.6322 0.708065 21.7677 0.910826 21.8602 1.13401C21.9526 1.3572 22.0001 1.59643 22 1.838V20.16C22.0003 20.4016 21.9529 20.6431 21.8607 20.8664C21.7686 21.0898 21.6334 21.2928 21.4627 21.464C21.2921 21.6352 21.0893 21.7708 20.866 21.8635C20.6427 21.9562 20.4013 22.0042 20.159 22.006H1.838C1.35053 22.006 0.883032 21.8124 0.53834 21.4677C0.193648 21.123 2.45031e-06 20.6555 2.45031e-06 20.168L2.7206e-07 1.838ZM8.708 8.388V18.56H12.687V13.424C12.687 11.837 12.994 10.31 15.04 10.31C17.056 10.31 17.082 12.154 17.082 13.528V18.56H21.061V12.766C21.061 9.394 20.351 6.754 16.408 6.754C14.504 6.754 13.252 7.825 12.738 8.84H12.687V8.388H8.708ZM3.938 8.388H7.917V18.56H3.938V8.388ZM5.928 2.44C5.53477 2.44 5.15677 2.59633 4.87433 2.87877C4.59189 3.16121 4.43556 3.53921 4.43556 3.932C4.43556 4.32479 4.59189 4.70279 4.87433 4.98523C5.15677 5.26767 5.53477 5.424 5.928 5.424C6.32079 5.424 6.69879 5.26767 6.98123 4.98523C7.26367 4.70279 7.42 4.32479 7.42 3.932C7.42 3.53921 7.26367 3.16121 6.98123 2.87877C6.69879 2.59633 6.32079 2.44 5.928 2.44Z",
  
  instagram: "M6.465 0.066C7.638 0.012 8.012 0 11 0C13.988 0 14.362 0.013 15.534 0.066C16.706 0.119 17.506 0.306 18.206 0.577C18.939 0.854 19.604 1.287 20.154 1.847C20.714 2.396 21.146 3.06 21.422 3.794C21.694 4.494 21.88 5.294 21.934 6.464C21.988 7.639 22 8.013 22 11C22 13.988 21.987 14.362 21.934 15.535C21.881 16.705 21.694 17.505 21.422 18.205C21.146 18.9391 20.7133 19.6042 20.154 20.154C19.604 20.713 18.939 21.145 18.206 21.422C17.506 21.694 16.706 21.88 15.535 21.934C14.361 21.988 13.987 22 11 22C8.012 22 7.638 21.987 6.465 21.934C5.295 21.881 4.495 21.694 3.795 21.422C3.06092 21.146 2.39582 20.7133 1.847 20.154C1.28792 19.6042 0.854278 18.9391 0.577 18.205C0.306 17.505 0.119 16.705 0.066 15.535C0.012 14.361 0 13.987 0 11C0 8.012 0.013 7.638 0.066 6.465C0.119 5.294 0.306 4.494 0.577 3.794C0.854278 3.06092 1.28792 2.39582 1.847 1.847C2.39582 1.28792 3.06092 0.854278 3.794 0.577C4.494 0.306 5.294 0.119 6.464 0.066H6.465ZM15.445 2.046C14.285 1.993 13.937 1.982 11 1.982C8.063 1.982 7.715 1.993 6.555 2.046C5.482 2.095 4.9 2.274 4.512 2.425C3.999 2.625 3.632 2.862 3.247 3.247C2.88205 3.61077 2.59776 4.05277 2.425 4.543C2.274 4.9 2.095 5.482 2.046 6.555C1.993 7.715 1.982 8.063 1.982 11C1.982 13.937 1.993 14.285 2.046 15.445C2.095 16.518 2.274 17.1 2.425 17.488C2.598 17.9723 2.88205 18.4143 3.247 18.778C3.61077 19.143 4.05277 19.427 4.543 19.6C4.9 19.751 5.482 19.93 6.555 19.979C7.715 20.032 8.062 20.043 11 20.043C13.938 20.043 14.285 20.032 15.445 19.979C16.518 19.93 17.1 19.751 17.488 19.6C18.001 19.4 18.368 19.163 18.753 18.778C19.118 18.4143 19.402 17.9723 19.575 17.488C19.726 17.1 19.905 16.518 19.954 15.445C20.007 14.285 20.018 13.937 20.018 11C20.018 8.063 20.007 7.715 19.954 6.555C19.905 5.482 19.726 4.9 19.575 4.512C19.375 3.999 19.138 3.632 18.753 3.247C18.3893 2.88205 17.9473 2.59776 17.457 2.425C17.1 2.274 16.518 2.095 15.445 2.046ZM9.595 14.391C10.3797 14.7176 11.2534 14.7617 12.0669 14.5157C12.8805 14.2697 13.5834 13.7489 14.0556 13.0422C14.5278 12.3356 14.7401 11.4869 14.656 10.6411C14.572 9.79534 14.1971 9.00497 13.595 8.405C13.2112 8.02148 12.7472 7.72781 12.2363 7.54515C11.7255 7.36248 11.1804 7.29536 10.6405 7.34862C10.1006 7.40187 9.58034 7.57418 9.1138 7.85313C8.64727 8.13208 8.24617 8.51074 7.94049 8.96185C7.63482 9.41296 7.43251 9.92529 7.34757 10.4634C7.26263 11.0016 7.29687 11.5515 7.44813 12.0748C7.59939 12.5981 7.86404 13.0819 8.22225 13.4919C8.58045 13.9019 9.02347 14.2274 9.52 14.445L9.595 14.391ZM7.002 7.002C7.52702 6.47698 8.15032 6.0605 8.8363 5.78405C9.52229 5.50761 10.2575 5.36652 11 5.36652C11.7425 5.36652 12.4777 5.50761 13.1637 5.78405C13.8497 6.0605 14.473 6.47698 14.998 7.002C15.523 7.52702 15.9395 8.15032 16.2159 8.8363C16.4924 9.52229 16.6335 10.2575 16.6335 11C16.6335 11.7425 16.4924 12.4777 16.2159 13.1637C15.9395 13.8497 15.523 14.473 14.998 14.998C13.9368 16.0592 12.4982 16.6335 11 16.6335C9.50176 16.6335 8.06324 16.0592 7.002 14.998C5.94076 13.9368 5.36652 12.4982 5.36652 11C5.36652 9.50176 5.94076 8.06324 7.002 7.002ZM17.908 6.188C18.0381 6.06527 18.1423 5.91768 18.2143 5.75397C18.2863 5.59027 18.3248 5.41377 18.3274 5.23493C18.33 5.05609 18.2967 4.87855 18.2295 4.71281C18.1622 4.54707 18.0624 4.39651 17.936 4.27004C17.8095 4.14357 17.6589 4.04376 17.4932 3.97652C17.3275 3.90928 17.1499 3.87598 16.9711 3.87598C16.7922 3.87598 16.6147 3.90928 16.4489 3.97652C16.2832 4.04376 16.1326 4.14357 16.0062 4.27004C15.7589 4.51724 15.6117 4.85082 15.6117 5.19993C15.6117 5.54904 15.7589 5.88262 16.0062 6.12982C16.2534 6.37703 16.587 6.52420 16.9361 6.52420C17.2852 6.52420 17.6188 6.37703 17.866 6.12982L17.908 6.188Z",
  
  'external-link': "M18 13V19C18 19.5304 17.7893 20.0391 17.4142 20.4142C17.0391 20.7893 16.5304 21 16 21H5C4.46957 21 3.96086 20.7893 3.58579 20.4142C3.21071 20.0391 3 19.5304 3 19V8C3 7.46957 3.21071 6.96086 3.58579 6.58579C3.96086 6.21071 4.46957 6 5 6H11M15 3H21V9M10 14L21 3",
  
  folder: "M10 4H4C2.89543 4 2 4.89543 2 6V18C2 19.1046 2.89543 20 4 20H20C21.1046 20 22 19.1046 22 18V8C22 6.89543 21.1046 6 20 6H12L10 4Z"
}

const iconViewBoxes = {
  github: "0 0 25 24",
  twitter: "0 0 23 19", 
  linkedin: "0 0 22 22",
  instagram: "0 0 22 22",
  'external-link': "0 0 24 24",
  folder: "0 0 24 24"
}

const Icon: React.FC<IconProps> = ({ 
  type, 
  width = 24, 
  height = 24, 
  className = "", 
  fill = "currentColor" 
}) => {
  return (
    <svg
      width={width}
      height={height}
      viewBox={iconViewBoxes[type]}
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      className={className}
    >
      <path
        d={iconPaths[type]}
        fill={fill}
        stroke={type === 'external-link' ? "currentColor" : undefined}
        strokeWidth={type === 'external-link' ? "2" : undefined}
        strokeLinecap={type === 'external-link' ? "round" : undefined}
        strokeLinejoin={type === 'external-link' ? "round" : undefined}
      />
    </svg>
  )
}

export default Icon
</file>

<file path="src/components/FloatMail.tsx">
'use client'

import React from 'react'
import '@/styles/floatmail.scss'
import strings from '@/data/contact.json'

const FloatMail: React.FC = () => {
  return (
    <div className="floating-mail">
      <div className="floating-line"></div>
      <a className="mail" href={`mailto:${strings.socials.mail}`}>
        {strings.socials.mail}
      </a>
    </div>
  )
}

export default FloatMail
</file>

<file path="src/data/aboutme.json">
{
  "hero": {
    "greeting": "👋 Hi there! My name is",
    "name": "Sebastian Ruiz",
    "description": "I <del>break</del> build things for the web",
    "buttonText": "See my projects"
  },
  "aboutMeTitle": "About Me",
  "aboutMeText1": "I'm Sebastian Ruiz. A web developer, an eternal learner, a creative. <strong>I have internet and technology in my veins.</strong>",
  "aboutMeText2": "My work focuses on building Web Applications (And everything in between) using State of the Art web technologies such as <strong>React, NextJS, Javascript, Typescript, Webpack, etc.</strong> My self-taught spirit drives me to never stop learning.",
  "aboutMeText3": "I also have a big passion for being a person who <strong>shares knowledge</strong> and <strong>teaches people</strong> about whatever I learn, that's why I also work as a <strong>Mentor with the local communities</strong> to engage new people into the ecosystems and encourage them to build amazing things.",
  "aboutMeText4": "As a complement to my skills on the Web, I have learned about <strong>blockchain technologies</strong> such as <strong>Web3JS, HardHat, and Solidity Programming</strong> to deliver highly efficient Decentralized Apps and Smart contracts.",
  "aboutMeText5": "Earlier in my life I learned about <a href=\"https://www.behance.net/imsebarz\" target=\"_blank\">Design</a>, photography and Filmmaking. Skills that have been very helpful in my career. The guiding principle of everything I do is: <strong>I learn and then teach, and teaching is the way I learn.</strong>",
  "someTechnologiesTitle": "Some technologies I've used",
  "technologies": [
    "Javascript",
    "Typescript",
    "ReactJS",
    "NextJS",
    "CSS",
    "Sass",
    "Styled components",
    "HTML",
    "NodeJS",
    "MongoDB",
    "CI/CD",
    "Git/Github",
    "Github Actions",
    "Webpack",
    "Parcel",
    "Solidity",
    "Hardhat",
    "Unit Testing",
    "Microfrontends"
  ]
}
</file>

<file path="src/data/contact.json">
{
  "contactTitle": "Get in touch",
  "contactText": "I am willing to work with you or with your company, wherever you are from, in any challenge that involves web development, systems engineering or any creative process",
  "contactButton": "Say hello",
  "socials": {
    "behance": "https://www.behance.net/imsebarz",
    "github": "https://github.com/imsebarz",
    "linkedin": "https://www.linkedin.com/in/imsebarz/",
    "twitter": "https://twitter.com/imsebarz",
    "instagram": "https://www.instagram.com/imsebarz/",
    "mail": "imsebarz@gmail.com",
    "username": "@imsebarz"
  }
}
</file>

<file path="src/data/nav.json">
{
  "name": "Sebarz",
  "links": {
    "aboutMe": "About me",
    "featuredProjects": "Featured",
    "projects": "Projects",
    "contact": "Contact",
    "resume": "Resume"
  },
  "resumeLink": ""
}
</file>

<file path="src/data/projects.json">
{
  "projects": [
    {
      "id": 0,
      "name": "🎮 Manikins Arena",
      "description": "ReactJS Interactive landing page for an online videogame. page made for Life is The Game S.A.S",
      "tags": ["ReactJS", "Javascript", "Sass", "React Router", "Web3JS"],
      "img": "manikins.webp",
      "githubRepo": "https://github.com/imsebarz/manikins",
      "demo": "https://manikins.io",
      "featured": true
    },
    {
      "id": 1,
      "name": "🛒 Petit Store",
      "description": "A full responsive e-commerce for small business,  made on ReactJS, Using React Router, Sass, and the React Context API ",
      "tags": ["ReactJS", "Javascript", "Sass", "React Router", "Responsive"],
      "img": "petit.webp",
      "githubRepo": "https://github.com/imsebarz/petit-website",
      "demo": "https://petit-website.web.app/",
      "featured": true
    },

    {
      "id": 2,
      "name": "📷 Photolalaphy Portfolio",
      "description": "A responsive creative photography portfolio built on Javascript Using GSAP for animations and transitions",
      "tags": ["Javascript", "Sass", "GSAP", "Responsive"],
      "img": "lala.webp",
      "githubRepo": "https://github.com/imsebarz/lalaphoto",
      "demo": "https://imsebarz.github.io/lalaphoto/",
      "featured": true
    },
    {
      "id": 3,
      "name": "🔠 Lexical analyzer",
      "description": "A lexical analyzer for a programming language based on the Javascript Sintax. Is a Fullstack application with backend on Python and Javascript Frontend.",
      "tags": ["Fullstack", "Javascript", "API", "ReactJS", "Python"],
      "img": "",
      "githubRepo": "https://github.com/imsebarz/analizador-lexico",
      "demo": "https://analizador-lexico.netlify.app/",
      "featured": false
    },

    {
      "id": 4,
      "name": "🎬 MediaPlayer",
      "description": "An extensible media player. Implemented Plugins for Autoplay, AutoPause and Ads. Built using Typescript, OOP and Software Design patterns.",
      "tags": ["Typescript", "Javascript", "OOP", "Plugins"],
      "img": "",
      "githubRepo": "https://github.com/imsebarz/mediaplayer",
      "demo": "https://imsebarz.github.io/lalaphoto/",
      "featured": false
    },
    {
      "id": 5,
      "name": "🤖 FRIDAY Clone",
      "description": "Iron Man's Friday Clone, Web Application Build on Vanilla Javascript Using Web Speech Recognition and Speech To Text API's",
      "tags": [
        "Javascript",
        "Speech to text",
        "Speech Recognition",
        "svg animation"
      ],
      "img": "",
      "githubRepo": "https://github.com/imsebarz/FRIDAY",
      "demo": "https://imsebarz.github.io/FRIDAY/",
      "featured": false
    },
    {
      "id": 6,
      "name": "👩 Personal Cards",
      "description": "Website that fetchs random user data and shows a nice presentation card about each user. This website was built using Webpack for improve performance and optimization.",
      "tags": ["Javascript", "Webpack", "Sass", "HTML"],
      "img": "",
      "githubRepo": "https://github.com/imsebarz/webpack-project",
      "demo": "",
      "featured": false
    },
    {
      "id": 7,
      "name": "💰 Batatabit Landing page",
      "description": "Mobile-First landing page for a criptocurrency company. Page built using only HTML and CSS. ",
      "tags": ["HTML", "CSS", "Mobile-First", "Responsive"],
      "img": "",
      "githubRepo": "https://github.com/imsebarz/mobile-first",
      "demo": "https://imsebarz.github.io/mobile-first/",
      "featured": false
    },
    {
      "id": 8,
      "name": "📺 PlatziVideo",
      "description": "Video streaming platform Homepage. The site is build on ReactJS and bundled using Parcel ",
      "tags": ["Javascript", "Sass", "ReactJS", "Parcel", "API"],
      "img": "",
      "githubRepo": "https://github.com/imsebarz/platzivideo",
      "demo": "",
      "featured": false
    }
  ]
}
</file>

<file path="src/lib/animation.ts">
import { Variants } from 'framer-motion'
import { APP_CONFIG } from '@/config/constants'

const ANIMATION_CONFIG = {
  duration: APP_CONFIG.ANIMATION.DURATION.NORMAL,
  ease: APP_CONFIG.ANIMATION.EASING,
  staggerChildren: 0.1,
  offset: 50,
}

export const ContainerVariants: Variants = {
  hidden: {
    opacity: 0,
    y: ANIMATION_CONFIG.offset,
  },
  visible: {
    opacity: 1,
    y: 0,
    transition: {
      duration: ANIMATION_CONFIG.duration,
      type: 'tween',
      when: 'beforeChildren',
      staggerChildren: ANIMATION_CONFIG.staggerChildren,
    },
  },
}

export const FadeInVariants: Variants = {
  hidden: { 
    opacity: 0 
  },
  visible: { 
    opacity: 1,
    transition: {
      duration: ANIMATION_CONFIG.duration,
      type: 'tween',
    },
  },
}

export const SlideUpVariants: Variants = {
  hidden: { 
    opacity: 0, 
    y: ANIMATION_CONFIG.offset 
  },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: {
      duration: ANIMATION_CONFIG.duration,
      type: 'tween',
    },
  },
}

export const SlideInLeftVariants: Variants = {
  hidden: { 
    opacity: 0, 
    x: -ANIMATION_CONFIG.offset 
  },
  visible: { 
    opacity: 1, 
    x: 0,
    transition: {
      duration: ANIMATION_CONFIG.duration,
      type: 'tween',
    },
  },
}

export const SlideInRightVariants: Variants = {
  hidden: { 
    opacity: 0, 
    x: ANIMATION_CONFIG.offset 
  },
  visible: { 
    opacity: 1, 
    x: 0,
    transition: {
      duration: ANIMATION_CONFIG.duration,
      type: 'tween',
    },
  },
}

export const ScaleVariants: Variants = {
  hidden: { 
    opacity: 0, 
    scale: 0.8 
  },
  visible: { 
    opacity: 1, 
    scale: 1,
    transition: {
      duration: ANIMATION_CONFIG.duration,
      type: 'tween',
    },
  },
}

export const HeroVariants: Variants = {
  hidden: { 
    opacity: 0, 
    y: ANIMATION_CONFIG.offset * 2 
  },
  visible: { 
    opacity: 1, 
    y: 0,
    transition: {
      duration: ANIMATION_CONFIG.duration * 2,
      type: 'tween',
      when: 'beforeChildren',
      staggerChildren: ANIMATION_CONFIG.staggerChildren * 2,
    },
  },
}

export const ProjectCardVariants: Variants = {
  hidden: { 
    opacity: 0, 
    y: ANIMATION_CONFIG.offset,
    scale: 0.95
  },
  visible: { 
    opacity: 1, 
    y: 0,
    scale: 1,
    transition: {
      duration: ANIMATION_CONFIG.duration,
      type: 'tween',
    },
  },
}
</file>

<file path="src/lib/api-response.ts">
/**
 * Tipos de respuesta estandarizados para APIs
 */

export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: {
    message: string;
    code?: string;
    details?: unknown;
  };
  meta?: {
    timestamp: string;
    requestId?: string;
    duration?: number;
  };
}

export interface WebhookResponse {
  message: string;
  pageId?: string;
  eventAction?: 'create' | 'update' | 'skip';
  debounceTimeMs?: number;
  success?: boolean;
}

export interface HealthCheckResponse {
  status: 'healthy' | 'unhealthy';
  message: string;
  timestamp: string;
  version?: string;
  uptime?: number;
  endpoints?: Record<string, string>;
  features?: Record<string, boolean | string>;
  configuration?: Record<string, boolean>;
}

// Utility functions para crear respuestas consistentes
export function createSuccessResponse<T>(
  data: T, 
  meta?: Partial<ApiResponse['meta']>
): ApiResponse<T> {
  return {
    success: true,
    data,
    meta: {
      timestamp: new Date().toISOString(),
      ...meta,
    },
  };
}

export function createErrorResponse(
  message: string,
  code?: string,
  details?: unknown,
  meta?: Partial<ApiResponse['meta']>
): ApiResponse {
  return {
    success: false,
    error: {
      message,
      code,
      details,
    },
    meta: {
      timestamp: new Date().toISOString(),
      ...meta,
    },
  };
}

export function createWebhookResponse(
  message: string,
  options: Partial<WebhookResponse> = {}
): WebhookResponse {
  return {
    message,
    success: true,
    ...options,
  };
}
</file>

<file path="src/lib/helpers.ts">
import { useState, useEffect } from 'react'
import { APP_CONFIG } from '@/config/constants'

export const cn = (...classes: (string | undefined | null | false)[]): string => {
  return classes.filter(Boolean).join(' ')
}

export const getTransition = (duration: keyof typeof APP_CONFIG.ANIMATION.DURATION = 'NORMAL'): string => {
  return `all ${APP_CONFIG.ANIMATION.DURATION[duration]}s ${APP_CONFIG.ANIMATION.EASING}`
}

export const isMobile = (width: number): boolean => {
  return width < APP_CONFIG.NAVIGATION.MOBILE_BREAKPOINT
}

export const getImageUrl = (imageName: string): string => {
  return `${APP_CONFIG.PATHS.IMAGES}${imageName}`
}

export const isExternalUrl = (url: string): boolean => {
  return url.startsWith('http://') || url.startsWith('https://')
}

export const createSlug = (text: string): string => {
  return text
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
}

export const debounce = <T extends (...args: unknown[]) => void>(
  func: T,
  delay: number
): ((...args: Parameters<T>) => void) => {
  let timeoutId: NodeJS.Timeout
  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => func(...args), delay)
  }
}

export const useMediaQuery = (query: string): boolean => {
  const [matches, setMatches] = useState(false)

  useEffect(() => {
    const media = window.matchMedia(query)
    if (media.matches !== matches) {
      setMatches(media.matches)
    }
    
    const listener = () => setMatches(media.matches)
    media.addEventListener('change', listener)
    
    return () => media.removeEventListener('change', listener)
  }, [matches, query])

  return matches
}

export const useIsMobile = (): boolean => {
  return useMediaQuery(`(max-width: ${APP_CONFIG.NAVIGATION.MOBILE_BREAKPOINT}px)`)
}
</file>

<file path="src/lib/index.ts">
/**
 * Exportaciones centralizadas para lib
 */

export { config, validateEnvironment } from './config';
export { logger } from './logger';
export { 
  createSuccessResponse, 
  createErrorResponse, 
  createWebhookResponse 
} from './api-response';
export type { 
  ApiResponse, 
  WebhookResponse, 
  HealthCheckResponse 
} from './api-response';
</file>

<file path="src/lib/logger.ts">
/**
 * Logger centralizado para la aplicación
 */

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export interface LogContext {
  [key: string]: unknown;
}

class Logger {
  private isDevelopment: boolean;

  constructor() {
    this.isDevelopment = process.env.NODE_ENV === 'development';
  }

  private formatMessage(level: LogLevel, message: string, context?: LogContext): string {
    const timestamp = new Date().toISOString();
    const emoji = this.getEmoji(level);
    const contextStr = context ? ` ${JSON.stringify(context, null, 2)}` : '';
    
    return `[${timestamp}] ${emoji} ${level.toUpperCase()}: ${message}${contextStr}`;
  }

  private getEmoji(level: LogLevel): string {
    switch (level) {
      case 'debug': return '🔍';
      case 'info': return 'ℹ️';
      case 'warn': return '⚠️';
      case 'error': return '❌';
      default: return '📝';
    }
  }

  debug(message: string, context?: LogContext): void {
    if (this.isDevelopment) {
      console.debug(this.formatMessage('debug', message, context));
    }
  }

  info(message: string, context?: LogContext): void {
    console.info(this.formatMessage('info', message, context));
  }

  warn(message: string, context?: LogContext): void {
    console.warn(this.formatMessage('warn', message, context));
  }

  error(message: string, error?: Error | unknown, context?: LogContext): void {
    const errorContext: LogContext = {
      ...context,
      ...(error instanceof Error && {
        error: {
          name: error.name,
          message: error.message,
          stack: error.stack,
        }
      })
    };
    
    console.error(this.formatMessage('error', message, errorContext));
  }

  // Métodos específicos para webhooks
  webhookReceived(payload: unknown, requestId?: string): void {
    this.info('Webhook received', { 
      requestId,
      payloadType: typeof payload,
      hasPayload: !!payload 
    });
  }

  webhookProcessed(pageId: string, action: string, requestId?: string): void {
    this.info('Webhook processed successfully', { 
      pageId, 
      action,
      requestId 
    });
  }

  webhookError(error: Error, pageId?: string, requestId?: string): void {
    this.error('Webhook processing failed', error, { 
      pageId,
      requestId 
    });
  }
}

// Singleton instance
export const logger = new Logger();
</file>

<file path="src/middleware/error-handler.ts">
/**
 * Middleware para manejo de errores en APIs
 */

import { NextRequest, NextResponse } from 'next/server';
import { logger } from '@/lib/logger';
import { createErrorResponse } from '@/lib/api-response';

export type ApiHandler = (request: NextRequest) => Promise<NextResponse>;

export interface ErrorHandlerOptions {
  logErrors?: boolean;
  includeStack?: boolean;
}

/**
 * Wrapper para manejar errores de forma consistente en las rutas de API
 */
export function withErrorHandler(
  handler: ApiHandler,
  options: ErrorHandlerOptions = {}
): ApiHandler {
  const { logErrors = true, includeStack = false } = options;

  return async (request: NextRequest): Promise<NextResponse> => {
    const startTime = Date.now();
    const requestId = generateRequestId();

    try {
      // Log incoming request
      if (logErrors) {
        logger.info('API request received', {
          requestId,
          method: request.method,
          url: request.url,
          userAgent: request.headers.get('user-agent'),
        });
      }

      const response = await handler(request);
      
      // Log successful response
      if (logErrors) {
        const duration = Date.now() - startTime;
        logger.info('API request completed', {
          requestId,
          status: response.status,
          duration,
        });
      }

      return response;
    } catch (error) {
      const duration = Date.now() - startTime;
      
      if (logErrors) {
        logger.error('API request failed', error, {
          requestId,
          method: request.method,
          url: request.url,
          duration,
        });
      }

      // Determine error status and message
      const { status, message, code } = getErrorDetails(error);
      
      const errorResponse = createErrorResponse(
        message,
        code,
        includeStack && error instanceof Error ? error.stack : undefined,
        { requestId, duration }
      );

      return NextResponse.json(errorResponse, { status });
    }
  };
}

/**
 * Extrae detalles del error para crear una respuesta apropiada
 */
function getErrorDetails(error: unknown): {
  status: number;
  message: string;
  code?: string;
} {
  if (error instanceof Error) {
    // Custom error types
    if (error.name === 'ValidationError') {
      return { status: 400, message: error.message, code: 'VALIDATION_ERROR' };
    }
    
    if (error.name === 'NotFoundError') {
      return { status: 404, message: error.message, code: 'NOT_FOUND' };
    }
    
    if (error.name === 'UnauthorizedError') {
      return { status: 401, message: error.message, code: 'UNAUTHORIZED' };
    }

    // Generic error
    return { 
      status: 500, 
      message: error.message || 'Internal server error',
      code: 'INTERNAL_ERROR'
    };
  }

  // Unknown error type
  return { 
    status: 500, 
    message: 'Unknown error occurred',
    code: 'UNKNOWN_ERROR'
  };
}

/**
 * Genera un ID único para la request
 */
function generateRequestId(): string {
  return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Custom error classes
 */
export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class NotFoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'NotFoundError';
  }
}

export class UnauthorizedError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'UnauthorizedError';
  }
}
</file>

<file path="src/services/webhooks/todoist-webhook.service.ts">
/**
 * Servicio para manejar webhooks de Todoist que actualizan Notion
 */

import { TodoistWebhookPayload } from '@/types/notion-todoist';
import { logger } from '@/lib/logger';
import { ValidationError } from '@/middleware/error-handler';
import { 
  isValidTodoistPayload,
  isValidTodoistWebhook,
  shouldProcessTodoistEvent,
  extractNotionPageId,
  getCompletedStatusForNotion,
  getUncompletedStatusForNotion
} from '@/utils/todoist-webhook-validator';
import { updateNotionPageStatus } from '@/utils/notion-client';

export class TodoistWebhookService {
  
  /**
   * Procesa un webhook de Todoist
   */
  async processWebhook(
    payload: TodoistWebhookPayload,
    headers: Record<string, string | null>,
    rawBody: string
  ): Promise<{
    message: string;
    taskId?: string;
    notionPageId?: string;
    eventType?: string;
  }> {
    // 1. Validar estructura del payload
    if (!isValidTodoistPayload(payload)) {
      throw new ValidationError('Invalid Todoist webhook payload structure');
    }

    // 2. Validar autenticidad del webhook
    const signature = headers['x-todoist-hmac-sha256'];
    const secret = process.env.TODOIST_WEBHOOK_SECRET;
    
    if (secret && !isValidTodoistWebhook(rawBody, signature, secret)) {
      throw new ValidationError('Invalid Todoist webhook signature');
    }

    // 3. Verificar si el evento debe ser procesado
    if (!shouldProcessTodoistEvent(payload)) {
      logger.info('Todoist event skipped - not a completion with Notion reference', {
        eventName: payload.event_name,
        taskId: payload.event_data?.id
      });
      
      return {
        message: 'Event skipped - not relevant for Notion sync',
        eventType: payload.event_name,
        taskId: payload.event_data?.id
      };
    }

    // 4. Procesar evento según el tipo
    if (payload.event_name === 'item:completed') {
      return await this.processTaskCompletion(payload);
    } else if (payload.event_name === 'item:uncompleted') {
      return await this.processTaskUncompletion(payload);
    }

    throw new Error(`Unsupported event type: ${payload.event_name}`);
  }

  /**
   * Procesa el completado de una tarea de Todoist
   */
  private async processTaskCompletion(
    payload: TodoistWebhookPayload
  ): Promise<{
    message: string;
    taskId: string;
    notionPageId?: string;
    eventType: string;
  }> {
    const taskData = payload.event_data;
    const taskId = taskData.id;
    const description = taskData.description;

    logger.info('Processing Todoist task completion', {
      taskId,
      taskTitle: taskData.content,
      completedAt: taskData.completed_at,
      userId: payload.user_id
    });

    try {
      // Extraer ID de página de Notion de la descripción
      const notionPageId = extractNotionPageId(description);
      
      if (!notionPageId) {
        logger.warn('No Notion page ID found in task description', {
          taskId,
          description: description.substring(0, 100) + '...'
        });
        
        return {
          message: 'Task completed but no Notion page ID found in description',
          taskId,
          eventType: payload.event_name
        };
      }

      // Actualizar status en Notion
      const completedStatus = getCompletedStatusForNotion();
      await updateNotionPageStatus(notionPageId, completedStatus);

      logger.info('Successfully updated Notion page status', {
        taskId,
        notionPageId,
        newStatus: completedStatus,
        taskTitle: taskData.content
      });

      return {
        message: 'Task completion synced to Notion successfully',
        taskId,
        notionPageId,
        eventType: payload.event_name
      };

    } catch (error) {
      logger.error('Error processing Todoist task completion', error as Error, {
        taskId,
        taskTitle: taskData.content,
        description: description.substring(0, 100) + '...'
      });

      throw new Error(`Failed to sync task completion to Notion: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Procesa cuando una tarea es desmarcada como completada
   */
  private async processTaskUncompletion(
    payload: TodoistWebhookPayload
  ): Promise<{
    message: string;
    taskId: string;
    notionPageId?: string;
    eventType: string;
  }> {
    const taskData = payload.event_data!;
    const taskId = taskData.id;

    logger.info('Processing Todoist task uncompletion', {
      taskId,
      taskTitle: taskData.content,
      userId: payload.user_id
    });

    try {
      // Extraer ID de página de Notion
      const notionPageId = extractNotionPageId(taskData.description || '');
      
      if (!notionPageId) {
        logger.warn('No Notion page ID found in task description', {
          taskId,
          description: taskData.description?.substring(0, 100) + '...'
        });
        
        return {
          message: 'Task uncompleted but no Notion page ID found in description',
          taskId,
          eventType: payload.event_name
        };
      }

      // Actualizar status en Notion a estado "no completado"
      const uncompletedStatus = getUncompletedStatusForNotion();
      await updateNotionPageStatus(notionPageId, uncompletedStatus);

      logger.info('Successfully updated Notion page status to uncompleted', {
        taskId,
        notionPageId,
        newStatus: uncompletedStatus,
        taskTitle: taskData.content
      });

      return {
        message: 'Task uncompletion synced to Notion successfully',
        taskId,
        notionPageId,
        eventType: payload.event_name
      };
    } catch (error) {
      logger.error('Error processing Todoist task uncompletion', {
        taskId,
        taskTitle: taskData.content,
        description: taskData.description?.substring(0, 100) + '...',
        error
      });

      throw new Error(`Failed to sync task uncompletion to Notion: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Valida el webhook y sus headers
   */
  private validateWebhook(
    payload: TodoistWebhookPayload,
    headers: Record<string, string | null>
  ): void {
    // Verificar Content-Type
    const contentType = headers['content-type'];
    if (!contentType || !contentType.includes('application/json')) {
      throw new ValidationError('Invalid content type. Expected application/json');
    }

    // Verificar User-Agent de Todoist
    const userAgent = headers['user-agent'];
    if (userAgent && !userAgent.includes('Todoist-Webhooks')) {
      logger.warn('Unexpected User-Agent for Todoist webhook', { userAgent });
    }

    // Verificar que tenemos los datos mínimos requeridos
    if (!payload.event_name || !payload.user_id || !payload.event_data) {
      throw new ValidationError('Missing required webhook data');
    }
  }
}
</file>

<file path="src/styles/colors.scss">
$mint: #eefff3;
$green: #004747;
$pepper: #403d39ff;
$black: #252422ff;
$orange: #eb5e28ff;
</file>

<file path="src/styles/featuredprojects.scss">
.featuredProjects {
  display: flex;
  margin: 0 5em;
  flex-direction: column;
  place-items: center;
  gap: 5em;
}

.featuredProjects-container {
  display: flex;
  flex-direction: column;
  gap: 3em;
}

@media screen and (max-width: 905px) {
  .featuredProjects {
    margin: 0;
  }
}
</file>

<file path="src/types/assets.d.ts">
declare module '*.svg' {
  const content: string
  export default content
}

declare module '*.png' {
  const content: string
  export default content
}

declare module '*.jpg' {
  const content: string
  export default content
}

declare module '*.jpeg' {
  const content: string
  export default content
}

declare module '*.webp' {
  const content: string
  export default content
}

declare module '*.gif' {
  const content: string
  export default content
}

declare module '*.ico' {
  const content: string
  export default content
}

declare module '*.otf' {
  const content: string
  export default content
}

declare module '*.ttf' {
  const content: string
  export default content
}

declare module '*.woff' {
  const content: string
  export default content
}

declare module '*.woff2' {
  const content: string
  export default content
}
</file>

<file path="src/utils/tag-helpers.ts">
/**
 * Utility functions for processing workspace and tag names
 */

/**
 * Converts a workspace name to a valid Todoist label
 * @param workspaceName - The original workspace name from Notion
 * @returns A sanitized label name suitable for Todoist
 */
export function createWorkspaceTag(workspaceName: string): string {
  return workspaceName
    .toLowerCase()
    .replace(/\s+/g, '-')           // Replace spaces with hyphens
    .replace(/[^a-z0-9\-_]/g, '')   // Remove invalid characters, keep letters, numbers, hyphens, underscores
    .replace(/^-+|-+$/g, '')        // Remove leading/trailing hyphens
    .substring(0, 50);              // Todoist label limit is 100 chars, being conservative
}

/**
 * Combines base tags with workspace tag, ensuring no duplicates
 * @param baseTags - Original tags from AI or default
 * @param workspaceTag - Sanitized workspace tag
 * @returns Array of unique tags
 */
export function combineTagsWithWorkspace(baseTags: string[], workspaceTag: string): string[] {
  const allTags = [...baseTags];
  
  // Only add workspace tag if it's not already present and is valid
  if (workspaceTag && !allTags.includes(workspaceTag)) {
    allTags.push(workspaceTag);
  }
  
  return allTags;
}
</file>

<file path="src/utils/todoist-webhook-validator.ts">
/**
 * Validadores para webhooks de Todoist
 */

import crypto from 'crypto';
import { TodoistWebhookPayload } from '@/types/notion-todoist';

/**
 * Valida si un webhook de Todoist es válido usando HMAC
 */
export function isValidTodoistWebhook(
  payload: string,
  signature: string | null,
  secret: string
): boolean {
  if (!signature || !secret) {
    return false;
  }

  try {
    // Todoist envía la firma en formato: SHA256=<hash>
    const expectedSignature = crypto
      .createHmac('sha256', secret)
      .update(payload, 'utf8')
      .digest('base64');

    // La firma viene como "UEEq9si3Vf9yRSrLthbpazbb69kP9+CZQ7fXmVyjhPs="
    return signature === expectedSignature;
  } catch (error) {
    console.error('Error validating Todoist webhook signature:', error);
    return false;
  }
}

/**
 * Determina si el evento de Todoist debe ser procesado
 */
export function shouldProcessTodoistEvent(payload: TodoistWebhookPayload): boolean {
  // Solo procesar eventos de items completados y no completados
  if (payload.event_name !== 'item:completed' && payload.event_name !== 'item:uncompleted') {
    return false;
  }

  // Verificar que el evento tenga los datos necesarios
  if (!payload.event_data || !payload.event_data.id || !payload.event_data.description) {
    return false;
  }

  // Verificar que la tarea tenga una referencia a Notion en la descripción
  const description = payload.event_data.description;
  const hasNotionReference = description.includes('notion.so/') || 
                           description.includes('www.notion.so/') ||
                           description.includes('notion.com/');

  return hasNotionReference;
}

/**
 * Extrae el ID de página de Notion de la descripción de la tarea de Todoist
 */
export function extractNotionPageId(description: string): string | null {
  try {
    // Buscar patrones de URL de Notion
    const patterns = [
      // Patrones directos con ID
      /notion\.so\/([a-f0-9]{32})/i,
      /notion\.so\/([a-f0-9-]{36})/i,
      /www\.notion\.so\/([a-f0-9]{32})/i,
      /www\.notion\.so\/([a-f0-9-]{36})/i,
      /notion\.com\/([a-f0-9]{32})/i,
      /notion\.com\/([a-f0-9-]{36})/i,
      
      // Patrones con título de página seguido de ID
      /notion\.so\/[^\/\s]*-([a-f0-9]{32})/i,
      /notion\.so\/[^\/\s]*-([a-f0-9-]{36})/i,
      /www\.notion\.so\/[^\/\s]*-([a-f0-9]{32})/i,
      /www\.notion\.so\/[^\/\s]*-([a-f0-9-]{36})/i,
      /notion\.com\/[^\/\s]*-([a-f0-9]{32})/i,
      /notion\.com\/[^\/\s]*-([a-f0-9-]{36})/i,
    ];

    for (const pattern of patterns) {
      const match = description.match(pattern);
      if (match && match[1]) {
        let pageId = match[1];
        
        // Si el ID no tiene guiones, agregarlos en el formato correcto
        if (pageId.length === 32 && !pageId.includes('-')) {
          pageId = [
            pageId.slice(0, 8),
            pageId.slice(8, 12),
            pageId.slice(12, 16),
            pageId.slice(16, 20),
            pageId.slice(20)
          ].join('-');
        }
        
        return pageId;
      }
    }

    return null;
  } catch (error) {
    console.error('Error extracting Notion page ID from description:', error);
    return null;
  }
}

/**
 * Valida la estructura básica del payload de Todoist
 */
export function isValidTodoistPayload(payload: unknown): payload is TodoistWebhookPayload {
  if (!payload || typeof payload !== 'object') {
    return false;
  }

  const obj = payload as Record<string, unknown>;
  
  return Boolean(
    typeof obj.event_name === 'string' &&
    typeof obj.user_id === 'string' &&
    obj.event_data &&
    typeof obj.event_data === 'object' &&
    typeof obj.triggered_at === 'string'
  );
}

/**
 * Obtiene el estado de completado apropiado para Notion
 */
export function getCompletedStatusForNotion(): string {
  // Puedes configurar esto según los estados que uses en tu Notion
  return 'Completado';
}

/**
 * Obtiene el estado de no completado apropiado para Notion
 */
export function getUncompletedStatusForNotion(): string {
  // Estados comunes para tareas pendientes/en progreso
  return 'En progreso';
}
</file>

<file path=".eslintrc.json">
{
  "extends": [
    "next/core-web-vitals",
    "next/typescript"
  ],
  "rules": {
    // Reglas de calidad de código
    "prefer-const": "error",
    "no-var": "error",
    "no-unused-vars": "off", // Deshabilitado en favor de @typescript-eslint/no-unused-vars
    "@typescript-eslint/no-unused-vars": [
      "error",
      {
        "argsIgnorePattern": "^_",
        "varsIgnorePattern": "^_",
        "caughtErrorsIgnorePattern": "^_"
      }
    ],
    
    // Reglas de React
    "react/jsx-key": "error",
    "react/jsx-no-duplicate-props": "error",
    "react/jsx-no-undef": "error",
    "react/no-children-prop": "error",
    "react/no-unescaped-entities": "warn",
    
    // Reglas de hooks
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn",
    
    // Reglas de accesibilidad básicas
    "jsx-a11y/alt-text": "warn",
    "jsx-a11y/anchor-has-content": "warn",
    "jsx-a11y/no-redundant-roles": "warn",
    
    // Reglas de estilo opcional
    "import/order": [
      "warn",
      {
        "groups": [
          "builtin",
          "external",
          "internal",
          "parent",
          "sibling",
          "index"
        ],
        "newlines-between": "never"
      }
    ]
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  }
}
</file>

<file path="jest.setup.js">
// Jest setup file
// Configuración global para tests

// Mock de variables de entorno para tests
process.env.NOTION_USER_ID = 'test-user-id';
process.env.TODOIST_PROJECT_ID = 'test-project-id';
process.env.ENABLE_AI_ENHANCEMENT = 'true';
process.env.OPENAI_API_KEY = 'test-openai-key';

// Mock global de console para tests más limpios
global.console = {
  ...console,
  log: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  info: jest.fn(),
};
</file>

<file path="site.webmanifest">
{"name":"","short_name":"","icons":[{"src":"/android-chrome-192x192.png","sizes":"192x192","type":"image/png"},{"src":"/android-chrome-512x512.png","sizes":"512x512","type":"image/png"}],"theme_color":"#ffffff","background_color":"#ffffff","display":"standalone"}
</file>

<file path="test-notion-id.js">
// Test rápido para verificar extracción de ID de Notion
const description = `Esta tarea consiste en contactar a Pascual para obtener las medidas necesarias relacionadas con el proyecto actual. Se debe recopilar toda la información precisa y asegurarse de que las medidas sean correctas para evitar errores en etapas posteriores. Revisar la información disponible en el enlace proporcionado para mayor contexto y registrar las medidas recibidas para uso futuro.

🔗 Ver en Notion:  https://www.notion.so/Pedir-medidas-de-pascual-2321ad4d650d800bac4df93e5c760f38 
📁 Workspace: Corabella Pets`;

// Simulamos la función extractNotionPageId
function extractNotionPageId(description) {
  try {
    const patterns = [
      // Patrones directos con ID
      /notion\.so\/([a-f0-9]{32})/i,
      /notion\.so\/([a-f0-9-]{36})/i,
      /www\.notion\.so\/([a-f0-9]{32})/i,
      /www\.notion\.so\/([a-f0-9-]{36})/i,
      /notion\.com\/([a-f0-9]{32})/i,
      /notion\.com\/([a-f0-9-]{36})/i,
      
      // Patrones con título de página seguido de ID
      /notion\.so\/[^\/\s]*-([a-f0-9]{32})/i,
      /notion\.so\/[^\/\s]*-([a-f0-9-]{36})/i,
      /www\.notion\.so\/[^\/\s]*-([a-f0-9]{32})/i,
      /www\.notion\.so\/[^\/\s]*-([a-f0-9-]{36})/i,
      /notion\.com\/[^\/\s]*-([a-f0-9]{32})/i,
      /notion\.com\/[^\/\s]*-([a-f0-9-]{36})/i,
    ];

    for (const pattern of patterns) {
      const match = description.match(pattern);
      if (match && match[1]) {
        let pageId = match[1];
        
        // Si el ID no tiene guiones, agregarlos en el formato correcto
        if (pageId.length === 32 && !pageId.includes('-')) {
          pageId = [
            pageId.slice(0, 8),
            pageId.slice(8, 12),
            pageId.slice(12, 16),
            pageId.slice(16, 20),
            pageId.slice(20)
          ].join('-');
        }
        
        return pageId;
      }
    }
    
    return null;
  } catch (error) {
    return null;
  }
}

const extractedId = extractNotionPageId(description);
console.log('Descripción:', description);
console.log('\nID extraído:', extractedId);
console.log('ID formateado:', extractedId ? extractedId : 'NO ENCONTRADO');
</file>

<file path="TODO">
Reducir deuda tecnica.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "es6"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@/components/*": ["./src/components/*"],
      "@/assets/*": ["./src/assets/*"],
      "@/styles/*": ["./src/styles/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="__tests__/meal-plan-service.test.ts">
import { MealPlanService } from '@/services/meal-plan.service';
import { logger } from '@/lib/logger';

// Mock de dependencias
jest.mock('@/lib/logger', () => ({
  logger: {
    info: jest.fn(),
    error: jest.fn(),
    warn: jest.fn(),
  },
}));

// Mock de fetch global
const mockFetch = jest.fn();
global.fetch = mockFetch;

// Mock de crypto para UUID generation
Object.defineProperty(globalThis, 'crypto', {
  value: {
    randomUUID: jest.fn(() => 'mock-uuid-1234'),
  },
});

describe('MealPlanService', () => {
  let service: MealPlanService;
  let originalEnv: NodeJS.ProcessEnv;

  beforeEach(() => {
    // Guardar variables de entorno originales
    originalEnv = { ...process.env };
    
    // Configurar variables de entorno para testing
    process.env.TODOIST_API_TOKEN_MEAL_PLAN = 'test-token-meal-plan';
    process.env.TODOIST_MEAL_PLAN_PROJECT_ID = 'test-project-id';
    process.env.TODOIST_MEAL_PLAN_FILTER_NAME = 'Test Meal Plan Filter';

    service = new MealPlanService();
    jest.clearAllMocks();
    mockFetch.mockClear();
  });

  afterEach(() => {
    // Restaurar variables de entorno
    process.env = originalEnv;
  });

  describe('Constructor', () => {
    it('should initialize with environment variables', () => {
      expect(service).toBeInstanceOf(MealPlanService);
    });

    it('should throw error when TODOIST_API_TOKEN is missing', () => {
      delete process.env.TODOIST_API_TOKEN_MEAL_PLAN;
      delete process.env.TODOIST_API_TOKEN;
      
      expect(() => new MealPlanService()).toThrow('TODOIST_API_TOKEN_MEAL_PLAN or TODOIST_API_TOKEN is required');
    });

    it('should throw error when project ID is missing', () => {
      delete process.env.TODOIST_MEAL_PLAN_PROJECT_ID;
      delete process.env.TODOIST_DAILY_PROJECT_ID;
      
      expect(() => new MealPlanService()).toThrow('TODOIST_MEAL_PLAN_PROJECT_ID or TODOIST_DAILY_PROJECT_ID is required');
    });

    it('should fallback to general tokens when specific ones are not available', () => {
      delete process.env.TODOIST_API_TOKEN_MEAL_PLAN;
      delete process.env.TODOIST_MEAL_PLAN_PROJECT_ID;
      process.env.TODOIST_API_TOKEN = 'fallback-token';
      process.env.TODOIST_DAILY_PROJECT_ID = 'fallback-project-id';

      expect(() => new MealPlanService()).not.toThrow();
    });
  });

  describe('processMealPlan', () => {
    const mockSections = [
      { id: 'section-1', name: 'Lunes', project_id: 'test-project-id' },
      { id: 'section-2', name: 'Martes', project_id: 'test-project-id' },
      { id: 'section-3', name: 'Miércoles', project_id: 'test-project-id' },
      { id: 'section-4', name: 'Jueves', project_id: 'test-project-id' },
      { id: 'section-5', name: 'Viernes', project_id: 'test-project-id' },
      { id: 'section-6', name: 'Sábado', project_id: 'test-project-id' },
      { id: 'section-7', name: 'Domingo', project_id: 'test-project-id' },
    ];

    const mockTasks = [
      {
        id: 'task-1',
        content: 'Desayuno - Avena con frutas',
        description: 'Preparar avena con plátano y fresas',
        section_id: 'section-2',
        project_id: 'test-project-id',
        is_completed: false,
        labels: ['mealprep', 'breakfast']
      },
      {
        id: 'task-2',
        content: 'Almuerzo - Ensalada de pollo',
        description: 'Ensalada verde con pollo a la plancha',
        section_id: 'section-2',
        project_id: 'test-project-id',
        is_completed: false,
        labels: ['mealprep', 'lunch']
      },
      {
        id: 'task-3',
        content: 'Tarea sin meal plan',
        description: 'Esta no debería aparecer',
        section_id: 'section-2',
        project_id: 'test-project-id',
        is_completed: false,
        labels: ['grocery']
      },
      {
        id: 'task-4',
        content: 'Cena completada',
        description: 'Esta está completada',
        section_id: 'section-2',
        project_id: 'test-project-id',
        is_completed: true,
        labels: ['mealprep', 'dinner']
      }
    ];

    const mockProjectInfo = {
      id: 'test-project-id',
      name: 'Alimentación'
    };

    const mockFilters = [
      {
        id: 'filter-1',
        name: 'Test Meal Plan Filter',
        query: '#Alimentación & /Martes & @mealprep & !subtask',
        color: 'green',
        favorite: true
      }
    ];

    it('should process meal plan successfully for next day', async () => {
      // Configurar mocks en orden de llamada
      mockFetch
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockSections),
        }) // getSections
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockProjectInfo),
        }) // getProjectInfo
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({ filters: mockFilters }),
        }) // get filters (sync)
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({}),
        }) // update filter
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockTasks),
        }); // getTasksFromSection

      const result = await service.processMealPlan();

      expect(result.success).toBe(true);
      expect(result.tasksCount).toBe(2); // Solo las tareas con mealprep que no están completadas
      expect(result.tasks).toHaveLength(2);
      expect(result.tasks[0].labels).toContain('mealprep');
      expect(result.tasks[1].labels).toContain('mealprep');
      
      expect(logger.info).toHaveBeenCalledWith('Processing meal plan for next day', expect.objectContaining({
        projectId: 'test-project-id'
      }));
    });

    it('should handle when no section is found for next day', async () => {
      // Mock secciones sin el día siguiente
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve([{ id: 'section-1', name: 'Otra Sección', project_id: 'test-project-id' }]),
      });

      const result = await service.processMealPlan();

      expect(result.success).toBe(false);
      expect(result.error).toContain('No se encontró sección para el día siguiente');
      expect(logger.warn).toHaveBeenCalled();
    });

    it('should filter tasks correctly (only mealprep and not completed)', async () => {
      // Mock básico
      mockFetch
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockSections),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockProjectInfo),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({ filters: mockFilters }),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({}),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockTasks),
        });

      const result = await service.processMealPlan();

      expect(result.success).toBe(true);
      expect(result.tasksCount).toBe(2);
      
      // Verificar que todas las tareas retornadas tienen la etiqueta mealprep y no están completadas
      result.tasks.forEach(task => {
        expect(task.labels).toContain('mealprep');
        expect(task.is_completed).toBe(false);
      });
    });

    it('should handle API errors gracefully', async () => {
      mockFetch.mockRejectedValueOnce(new Error('API Error'));

      const result = await service.processMealPlan();

      expect(result.success).toBe(false);
      expect(result.error).toBe('API Error');
      expect(logger.error).toHaveBeenCalledWith('Error processing meal plan', expect.objectContaining({
        error: expect.any(Error)
      }));
    });

    it('should handle fetch errors for sections', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 401,
        statusText: 'Unauthorized',
      });

      const result = await service.processMealPlan();

      expect(result.success).toBe(false);
      expect(result.error).toContain('Failed to fetch sections: 401');
    });
  });

  describe('getProjectInfo', () => {
    beforeEach(() => {
      mockFetch.mockClear();
    });

    it('should return project info successfully', async () => {
      const mockProject = {
        id: 'test-project-id',
        name: 'Alimentación'
      };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockProject),
      });

      const result = await service.getProjectInfo();

      expect(result).toEqual(mockProject);
      expect(mockFetch).toHaveBeenCalledWith(
        'https://api.todoist.com/rest/v2/projects/test-project-id',
        expect.objectContaining({
          headers: { 'Authorization': 'Bearer test-token-meal-plan' }
        })
      );
    });

    it('should return null when project fetch fails', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 404,
        statusText: 'Not Found',
      });

      const result = await service.getProjectInfo();

      expect(result).toBeNull();
      expect(logger.error).toHaveBeenCalledWith('Error fetching project info', expect.objectContaining({
        error: expect.any(Error),
        projectId: 'test-project-id'
      }));
    });

    it('should handle network errors', async () => {
      mockFetch.mockRejectedValueOnce(new Error('Network error'));

      const result = await service.getProjectInfo();

      expect(result).toBeNull();
      expect(logger.error).toHaveBeenCalled();
    });
  });

  describe('Day calculation integration', () => {
    beforeEach(() => {
      mockFetch.mockClear();
    });

    it('should process tasks when section is found', async () => {
      // Mock secciones que incluyan posiblemente el día siguiente
      const mockSections = [
        { id: 'section-1', name: 'Lunes', project_id: 'test-project-id' },
        { id: 'section-2', name: 'Martes', project_id: 'test-project-id' },
        { id: 'section-7', name: 'Domingo', project_id: 'test-project-id' },
      ];

      const mockProjectInfo = { id: 'test-project-id', name: 'Alimentación' };
      const mockFilters: Array<{ id: string; name: string; query: string; color: string; favorite: boolean }> = [];
      const mockTasks = [
        {
          id: 'task-1',
          content: 'Meal plan task',
          description: 'Una tarea de meal plan',
          section_id: 'section-7',
          project_id: 'test-project-id',
          is_completed: false,
          labels: ['mealprep', 'brunch']
        }
      ];

      mockFetch
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockSections),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockProjectInfo),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({ filters: mockFilters }),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({}),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({ filters: [] }),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve(mockTasks),
        });

      const result = await service.processMealPlan();

      // No vamos a asumir que encuentra la sección correcta, solo que funciona el flujo
      if (result.success) {
        expect(result.tasksCount).toBeGreaterThanOrEqual(0);
        expect(result.tasks).toBeDefined();
      } else {
        // Si no encuentra la sección, es válido también
        expect(result.error).toContain('No se encontró sección');
      }
    });
  });
});
</file>

<file path="__tests__/notion-todoist-service.test.ts">
/**
 * Tests para el servicio NotionTodoistService con la nueva funcionalidad de eliminación de menciones
 */

import { NotionTodoistService } from '@/services/webhooks/notion-todoist.service';
import * as todoistClient from '@/utils/todoist-client';

// Mocks
jest.mock('@/utils/todoist-client', () => ({
  findTaskByNotionUrl: jest.fn(),
  deleteTodoistTask: jest.fn(),
  createTodoistTask: jest.fn(),
  updateTodoistTask: jest.fn(),
  completeTodoistTask: jest.fn(),
  formatDateForTodoist: jest.fn(),
  findOrCreateProjectByWorkspace: jest.fn(),
}));

jest.mock('@/utils/notion-client', () => ({
  getNotionPageContent: jest.fn(),
  getNotionPageStatus: jest.fn(),
}));

jest.mock('@/lib/config', () => ({
  config: {
    todoist: {
      projectId: 'test-project-id'
    },
    openai: {
      enabled: false,
      apiKey: null
    }
  }
}));

describe('NotionTodoistService - handleMentionRemoval', () => {
  let service: NotionTodoistService;

  beforeEach(() => {
    service = new NotionTodoistService();
    jest.clearAllMocks();
  });

  describe('handleMentionRemoval', () => {
    it('debe eliminar una tarea existente cuando se quita la mención', async () => {
      const pageId = 'test-page-123';
      const mockTask = {
        id: 'task-456',
        content: 'Test Task',
        description: 'Test description with notion.so/test-page-123'
      };

      // Mock que encuentra una tarea existente
      (todoistClient.findTaskByNotionUrl as jest.Mock).mockResolvedValue(mockTask);
      (todoistClient.deleteTodoistTask as jest.Mock).mockResolvedValue(undefined);

      const result = await service.handleMentionRemoval(pageId);

      expect(todoistClient.findTaskByNotionUrl).toHaveBeenCalledWith(pageId);
      expect(todoistClient.deleteTodoistTask).toHaveBeenCalledWith('task-456');
      expect(result).toEqual({
        taskDeleted: true,
        taskId: 'task-456'
      });
    });

    it('debe retornar taskDeleted: false cuando no hay tarea existente', async () => {
      const pageId = 'test-page-456';

      // Mock que NO encuentra una tarea existente
      (todoistClient.findTaskByNotionUrl as jest.Mock).mockResolvedValue(null);

      const result = await service.handleMentionRemoval(pageId);

      expect(todoistClient.findTaskByNotionUrl).toHaveBeenCalledWith(pageId);
      expect(todoistClient.deleteTodoistTask).not.toHaveBeenCalled();
      expect(result).toEqual({
        taskDeleted: false
      });
    });

    it('debe manejar errores al buscar la tarea', async () => {
      const pageId = 'test-page-error';
      const error = new Error('Error buscando tarea');

      // Mock que falla al buscar
      (todoistClient.findTaskByNotionUrl as jest.Mock).mockRejectedValue(error);

      const result = await service.handleMentionRemoval(pageId);

      expect(result).toEqual({
        taskDeleted: false,
        error: 'Error buscando tarea'
      });
    });

    it('debe manejar errores al eliminar la tarea', async () => {
      const pageId = 'test-page-delete-error';
      const mockTask = {
        id: 'task-error',
        content: 'Test Task'
      };
      const deleteError = new Error('Error eliminando tarea');

      // Mock que encuentra la tarea pero falla al eliminar
      (todoistClient.findTaskByNotionUrl as jest.Mock).mockResolvedValue(mockTask);
      (todoistClient.deleteTodoistTask as jest.Mock).mockRejectedValue(deleteError);

      const result = await service.handleMentionRemoval(pageId);

      expect(todoistClient.findTaskByNotionUrl).toHaveBeenCalledWith(pageId);
      expect(todoistClient.deleteTodoistTask).toHaveBeenCalledWith('task-error');
      expect(result).toEqual({
        taskDeleted: false,
        error: 'Error eliminando tarea'
      });
    });
  });
});
</file>

<file path="src/app/page.tsx">
import Nav from '@/components/Nav'
import FloatSocial from '@/components/FloatSocial'
import FloatMail from '@/components/FloatMail'
import Hero from '@/components/Hero'
import AboutMe from '@/components/AboutMe'
import MyWork from '@/components/MyWork'
import FeaturedProjects from '@/components/FeaturedProjects'
import Footer from '@/components/Footer'
import Contact from '@/components/Contact'

export default function Home() {
  return (
    <>
      <Nav />
      <main>
        <FloatSocial />
        <FloatMail />
        <Hero />
        <AboutMe />
        <FeaturedProjects />
        <MyWork />
        <Contact />
      </main>
      <Footer />
    </>
  )
}
</file>

<file path="src/components/Contact.tsx">
'use client'

import { motion, useAnimation } from 'framer-motion'
import React, { useEffect } from 'react'
import { useInView } from 'react-intersection-observer'
import '@/styles/contact.scss'
import { ContainerVariants } from '@/lib/animation'
import strings from '@/data/contact.json'

const Contact: React.FC = () => {
  const [ref, inView] = useInView()
  const animation = useAnimation()

  useEffect(() => {
    if (inView) {
      animation.start('visible')
    } else {
      animation.start('hidden')
    }
  }, [inView, animation])

  return (
    <motion.section
      className="contact"
      ref={ref}
      variants={ContainerVariants}
      initial="hidden"
      animate={animation}
    >
      <h1 className="title" id="contact">
        {strings.contactTitle}
      </h1>
      <p>
        {strings.contactText}
      </p>
      <a href={`mailto:${strings.socials.mail}`}>
        <button>{strings.contactButton}</button>
      </a>
    </motion.section>
  )
}

export default Contact
</file>

<file path="src/components/Nav.tsx">
'use client'

import React, { useState } from 'react'
import '@/styles/nav.scss'
import navStrings from '@/data/nav.json'
import socialStrings from '@/data/contact.json'

const Nav: React.FC = () => {
  const [sideDisplay, setSideDisplay] = useState<string>('-100%')
  const [isOpen, setIsOpen] = useState<string>('closed')

  const toggleSidebar = (): void => {
    if (sideDisplay === '-100%') {
      setSideDisplay('0%')
      setIsOpen('open')
    } else {
      setSideDisplay('-100%')
      setIsOpen('closed')
    }
  }

  return (
    <nav className="nav">
      <a href="#">
        <h1>{navStrings.name}</h1>
      </a>
      <ul className="nav-links">
        <li>
          <a href="#aboutme">{navStrings.links.aboutMe}</a>
        </li>
        <li>
          <a href="#featuredProjects">{navStrings.links.featuredProjects}</a>
        </li>
        <li>
          <a href="#mywork">{navStrings.links.projects}</a>
        </li>
        <li>
          <a href="#contact">{navStrings.links.contact}</a>
        </li>
        <a
          href={navStrings.resumeLink}
          target="_blank"
          rel="noopener noreferrer"
        >
          <button>{navStrings.links.resume}</button>
        </a>
      </ul>
      <div className={`hamburger ${isOpen}`} onClick={toggleSidebar}>
        <svg
          width="105"
          height="90"
          viewBox="0 0 105 90"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <g id="hamburger">
            <path
              id="bottom"
              d="M10.5875 70.3995H94.5039C95.7861 70.3995 97.0558 70.6521 98.2405 71.1428C99.4251 71.6335 100.502 72.3527 101.408 73.2594C102.315 74.1661 103.034 75.2425 103.525 76.4271C104.016 77.6118 104.268 78.8815 104.268 80.1637C104.268 81.446 104.016 82.7157 103.525 83.9003C103.034 85.085 102.315 86.1614 101.408 87.0681C100.502 87.9748 99.4251 88.694 98.2405 89.1847C97.0558 89.6754 95.7861 89.928 94.5039 89.928H10.5875C9.30528 89.928 8.03558 89.6754 6.85093 89.1847C5.66628 88.694 4.58988 87.9748 3.68318 87.0681C2.77649 86.1614 2.05726 85.085 1.56656 83.9003C1.07586 82.7157 0.823303 81.446 0.823303 80.1637C0.823303 78.8815 1.07586 77.6118 1.56656 76.4271C2.05726 75.2425 2.77649 74.1661 3.68318 73.2594C4.58988 72.3527 5.66628 71.6335 6.85093 71.1428C8.03558 70.6521 9.30528 70.3995 10.5875 70.3995V70.3995Z"
              fill="#E9E9E9"
            />
            <path
              id="middle"
              d="M10.5875 35.267H94.5039C95.7861 35.267 97.0558 35.5195 98.2405 36.0102C99.4251 36.5009 100.502 37.2201 101.408 38.1268C102.315 39.0335 103.034 40.1099 103.525 41.2946C104.016 42.4792 104.268 43.7489 104.268 45.0312C104.268 46.3134 104.016 47.5832 103.525 48.7678C103.034 49.9525 102.315 51.0289 101.408 51.9355C100.502 52.8422 99.4251 53.5615 98.2405 54.0522C97.0558 54.5429 95.7861 54.7954 94.5039 54.7954H10.5875C9.30528 54.7954 8.03558 54.5429 6.85093 54.0522C5.66628 53.5615 4.58988 52.8422 3.68318 51.9355C2.77649 51.0289 2.05726 49.9525 1.56656 48.7678C1.07586 47.5832 0.823303 46.3134 0.823303 45.0312C0.823303 43.7489 1.07586 42.4792 1.56656 41.2946C2.05726 40.1099 2.77649 39.0335 3.68318 38.1268C4.58988 37.2201 5.66628 36.5009 6.85093 36.0102C8.03558 35.5195 9.30528 35.267 10.5875 35.267V35.267Z"
              fill="#E9E9E9"
            />
            <path
              id="top"
              d="M10.5875 0.138149H94.5039C97.0935 0.138149 99.5771 1.16688 101.408 2.99803C103.239 4.82918 104.268 7.31275 104.268 9.90238C104.268 12.492 103.239 14.9756 101.408 16.8067C99.5771 18.6379 97.0935 19.6666 94.5039 19.6666H10.5875C7.9979 19.6666 5.51433 18.6379 3.68318 16.8067C1.85203 14.9756 0.823303 12.492 0.823303 9.90238C0.823303 7.31275 1.85203 4.82918 3.68318 2.99803C5.51433 1.16688 7.9979 0.138149 10.5875 0.138149V0.138149Z"
              fill="#E9E9E9"
            />
          </g>
        </svg>
      </div>
      <aside className="sidebar" style={{ right: sideDisplay }}>
        <ul className="aside-links">
          <li>
            <a href="#aboutme">{navStrings.links.aboutMe}</a>
          </li>
          <li>
            <a href="#featuredProjects">{navStrings.links.featuredProjects}</a>
          </li>
          <li>
            <a href="#mywork">{navStrings.links.projects}</a>
          </li>
          <li>
            <a href="#contact">{navStrings.links.contact}</a>
          </li>
          <a
            href={navStrings.resumeLink}
            target="_blank"
            rel="noopener noreferrer"
          >
            <button>{navStrings.links.resume}</button>
          </a>
          <ul className="aside-social">
            <li>
              <a href={socialStrings.socials.github} target="_blank" rel="noopener noreferrer">
                <svg
                  width="21"
                  height="21"
                  viewBox="0 0 25 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <g id="Github">
                    <path
                      d="M12.5516 0.454773C5.92157 0.454773 0.551575 5.82477 0.551575 12.4548C0.551575 17.7648 3.98657 22.2498 8.75657 23.8398C9.35657 23.9448 9.58157 23.5848 9.58157 23.2698C9.58157 22.9848 9.56658 22.0398 9.56658 21.0348C6.55157 21.5898 5.77157 20.2998 5.53157 19.6248C5.39657 19.2798 4.81157 18.2148 4.30157 17.9298C3.88157 17.7048 3.28157 17.1498 4.28657 17.1348C5.23157 17.1198 5.90657 18.0048 6.13157 18.3648C7.21157 20.1798 8.93657 19.6698 9.62657 19.3548C9.73157 18.5748 10.0466 18.0498 10.3916 17.7498C7.72157 17.4498 4.93157 16.4148 4.93157 11.8248C4.93157 10.5198 5.39657 9.43977 6.16157 8.59977C6.04157 8.29977 5.62157 7.06977 6.28157 5.41977C6.28157 5.41977 7.28657 5.10477 9.58157 6.64977C10.5416 6.37977 11.5616 6.24477 12.5816 6.24477C13.6016 6.24477 14.6216 6.37977 15.5816 6.64977C17.8766 5.08977 18.8816 5.41977 18.8816 5.41977C19.5416 7.06977 19.1216 8.29977 19.0016 8.59977C19.7666 9.43977 20.2316 10.5048 20.2316 11.8248C20.2316 16.4298 17.4266 17.4498 14.7566 17.7498C15.1916 18.1248 15.5666 18.8448 15.5666 19.9698C15.5666 21.5748 15.5516 22.8648 15.5516 23.2698C15.5516 23.5848 15.7766 23.9598 16.3766 23.8398C18.7588 23.0355 20.8288 21.5045 22.2952 19.4621C23.7617 17.4198 24.5509 14.9691 24.5516 12.4548C24.5516 5.82477 19.1816 0.454773 12.5516 0.454773Z"
                      fill="currentColor"
                    />
                  </g>
                </svg>
              </a>
            </li>
            <li>
              <a href={socialStrings.socials.twitter} target="_blank" rel="noopener noreferrer">
                <svg
                  width="21"
                  height="21"
                  viewBox="0 0 23 19"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <g id="Twitter">
                    <path
                      id="Vector"
                      d="M22.869 2.41503C22.034 2.78503 21.137 3.03503 20.194 3.14803C21.167 2.56582 21.8949 1.64949 22.242 0.570028C21.3278 1.11302 20.3273 1.49522 19.284 1.70003C18.5824 0.950893 17.653 0.454354 16.6403 0.287502C15.6276 0.12065 14.5881 0.29282 13.6832 0.777281C12.7784 1.26174 12.0588 2.03139 11.6361 2.96673C11.2135 3.90207 11.1115 4.95078 11.346 5.95003C9.49367 5.85702 7.68161 5.37558 6.02741 4.53693C4.37321 3.69829 2.91383 2.52119 1.74399 1.08203C1.34399 1.77203 1.11399 2.57203 1.11399 3.42403C1.11354 4.19102 1.30242 4.94627 1.66387 5.62276C2.02531 6.29925 2.54815 6.87607 3.18599 7.30203C2.44626 7.27849 1.72286 7.07861 1.07599 6.71903V6.77903C1.07591 7.85477 1.44802 8.89741 2.12917 9.73002C2.81032 10.5626 3.75856 11.134 4.81299 11.347C4.12677 11.5327 3.40732 11.5601 2.70899 11.427C3.00648 12.3526 3.58598 13.1621 4.36635 13.742C5.14673 14.3219 6.0889 14.6432 7.06099 14.661C5.41082 15.9564 3.37287 16.6591 1.27499 16.656C0.903368 16.6561 0.532063 16.6344 0.162987 16.591C2.29246 17.9602 4.77133 18.6868 7.30299 18.684C15.873 18.684 20.558 11.586 20.558 5.43003C20.558 5.23003 20.553 5.02803 20.544 4.82803C21.4553 4.169 22.2419 3.35292 22.867 2.41803L22.869 2.41503V2.41503Z"
                      fill="currentColor"
                    />
                  </g>
                </svg>
              </a>
            </li>
            <li>
              <a href={socialStrings.socials.linkedin} target="_blank" rel="noopener noreferrer">
                <svg
                  width="22"
                  height="22"
                  viewBox="0 0 22 22"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <g id="LinkedIn">
                    <path
                      id="Vector"
                      fillRule="evenodd"
                      clipRule="evenodd"
                      d="M2.7206e-07 1.838C2.7206e-07 1.35053 0.193646 0.883032 0.538338 0.53834C0.88303 0.193648 1.35053 2.45031e-06 1.838 2.45031e-06H20.16C20.4016 -0.000392101 20.6409 0.0468654 20.8641 0.139069C21.0874 0.231273 21.2903 0.366612 21.4612 0.537339C21.6322 0.708065 21.7677 0.910826 21.8602 1.13401C21.9526 1.3572 22.0001 1.59643 22 1.838V20.16C22.0003 20.4016 21.9529 20.6409 21.8606 20.8642C21.7683 21.0875 21.6328 21.2904 21.462 21.4613C21.2912 21.6322 21.0884 21.7678 20.8651 21.8602C20.6419 21.9526 20.4026 22.0001 20.161 22H1.838C1.59655 22 1.35746 21.9524 1.1344 21.86C0.911335 21.7676 0.708671 21.6321 0.537984 21.4613C0.367297 21.2905 0.231932 21.0878 0.139623 20.8647C0.0473133 20.6416 -0.000131096 20.4025 2.7206e-07 20.161V1.838ZM8.708 8.388H11.687V9.884C12.117 9.024 13.217 8.25 14.87 8.25C18.039 8.25 18.79 9.963 18.79 13.106V18.928H15.583V13.822C15.583 12.032 15.153 11.022 14.061 11.022C12.546 11.022 11.916 12.111 11.916 13.822V18.928H8.708V8.388ZM3.208 18.791H6.416V8.25H3.208V18.79V18.791ZM6.875 4.812C6.88105 5.08667 6.83217 5.35979 6.73124 5.61532C6.63031 5.87084 6.47935 6.10364 6.28723 6.30003C6.09511 6.49643 5.8657 6.65248 5.61246 6.75901C5.35921 6.86554 5.08724 6.92042 4.8125 6.92042C4.53776 6.92042 4.26579 6.86554 4.01255 6.75901C3.7593 6.65248 3.52989 6.49643 3.33777 6.30003C3.14565 6.10364 2.99469 5.87084 2.89376 5.61532C2.79283 5.35979 2.74395 5.08667 2.75 4.812C2.76187 4.27286 2.98439 3.75979 3.36989 3.38269C3.75539 3.00558 4.27322 2.79442 4.8125 2.79442C5.35178 2.79442 5.86961 3.00558 6.25512 3.38269C6.64062 3.75979 6.86313 4.27286 6.875 4.812V4.812Z"
                      fill="currentColor"
                    />
                  </g>
                </svg>
              </a>
            </li>
            <li>
              <a href={socialStrings.socials.instagram} target="_blank" rel="noopener noreferrer">
                <svg
                  width="21"
                  height="21"
                  viewBox="0 0 22 22"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <g id="Instagram">
                    <path
                      id="Vector"
                      d="M6.465 0.066C7.638 0.012 8.012 0 11 0C13.988 0 14.362 0.013 15.534 0.066C16.706 0.119 17.506 0.306 18.206 0.577C18.939 0.854 19.604 1.287 20.154 1.847C20.714 2.396 21.146 3.06 21.422 3.794C21.694 4.494 21.88 5.294 21.934 6.464C21.988 7.639 22 8.013 22 11C22 13.988 21.987 14.362 21.934 15.535C21.881 16.705 21.694 17.505 21.422 18.205C21.146 18.9391 20.7133 19.6042 20.154 20.154C19.604 20.714 18.939 21.146 18.206 21.422C17.506 21.694 16.706 21.88 15.536 21.934C14.362 21.988 13.988 22 11 22C8.012 22 7.638 21.987 6.465 21.934C5.295 21.881 4.495 21.694 3.795 21.422C3.06092 21.146 2.39582 20.7133 1.846 20.154C1.28638 19.6047 0.853315 18.9399 0.577 18.206C0.306 17.506 0.12 16.706 0.066 15.536C0.012 14.361 0 13.987 0 11C0 8.012 0.013 7.638 0.066 6.466C0.119 5.294 0.306 4.494 0.577 3.794C0.853723 3.06008 1.28712 2.39531 1.847 1.846C2.39604 1.2865 3.06047 0.853443 3.794 0.577C4.494 0.306 5.294 0.12 6.464 0.066H6.465ZM15.445 2.046C14.285 1.993 13.937 1.982 11 1.982C8.063 1.982 7.715 1.993 6.555 2.046C5.482 2.095 4.9 2.274 4.512 2.425C3.999 2.625 3.632 2.862 3.247 3.247C2.88205 3.60205 2.60118 4.03428 2.425 4.512C2.274 4.9 2.095 5.482 2.046 6.555C1.993 7.715 1.982 8.063 1.982 11C1.982 13.937 1.993 14.285 2.046 15.445C2.095 16.518 2.274 17.1 2.425 17.488C2.601 17.965 2.882 18.398 3.247 18.753C3.602 19.118 4.035 19.399 4.512 19.575C4.9 19.726 5.482 19.905 6.555 19.954C7.715 20.007 8.062 20.018 11 20.018C13.938 20.018 14.285 20.007 15.445 19.954C16.518 19.905 17.1 19.726 17.488 19.575C18.001 19.375 18.368 19.138 18.753 18.753C19.118 18.398 19.399 17.965 19.575 17.488C19.726 17.1 19.905 16.518 19.954 15.445C20.007 14.285 20.018 13.937 20.018 11C20.018 8.063 20.007 7.715 19.954 6.555C19.905 5.482 19.726 4.9 19.575 4.512C19.375 3.999 19.138 3.632 18.753 3.247C18.3979 2.88207 17.9657 2.60121 17.488 2.425C17.1 2.274 16.518 2.095 15.445 2.046V2.046ZM9.595 14.391C10.3797 14.7176 11.2534 14.7617 12.0669 14.5157C12.8805 14.2697 13.5834 13.7489 14.0556 13.0422C14.5278 12.3356 14.7401 11.4869 14.656 10.6411C14.572 9.79534 14.197 9.00497 13.595 8.405C13.2112 8.02148 12.7472 7.72781 12.2363 7.54515C11.7255 7.36248 11.1804 7.29536 10.6405 7.34862C10.1006 7.40187 9.57915 7.57418 9.1138 7.85313C8.64846 8.13208 8.25074 8.51074 7.9493 8.96185C7.64786 9.41296 7.45019 9.92529 7.37052 10.462C7.29084 10.9986 7.33115 11.5463 7.48854 12.0655C7.64593 12.5847 7.91648 13.0626 8.28072 13.4647C8.64496 13.8668 9.09382 14.1832 9.595 14.391ZM7.002 7.002C7.52702 6.47698 8.15032 6.0605 8.8363 5.77636C9.52228 5.49222 10.2575 5.34597 11 5.34597C11.7425 5.34597 12.4777 5.49222 13.1637 5.77636C13.8497 6.0605 14.473 6.47698 14.998 7.002C15.523 7.52702 15.9395 8.15032 16.2236 8.8363C16.5078 9.52228 16.654 10.2575 16.654 11C16.654 11.7425 16.5078 12.4777 16.2236 13.1637C15.9395 13.8497 15.523 14.473 14.998 14.998C13.9377 16.0583 12.4995 16.654 11 16.654C9.50046 16.654 8.06234 16.0583 7.002 14.998C5.94166 13.9377 5.34597 12.4995 5.34597 11C5.34597 9.50046 5.94166 8.06234 7.002 7.002V7.002ZM17.908 6.188C18.0381 6.06527 18.1423 5.91768 18.2143 5.75397C18.2863 5.59027 18.3248 5.41377 18.3274 5.23493C18.33 5.05609 18.2967 4.87855 18.2295 4.71281C18.1622 4.54707 18.0624 4.39651 17.936 4.27004C17.8095 4.14357 17.6589 4.04376 17.4932 3.97652C17.3275 3.90928 17.1499 3.87598 16.9711 3.87858C16.7922 3.88119 16.6157 3.91965 16.452 3.9917C16.2883 4.06374 16.1407 4.1679 16.018 4.298C15.7793 4.55103 15.6486 4.88712 15.6537 5.23493C15.6588 5.58274 15.7992 5.91488 16.0452 6.16084C16.2911 6.40681 16.6233 6.54723 16.9711 6.5523C17.3189 6.55737 17.655 6.42669 17.908 6.188V6.188Z"
                      fill="currentColor"
                    />
                  </g>
                </svg>
              </a>
            </li>
          </ul>
        </ul>
      </aside>
    </nav>
  )
}

export default Nav
</file>

<file path="src/config/constants.ts">
export const APP_CONFIG = {
  PATHS: {
    FONTS: '/fonts/Recoleta.otf',
    IMAGES: '/images/',
  },
  
  NAVIGATION: {
    SCROLL_OFFSET: 100,
    MOBILE_BREAKPOINT: 900,
  },
  
  ANIMATION: {
    DURATION: {
      FAST: 0.2,
      NORMAL: 0.3,
      SLOW: 0.5,
    },
    EASING: 'ease',
  },
  
  SOCIAL_LINKS: {
    GITHUB: 'https://github.com/imsebarz',
    LINKEDIN: 'https://linkedin.com/in/imsebarz',
    TWITTER: 'https://twitter.com/imsebarz',
    INSTAGRAM: 'https://instagram.com/imsebarz',
  },
  
  CONTACT: {
    EMAIL: 'sebastian@example.com',
    RESUME_LINK: '#',
  },
} as const
export type SocialPlatform = keyof typeof APP_CONFIG.SOCIAL_LINKS
export type AnimationDuration = keyof typeof APP_CONFIG.ANIMATION.DURATION
</file>

<file path="src/services/health-check.service.ts">
/**
 * Servicio para health checks de la aplicación
 */

import { config } from '@/lib/config';
import { HealthCheckResponse } from '@/lib/api-response';

export class HealthCheckService {
  private startTime: number;

  constructor() {
    this.startTime = Date.now();
  }

  /**
   * Obtiene el estado de salud de la aplicación
   */
  getHealthStatus(): HealthCheckResponse {
    const uptime = Date.now() - this.startTime;
    
    return {
      status: 'healthy',
      message: 'Notion-Todoist Webhook API is running',
      timestamp: new Date().toISOString(),
      uptime,
      endpoints: {
        webhook: 'POST /api/notion-webhook',
        health: 'GET /api/notion-webhook',
      },
      configuration: {
        notionUserIdConfigured: !!config.notion.userId,
        todoistProjectIdConfigured: !!config.todoist.projectId, // Optional: used as fallback when dynamic project creation fails
        aiEnhancementEnabled: config.openai.enabled,
        openaiConfigured: !!config.openai.apiKey,
      },
      features: {
        duplicatePrevention: 'Latest-event debounce system (60s window)',
        taskUpdates: 'Updates existing Todoist tasks for page property changes',
        aiEnhancement: config.openai.enabled ? 'Enabled' : 'Disabled',
        workspaceTags: 'Automatic workspace labeling',
        mentionDetection: 'User-specific filtering',
        dynamicProjectCreation: 'Creates projects per workspace automatically',
      },
    };
  }

  /**
   * Verifica que la configuración mínima esté presente
   */
  checkMinimalConfiguration(): { isValid: boolean; missingConfig: string[] } {
    const missingConfig: string[] = [];

    if (!config.todoist.apiToken) {
      missingConfig.push('TODOIST_API_TOKEN');
    }

    return {
      isValid: missingConfig.length === 0,
      missingConfig,
    };
  }
}
</file>

<file path="src/services/meal-plan.service.ts">
import { logger } from '@/lib/logger';

interface TodoistSection {
  id: string;
  name: string;
  project_id: string;
}

interface TodoistTask {
  id: string;
  content: string;
  description: string;
  section_id: string;
  project_id: string;
  is_completed: boolean;
  labels: string[];
  due?: {
    date: string;
    string: string;
  };
}

interface MealPlanResult {
  success: boolean;
  currentDay: string;
  nextDay: string;
  sectionId: string | null;
  sectionName: string | null;
  tasksCount: number;
  tasks: TodoistTask[];
  projectId: string;
  filterId?: string;
  filterQuery?: string;
  filterUpdated?: boolean;
  error?: string;
}

export class MealPlanService {
  private readonly apiUrl = 'https://api.todoist.com/rest/v2';
  private readonly token: string;
  private readonly projectId: string;
  private readonly filterName: string;

  constructor() {
    this.token = process.env.TODOIST_API_TOKEN_MEAL_PLAN || process.env.TODOIST_API_TOKEN || '';
    this.projectId = process.env.TODOIST_MEAL_PLAN_PROJECT_ID || process.env.TODOIST_DAILY_PROJECT_ID || '';
    this.filterName = process.env.TODOIST_MEAL_PLAN_FILTER_NAME || 'Meal Plan del día siguiente';
    
    if (!this.token) throw new Error('TODOIST_API_TOKEN_MEAL_PLAN or TODOIST_API_TOKEN is required');
    if (!this.projectId) throw new Error('TODOIST_MEAL_PLAN_PROJECT_ID or TODOIST_DAILY_PROJECT_ID is required');
  }

  private getCurrentDayName(): string {
    const days = ['domingo', 'lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado'];
    return days[new Date().getDay()];
  }

  private getNextDayName(): string {
    const days = ['domingo', 'lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado'];
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    return days[tomorrow.getDay()];
  }

  private async getSections(): Promise<TodoistSection[]> {
    const response = await fetch(`${this.apiUrl}/sections?project_id=${this.projectId}`, {
      headers: { 'Authorization': `Bearer ${this.token}` },
    });
    if (!response.ok) throw new Error(`Failed to fetch sections: ${response.status} - ${response.statusText}`);
    return await response.json();
  }

  private findSectionByDay(sections: TodoistSection[], dayName: string): TodoistSection | null {
    return sections.find(section => section.name.toLowerCase().includes(dayName.toLowerCase())) || null;
  }

  private async getTasksFromSection(sectionId: string): Promise<TodoistTask[]> {
    const response = await fetch(`${this.apiUrl}/tasks?project_id=${this.projectId}&section_id=${sectionId}`, {
      headers: { 'Authorization': `Bearer ${this.token}` },
    });
    if (!response.ok) throw new Error(`Failed to fetch tasks: ${response.status} - ${response.statusText}`);
    return await response.json();
  }

  private filterMealPlanTasks(tasks: TodoistTask[]): TodoistTask[] {
    return tasks.filter(task => 
      !task.is_completed && 
      task.labels.some(label => label.toLowerCase().includes('mealprep'))
    );
  }

  /**
   * Crea o actualiza el filtro nativo para meal plan del día siguiente usando la API Sync v9
   */
  private async syncV9CreateOrUpdateFilter(sectionName: string): Promise<{ filterId: string; filterQuery: string; updated: boolean }> {
    const filterName = this.filterName;
    
    // Obtener el nombre del proyecto
    const projectInfo = await this.getProjectInfo();
    const projectName = projectInfo?.name || '';
    
    // El filtro debe ser #proyecto & /Seccion & @mealprep
    const filterQuery = `#${projectName} & /${sectionName} & @mealprep`;
    const syncUrl = 'https://api.todoist.com/sync/v9/sync';

    // 1. Obtener todos los filtros
    const getRes = await fetch(syncUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        sync_token: '*',
        resource_types: '["filters"]'
      })
    });

    if (!getRes.ok) throw new Error('No se pudo obtener filtros (Sync v9)');
    const getData = await getRes.json();
    const filters = getData.filters || [];

    interface TodoistFilter {
      id: string;
      name: string;
      query: string;
      color?: string;
      favorite?: boolean;
    }

    const existing = filters.find((f: TodoistFilter) => f.name === filterName);

    if (existing) {
      if (existing.query === filterQuery) {
        return { filterId: existing.id, filterQuery, updated: false };
      }

      // Actualizar filtro
      const updateRes = await fetch(syncUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sync_token: '*',
          commands: [
            {
              type: 'filter_update',
              uuid: (globalThis.crypto?.randomUUID?.() || Math.random().toString(36).slice(2)),
              args: {
                id: existing.id,
                name: filterName,
                query: filterQuery,
                color: existing.color || 'green',
                favorite: true
              }
            }
          ]
        })
      });

      if (!updateRes.ok) throw new Error('No se pudo actualizar el filtro (Sync v9)');
      return { filterId: existing.id, filterQuery, updated: true };
    } else {
      // Crear filtro
      const addRes = await fetch(syncUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sync_token: '*',
          commands: [
            {
              type: 'filter_add',
              uuid: (globalThis.crypto?.randomUUID?.() || Math.random().toString(36).slice(2)),
              temp_id: (globalThis.crypto?.randomUUID?.() || Math.random().toString(36).slice(2)),
              args: {
                name: filterName,
                query: filterQuery,
                color: 'green',
                favorite: true
              }
            }
          ]
        })
      });

      if (!addRes.ok) throw new Error('No se pudo crear el filtro (Sync v9)');

      // Volver a consultar para obtener el filtro creado
      const getRes2 = await fetch(syncUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sync_token: '*',
          resource_types: '["filters"]'
        })
      });

      const getData2 = await getRes2.json();
      const created = (getData2.filters || []).find((f: TodoistFilter) => f.name === filterName && f.query === filterQuery);
      return { filterId: created?.id || '', filterQuery, updated: true };
    }
  }

  async processMealPlan(): Promise<MealPlanResult> {
    try {
      const currentDay = this.getCurrentDayName();
      const nextDay = this.getNextDayName();
      
      logger.info('Processing meal plan for next day', { 
        currentDay, 
        nextDay, 
        projectId: this.projectId 
      });

      const sections = await this.getSections();
      logger.info('Sections found', { 
        sectionsCount: sections.length, 
        sections: sections.map(s => s.name) 
      });

      const nextDaySection = this.findSectionByDay(sections, nextDay);
      if (!nextDaySection) {
        logger.warn('No section found for next day', { 
          nextDay, 
          availableSections: sections.map(s => s.name) 
        });
        return {
          success: false,
          currentDay,
          nextDay,
          sectionId: null,
          sectionName: null,
          tasksCount: 0,
          tasks: [],
          projectId: this.projectId,
          error: `No se encontró sección para el día siguiente: ${nextDay}`
        };
      }

      // Crear o actualizar el filtro nativo usando Sync v9
      const filterResult = await this.syncV9CreateOrUpdateFilter(nextDaySection.name);

      const allTasks = await this.getTasksFromSection(nextDaySection.id);
      const mealPlanTasks = this.filterMealPlanTasks(allTasks);

      logger.info('Meal plan processed successfully', {
        currentDay,
        nextDay,
        sectionName: nextDaySection.name,
        totalTasks: allTasks.length,
        mealPlanTasks: mealPlanTasks.length,
        filterId: filterResult.filterId,
        filterUpdated: filterResult.updated
      });

      return {
        success: true,
        currentDay,
        nextDay,
        sectionId: nextDaySection.id,
        sectionName: nextDaySection.name,
        tasksCount: mealPlanTasks.length,
        tasks: mealPlanTasks,
        projectId: this.projectId,
        filterId: filterResult.filterId,
        filterQuery: filterResult.filterQuery,
        filterUpdated: filterResult.updated
      };
    } catch (error) {
      logger.error('Error processing meal plan', { error });
      return {
        success: false,
        currentDay: this.getCurrentDayName(),
        nextDay: this.getNextDayName(),
        sectionId: null,
        sectionName: null,
        tasksCount: 0,
        tasks: [],
        projectId: this.projectId,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  async getProjectInfo(): Promise<{ id: string; name: string } | null> {
    try {
      const response = await fetch(`${this.apiUrl}/projects/${this.projectId}`, {
        headers: { 'Authorization': `Bearer ${this.token}` },
      });
      if (!response.ok) throw new Error(`Failed to fetch project: ${response.status} - ${response.statusText}`);
      return await response.json();
    } catch (error) {
      logger.error('Error fetching project info', { error, projectId: this.projectId });
      return null;
    }
  }
}
</file>

<file path="src/styles/contact.scss">
@use './colors.scss';

.contact {
  display: flex;
  flex-direction: column;
  min-height: 40vh;
  width: 100%;
  max-width: 800px;
  margin: 4em auto;
  padding: 3em 2em;
  place-items: center;
  justify-content: center;
  gap: 2em;
  background-color: colors.$mint;
  text-align: center;
  border-radius: 15px;
  
  .title {
    margin-bottom: 0;
    font-family: var(--font-recoleta);
  }
  
  p {
    font-size: 1.1rem;
    line-height: 1.6;
    max-width: 600px;
    margin: 0;
  }
  
  button {
    color: colors.$mint;
    background: colors.$green;
    height: 4em;
    width: 12em;
    padding: 1em;
    font-weight: 700;
    border-radius: 10px;
    border: none;
    font-size: 1rem;
    transition: all 0.3s ease;
  }
  
  button:hover {
    border: solid 2px colors.$green;
    color: colors.$green;
    background: colors.$mint;
    transform: translateY(-2px);
  }
}

@media screen and (max-width: 900px) {
  .contact {
    width: 95%;
    margin: 2em auto;
    padding: 2em 1em;
    
    .title {
      font-size: 2.5rem;
    }
    
    p {
      font-size: 1rem;
    }
    
    button {
      width: 10em;
      height: 3.5em;
    }
  }
}
</file>

<file path="src/styles/featuredproject.scss">
@use './colors.scss';

.ftProject {
  display: grid;
  height: max-content;
  gap: 5px;
  grid-template-columns: repeat(12, 1fr);
}

.ftProject-image {
  grid-column: 1 / 8;
  grid-row: 1 / 2;
  height: 100%;
  overflow: hidden;

  a {
    overflow: hidden;
    display: block;
    height: 100%;
  }
  img {
    height: 100%;
    width: 100%;
    filter: brightness(0.8) saturate(0.8);
    object-fit: cover;
    transition: all 0.3s ease;
  }
}
.ftProject-image:hover img {
  transform: scale(1.05);
  filter: brightness(0.9);
}

.ftProject-content {
  grid-column: 7 / -1;
  grid-row: 1 / 2;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  text-align: right;
  justify-content: space-evenly;
  .desc {
    background-color: colors.$green;
    padding: 2em;
    border-radius: 5px;
    margin-right: 1em;
    opacity: 0.8;
    p {
      color: colors.$mint;
      opacity: 1;
    }
  }
  .ftProject-links {
    display: flex;
    width: 70px;
    justify-content: space-evenly;
    
    a {
      color: colors.$pepper;
      transition: all 0.3s ease;
      
      &:hover {
        color: colors.$green;
        transform: translateY(-2px);
      }
      
      svg {
        width: 20px;
        height: 20px;
        transition: inherit;
      }
    }
  }
  ul {
    display: flex;
    width: 80%;
    flex-wrap: wrap;
    gap: 1vw;
    li {
      color: colors.$pepper;
      width: max-content;
    }
  }
}

.left {
  .ftProject-image {
    grid-column: 6 / -1;
    grid-row: 1 / 2;
  }

  .ftProject-content {
    grid-column: 1 / 7;
    grid-row: 1 / 2;
    align-items: flex-start;
    text-align: left;
    .desc {
      margin-left: 1em;
    }
  }
}

@media screen and (max-width: 900px) {
  .ftProject {
    border-radius: 5px;
    .ftProject-image {
      grid-column: 1 / -1;
      position: relative;
      img {
        filter: brightness(0.5) saturate(0.5) contrast(1.2);
      }
    }
    .ftProject-image::after {
      height: 100%;
      content: "";
      top: 0;
      width: 100%;
      background: #027555bb;
      position: absolute;
    }
    .ftProject-content {
      align-items: flex-start;
      text-align: left;
      padding: 3em;
      color: white;
      grid-column: 1 / -1;
      z-index: 5;
      h1 {
        color: colors.$mint;
      }
      .desc {
        background: transparent;
        margin: 0;
        padding: 0;
      }
      li {
        color: colors.$mint;
      }
      .ftProject-links {
        justify-content: space-between;
        svg {
          path {
            fill: colors.$mint !important;
          }
        }
      }
    }
  }
}

@media screen and (max-width: 600px) {
  .ftProject {
    .ftProject-content {
      gap: 35px;
    }
  }
}
</file>

<file path="src/styles/floatmail.scss">
@use './colors.scss';

.floating-mail {
  position: fixed;
  display: flex;
  align-items: center;
  bottom: -10px;
  left: 4em;
  transform-origin: 0%;
  transform: rotate(270deg);
  .floating-line {
    margin: 0 2em 0 0;
    width: 6em;
    height: 3px;
    background-color: colors.$green;
  }
  .mail {
    color: colors.$green;
    font-weight: 300;
    font-size: 18px;
    text-decoration: none;
  }
}
</file>

<file path="src/styles/footer.scss">
@use './colors.scss';

.footer {
  height: 5em;
  background-color: colors.$green;
  margin-bottom: 0;
  display: flex;
  place-content: center;
  place-items: center;
  
  p {
    color: colors.$mint;
    font-size: 1rem;
    text-align: center;
  }
  
  a {
    color: colors.$mint;
    text-decoration: none;
    font-weight: 600;
    transition: all 0.3s ease;
    
    &:hover {
      color: colors.$black;
      text-decoration: underline;
    }
  }
}
</file>

<file path="src/styles/mixins.scss">
@mixin no-scroll {
  overflow: visible;
}

@mixin hide-overflow {
  overflow: hidden;
}

@mixin scroll-y {
  overflow-x: hidden;
  overflow-y: auto;
}

@mixin flex-container($direction: row, $wrap: wrap, $gap: 1em) {
  display: flex;
  flex-direction: $direction;
  flex-wrap: $wrap;
  gap: $gap;
  overflow: visible;
}

@mixin grid-container($min-width: 250px, $gap: 1em) {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax($min-width, 1fr));
  gap: $gap;
  overflow: visible;
}

@mixin smooth-transition($property: all, $duration: 0.3s, $easing: ease) {
  transition: #{$property} #{$duration} #{$easing};
}

@mixin center-content {
  display: flex;
  align-items: center;
  justify-content: center;
}

@mixin responsive-font($mobile: 1rem, $tablet: 1.2rem, $desktop: 1.5rem) {
  font-size: $mobile;
  
  @media screen and (min-width: 768px) {
    font-size: $tablet;
  }
  
  @media screen and (min-width: 1024px) {
    font-size: $desktop;
  }
}
</file>

<file path="src/styles/mywork.scss">
@use './colors.scss';
@use './mixins.scss';

.mywork {
  min-height: auto;
  height: auto;
  @include mixins.flex-container(column, nowrap, 3em);
  align-items: center;
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 2em;
  
  .title {
    text-align: center;
    margin-bottom: 2em;
  }
  
  .mywork-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 2em;
    width: 100%;
    max-width: 1000px;
    justify-items: center;
    align-items: start;
    @include mixins.no-scroll;
  }
}

@media screen and (max-width: 905px) {
  .mywork {
    padding: 1.5em;
    
    .mywork-container {
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5em;
    }
  }
}

@media screen and (max-width: 600px) {
  .mywork {
    padding: 1em;
    
    .mywork-container {
      grid-template-columns: 1fr;
      gap: 1em;
    }
  }
}
</file>

<file path="src/types/index.ts">
export interface Project {
  id: number
  name: string
  description: string
  tags: string[]
  img: string
  githubRepo?: string
  demo?: string
  featured?: boolean
}

export interface PersonalInfo {
  hero: {
    greeting: string
    name: string
    description: string
    buttonText: string
  }
  aboutMeText1: string
  aboutMeText2: string
  aboutMeText3: string
  aboutMeText4: string
  aboutMeText5: string
  someTechnologiesTitle: string
  technologies: string[]
}

export interface NavigationLinks {
  name: string
  links: {
    aboutMe: string
    featuredProjects: string
    projects: string
    contact: string
    resume: string
  }
  resumeLink: string
}

export interface ContactInfo {
  contactTitle: string
  contactText: string
  contactButton: string
  socials: {
    behance: string
    github: string
    linkedin: string
    twitter: string
    instagram: string
    mail: string
    username: string
  }
}

export interface AnimationVariants {
  hidden: {
    opacity: number
    y?: number
    x?: number
    scale?: number
  }
  visible: {
    opacity: number
    y?: number
    x?: number
    scale?: number
    transition?: {
      duration?: number
      delay?: number
      ease?: string
      staggerChildren?: number
    }
  }
}

export interface BaseComponentProps {
  className?: string
  children?: React.ReactNode
}

export interface ProjectComponentProps extends BaseComponentProps {
  project: Project
  isReversed?: boolean
}
</file>

<file path="src/utils/webhook-logger.ts">
import { NextRequest } from 'next/server';
import { NotionWebhookPayload } from '@/types/notion-todoist';

export interface WebhookLogEntry {
  timestamp: string;
  requestId: string;
  method: string;
  url: string;
  headers: Record<string, string>;
  payload: NotionWebhookPayload | Record<string, unknown>;
  userAgent: string | null;
  contentType: string | null;
  notionSignature: string | null;
  notionVersion: string | null;
  ipAddress?: string;
  processing: {
    success: boolean;
    duration: number;
    error?: string;
    pageId?: string;
    eventType?: string;
    wasProcessed?: boolean;
    skipReason?: string;
  };
}

class WebhookLogger {
  private logs: WebhookLogEntry[] = [];
  private maxLogs = 1000; // Mantener solo los últimos 1000 logs

  async logRequest(
    request: NextRequest, 
    payload: NotionWebhookPayload | Record<string, unknown>, 
    processing?: Partial<WebhookLogEntry['processing']>
  ): Promise<string> {
    const requestId = this.generateRequestId();
    const timestamp = new Date().toISOString();

    // Extraer headers importantes
    const headers: Record<string, string> = {};
    request.headers.forEach((value, key) => {
      headers[key] = value;
    });

    const logEntry: WebhookLogEntry = {
      timestamp,
      requestId,
      method: request.method,
      url: request.url,
      headers,
      payload,
      userAgent: request.headers.get('user-agent'),
      contentType: request.headers.get('content-type'),
      notionSignature: request.headers.get('x-notion-signature'),
      notionVersion: request.headers.get('notion-version'),
      ipAddress: this.getClientIp(request),
      processing: {
        success: false,
        duration: 0,
        ...processing
      }
    };

    this.addLog(logEntry);

    return requestId;
  }

  updateProcessingResult(requestId: string, processing: Partial<WebhookLogEntry['processing']>) {
    const logIndex = this.logs.findIndex(log => log.requestId === requestId);
    if (logIndex !== -1) {
      this.logs[logIndex].processing = {
        ...this.logs[logIndex].processing,
        ...processing
      };
    }
  }

  private addLog(entry: WebhookLogEntry) {
    this.logs.push(entry);
    
    // Mantener solo los últimos maxLogs
    if (this.logs.length > this.maxLogs) {
      this.logs = this.logs.slice(-this.maxLogs);
    }
  }

  private generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private getClientIp(request: NextRequest): string | undefined {
    // Intentar obtener la IP real del cliente
    const forwardedFor = request.headers.get('x-forwarded-for');
    const realIp = request.headers.get('x-real-ip');
    
    if (forwardedFor) {
      return forwardedFor.split(',')[0].trim();
    }
    
    if (realIp) {
      return realIp;
    }

    return undefined;
  }

  // Métodos para consultar logs
  getAllLogs(): WebhookLogEntry[] {
    return [...this.logs].reverse(); // Más recientes primero
  }

  getLogsByTimeRange(startTime: Date, endTime: Date): WebhookLogEntry[] {
    return this.logs.filter(log => {
      const logTime = new Date(log.timestamp);
      return logTime >= startTime && logTime <= endTime;
    });
  }

  getLogsByEventType(eventType: string): WebhookLogEntry[] {
    return this.logs.filter(log => 
      log.payload?.type === eventType
    );
  }

  getFailedLogs(): WebhookLogEntry[] {
    return this.logs.filter(log => !log.processing.success);
  }

  getSuccessfulLogs(): WebhookLogEntry[] {
    return this.logs.filter(log => log.processing.success);
  }

  getLogById(requestId: string): WebhookLogEntry | undefined {
    return this.logs.find(log => log.requestId === requestId);
  }

  // Estadísticas
  getStats() {
    const total = this.logs.length;
    const successful = this.getSuccessfulLogs().length;
    const failed = this.getFailedLogs().length;
    
    const eventTypes = new Map<string, number>();
    const userAgents = new Map<string, number>();
    
    this.logs.forEach(log => {
      const eventType = (log.payload as NotionWebhookPayload)?.type || 'unknown';
      eventTypes.set(eventType, (eventTypes.get(eventType) || 0) + 1);
      
      const userAgent = log.userAgent || 'unknown';
      userAgents.set(userAgent, (userAgents.get(userAgent) || 0) + 1);
    });

    return {
      total,
      successful,
      failed,
      successRate: total > 0 ? (successful / total * 100).toFixed(2) + '%' : '0%',
      eventTypes: Object.fromEntries(eventTypes),
      userAgents: Object.fromEntries(userAgents),
      averageProcessingTime: this.calculateAverageProcessingTime()
    };
  }

  private calculateAverageProcessingTime(): number {
    const processedLogs = this.logs.filter(log => log.processing.duration > 0);
    if (processedLogs.length === 0) return 0;
    
    const totalTime = processedLogs.reduce((sum, log) => sum + log.processing.duration, 0);
    return Math.round(totalTime / processedLogs.length);
  }

  // Exportar logs para análisis
  exportLogs(format: 'json' | 'csv' = 'json'): string {
    if (format === 'csv') {
      return this.exportToCsv();
    }
    return JSON.stringify(this.logs, null, 2);
  }

  private exportToCsv(): string {
    const headers = [
      'timestamp', 'requestId', 'method', 'eventType', 'pageId', 
      'success', 'duration', 'userAgent', 'notionVersion', 'error'
    ];
    
    const rows = this.logs.map(log => [
      log.timestamp,
      log.requestId,
      log.method,
      (log.payload as NotionWebhookPayload)?.type || '',
      (log.payload as NotionWebhookPayload)?.entity?.id || 
      (log.payload as NotionWebhookPayload)?.page?.id || '',
      log.processing.success.toString(),
      log.processing.duration.toString(),
      log.userAgent || '',
      log.notionVersion || '',
      log.processing.error || ''
    ]);

    return [headers, ...rows].map(row => row.join(',')).join('\n');
  }

  // Limpiar logs antiguos
  clearOldLogs(olderThanHours: number = 24) {
    const cutoffTime = new Date(Date.now() - (olderThanHours * 60 * 60 * 1000));
    const initialCount = this.logs.length;
    
    this.logs = this.logs.filter(log => 
      new Date(log.timestamp) > cutoffTime
    );
    
    const removedCount = initialCount - this.logs.length;
    
    return removedCount;
  }
}

// Singleton para mantener logs en memoria durante la sesión
export const webhookLogger = new WebhookLogger();

// Utilidades para logging específico
export function logWebhookStart(request: NextRequest, payload: NotionWebhookPayload | Record<string, unknown>): Promise<string> {
  return webhookLogger.logRequest(request, payload);
}

export function logWebhookSuccess(requestId: string, duration: number, pageId?: string, eventType?: string) {
  webhookLogger.updateProcessingResult(requestId, {
    success: true,
    duration,
    pageId,
    eventType,
    wasProcessed: true
  });
}

export function logWebhookSkipped(requestId: string, duration: number, skipReason: string, pageId?: string, eventType?: string) {
  webhookLogger.updateProcessingResult(requestId, {
    success: true,
    duration,
    pageId,
    eventType,
    wasProcessed: false,
    skipReason
  });
}

export function logWebhookError(requestId: string, duration: number, error: string, pageId?: string, eventType?: string) {
  webhookLogger.updateProcessingResult(requestId, {
    success: false,
    duration,
    error,
    pageId,
    eventType,
    wasProcessed: false
  });
}
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  images: {
    formats: ['image/webp', 'image/avif'],
  },
}

export default nextConfig
</file>

<file path="vercel.json">
{
  "functions": {
    "src/app/api/notion-webhook/route.ts": {
      "maxDuration": 30
    },
    "src/app/api/todoist-webhook/route.ts": {
      "maxDuration": 30
    },
    "src/app/api/daily-tasks/route.ts": {
      "maxDuration": 30
    }
  },
  "crons": [
    {
      "path": "/api/daily-tasks",
      "schedule": "0 6 * * *"
    }
  ]
}
</file>

<file path="__tests__/webhook-service.test.ts">
/**
 * Tests refactorizados para la nueva arquitectura
 */

import { NotionWebhookService } from '@/services/webhooks/notion-webhook.service';
import * as webhookValidator from '@/utils/notion-webhook-validator';

// Mock de dependencias
jest.mock('@/utils/notion-webhook-validator', () => ({
  isValidNotionWebhook: jest.fn(),
  shouldProcessEvent: jest.fn(),
  getEventAction: jest.fn(),
}));

jest.mock('@/utils/notion-client', () => ({
  isUserMentioned: jest.fn(),
  getNotionPageContent: jest.fn(),
  getNotionPageStatus: jest.fn(),
}));

jest.mock('@/services/webhooks/notion-todoist.service', () => ({
  NotionTodoistService: jest.fn().mockImplementation(() => ({
    processPage: jest.fn(),
    handleMentionRemoval: jest.fn(),
  })),
}));

describe('NotionWebhookService', () => {
  let service: NotionWebhookService;
  
  beforeEach(() => {
    service = new NotionWebhookService();
    jest.clearAllMocks();
  });

  afterEach(() => {
    // Limpiar timeouts pendientes para evitar warnings de Jest
    service.cleanup();
  });

  describe('Validación de webhook', () => {
    it('debe rechazar webhooks que no provienen de Notion', async () => {
      (webhookValidator.isValidNotionWebhook as jest.Mock).mockReturnValue(false);

      const payload = { entity: { id: 'test-page', type: 'page' } };
      const headers = { 'user-agent': 'not-notion', 'x-notion-signature': null };

      await expect(service.processWebhook(payload, headers))
        .rejects.toThrow('Invalid webhook - not from Notion');
    });

    it('debe aceptar webhooks válidos de Notion', async () => {
      (webhookValidator.isValidNotionWebhook as jest.Mock).mockReturnValue(true);
      (webhookValidator.shouldProcessEvent as jest.Mock).mockReturnValue(true);
      (webhookValidator.getEventAction as jest.Mock).mockReturnValue('create');

      const payload = { 
        entity: { id: 'test-page', type: 'page' },
        type: 'page.created'
      };
      const headers = { 
        'user-agent': 'notion-api', 
        'x-notion-signature': 'valid-signature' 
      };

      const result = await service.processWebhook(payload, headers);
      
      // Con el nuevo comportamiento, se procesa inmediatamente si no hay conflicto de debounce
      expect(result.message).toContain('Event processed successfully');
      expect(result.pageId).toBe('test-page');
      expect(result.eventAction).toBe('create');
    });
  });

  describe('Manejo de verificación', () => {
    it('debe manejar verificación de Notion', async () => {
      (webhookValidator.isValidNotionWebhook as jest.Mock).mockReturnValue(true);

      const payload = { verification_token: 'test-token-123' };
      const headers = { 'user-agent': 'notion-api', 'x-notion-signature': 'signature' };

      const result = await service.processWebhook(payload, headers);
      
      expect('verification_token' in result && (result as { verification_token: string }).verification_token).toBe('test-token-123');
      expect(result.message).toBe('Verification successful');
    });
  });

  describe('Validación de eventos', () => {
    it('debe rechazar eventos que no son de páginas', async () => {
      (webhookValidator.isValidNotionWebhook as jest.Mock).mockReturnValue(true);

      // Un payload sin pageId debería fallar en extractPageId
      const payload = {};
      const headers = { 'user-agent': 'notion-api', 'x-notion-signature': 'signature' };

      await expect(service.processWebhook(payload, headers))
        .rejects.toThrow('Invalid payload: missing page ID');
    });

    it('debe rechazar eventos de tipo database', async () => {
      (webhookValidator.isValidNotionWebhook as jest.Mock).mockReturnValue(true);

      const payload = { entity: { id: 'test-db', type: 'database' } };
      const headers = { 'user-agent': 'notion-api', 'x-notion-signature': 'signature' };

      await expect(service.processWebhook(payload, headers))
        .rejects.toThrow('Event ignored - not a page');
    });

    it('debe rechazar eventos de páginas eliminadas', async () => {
      (webhookValidator.isValidNotionWebhook as jest.Mock).mockReturnValue(true);
      (webhookValidator.shouldProcessEvent as jest.Mock).mockReturnValue(false);

      const payload = { 
        entity: { id: 'test-page', type: 'page' },
        type: 'page.deleted'
      };
      const headers = { 'user-agent': 'notion-api', 'x-notion-signature': 'signature' };

      await expect(service.processWebhook(payload, headers))
        .rejects.toThrow('Event ignored - page deleted');
    });
  });

  describe('Debouncing de eventos', () => {
    it('debe procesar evento inmediatamente cuando no hay conflicto de debounce', async () => {
      (webhookValidator.isValidNotionWebhook as jest.Mock).mockReturnValue(true);
      (webhookValidator.shouldProcessEvent as jest.Mock).mockReturnValue(true);
      (webhookValidator.getEventAction as jest.Mock).mockReturnValue('update');

      const payload = { 
        entity: { id: 'test-page', type: 'page' },
        type: 'page.updated'
      };
      const headers = { 'user-agent': 'notion-api', 'x-notion-signature': 'signature' };

      const result = await service.processWebhook(payload, headers);
      
      // Con el nuevo comportamiento, se procesa inmediatamente si no hay conflicto de debounce
      expect(result.message).toContain('Event processed successfully');
      expect(result.pageId).toBe('test-page');
      expect(result.eventAction).toBe('update');
      expect(result.debounceTimeMs).toBe(0);
    });

    it('debe aplicar debounce cuando hay procesamiento reciente', async () => {
      (webhookValidator.isValidNotionWebhook as jest.Mock).mockReturnValue(true);
      (webhookValidator.shouldProcessEvent as jest.Mock).mockReturnValue(true);
      (webhookValidator.getEventAction as jest.Mock).mockReturnValue('update');

      const payload = { 
        entity: { id: 'test-page-debounce', type: 'page' },
        type: 'page.updated'
      };
      const headers = { 'user-agent': 'notion-api', 'x-notion-signature': 'signature' };

      // Procesar primer evento
      await service.processWebhook(payload, headers);
      
      // Procesar segundo evento inmediatamente (debería aplicar debounce)
      const result = await service.processWebhook(payload, headers);
      
      expect(result.message).toContain('debounced');
      expect(result.pageId).toBe('test-page-debounce');
      expect(result.eventAction).toBe('update');
      expect(result.debounceTimeMs).toBe(10000); // Nuevo tiempo de debounce
    });
  });

  describe('Estadísticas del servicio', () => {
    it('debe retornar estadísticas del servicio', () => {
      const stats = service.getStats();
      
      expect(stats).toHaveProperty('currentlyTrackedPages');
      expect(stats).toHaveProperty('pendingEvents');
      expect(typeof stats.currentlyTrackedPages).toBe('number');
      expect(typeof stats.pendingEvents).toBe('number');
    });
  });

  describe('Eliminación de tareas cuando se quita la mención', () => {
    it('debe eliminar la tarea de Todoist cuando se quita la mención del usuario', async () => {
      const { isUserMentioned } = jest.requireMock('@/utils/notion-client');
      
      // Mock que indica que el usuario NO está mencionado
      (isUserMentioned as jest.Mock).mockResolvedValue(false);
      (webhookValidator.isValidNotionWebhook as jest.Mock).mockReturnValue(true);
      (webhookValidator.shouldProcessEvent as jest.Mock).mockReturnValue(true);
      (webhookValidator.getEventAction as jest.Mock).mockReturnValue('update');
      
      // Mock del resultado de handleMentionRemoval directamente en el servicio
      const mockHandleMentionRemoval = jest.fn().mockResolvedValue({
        taskDeleted: true,
        taskId: 'deleted-task-123'
      });
      
      // Asignar el mock al servicio
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (service as any).notionTodoistService.handleMentionRemoval = mockHandleMentionRemoval;

      const payload = {
        entity: { id: 'test-page-remove-mention', type: 'page' },
        type: 'page.updated'
      };
      const headers = { 'user-agent': 'notion-api', 'x-notion-signature': 'signature' };

      const result = await service.processWebhook(payload, headers);

      // Verificar que se llamó a handleMentionRemoval
      expect(mockHandleMentionRemoval).toHaveBeenCalledWith('test-page-remove-mention');
      
      // Verificar el resultado
      expect(result.message).toContain('Event processed successfully');
      expect(result.pageId).toBe('test-page-remove-mention');
    });

    it('debe manejar correctamente cuando no hay tarea que eliminar', async () => {
      const { isUserMentioned } = jest.requireMock('@/utils/notion-client');
      
      // Mock que indica que el usuario NO está mencionado
      (isUserMentioned as jest.Mock).mockResolvedValue(false);
      (webhookValidator.isValidNotionWebhook as jest.Mock).mockReturnValue(true);
      (webhookValidator.shouldProcessEvent as jest.Mock).mockReturnValue(true);
      (webhookValidator.getEventAction as jest.Mock).mockReturnValue('update');
      
      // Mock del resultado de handleMentionRemoval cuando no hay tarea
      const mockHandleMentionRemoval = jest.fn().mockResolvedValue({
        taskDeleted: false
      });
      
      // Asignar el mock al servicio  
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (service as any).notionTodoistService.handleMentionRemoval = mockHandleMentionRemoval;

      const payload = {
        entity: { id: 'test-page-no-task', type: 'page' },
        type: 'page.updated'
      };
      const headers = { 'user-agent': 'notion-api', 'x-notion-signature': 'signature' };

      const result = await service.processWebhook(payload, headers);

      // Verificar que se llamó a handleMentionRemoval
      expect(mockHandleMentionRemoval).toHaveBeenCalledWith('test-page-no-task');
      
      // Verificar el resultado
      expect(result.message).toContain('Event processed successfully');
      expect(result.pageId).toBe('test-page-no-task');
    });
  });
});

// Payloads de prueba basados en casos reales
export const testPayloads = {
  verification: {
    verification_token: 'test-verification-token-123'
  },

  pageCreated: {
    id: 'test-event-id',
    timestamp: '2025-07-15T20:25:39.546Z',
    workspace_id: 'test-workspace-id',
    workspace_name: 'Test Workspace',
    type: 'page.created',
    entity: {
      id: 'test-page-id',
      type: 'page'
    }
  },

  pageUpdated: {
    id: 'test-event-id-2',
    timestamp: '2025-07-15T20:25:40.869Z',
    workspace_id: 'test-workspace-id',
    workspace_name: 'Test Workspace',
    type: 'page.updated',
    entity: {
      id: 'test-page-id',
      type: 'page'
    }
  },

  pageDeleted: {
    id: 'test-event-id-3',
    timestamp: '2025-07-15T20:25:38.394Z',
    workspace_id: 'test-workspace-id',
    workspace_name: 'Test Workspace',
    type: 'page.deleted',
    entity: {
      id: 'test-page-id',
      type: 'page'
    }
  },

  invalidEntity: {
    id: 'test-event-id-4',
    timestamp: '2025-07-15T20:25:39.546Z',
    workspace_id: 'test-workspace-id',
    workspace_name: 'Test Workspace',
    type: 'database.created',
    entity: {
      id: 'test-database-id',
      type: 'database'
    }
  }
};
</file>

<file path="src/components/FloatSocial.tsx">
'use client'

import React from 'react'
import '@/styles/floatsocial.scss'
import strings from '@/data/contact.json'

const FloatSocial: React.FC = () => {
  return (
    <div className="floating-social">
      <ul>
        <li>
          <a href={strings.socials.github} target="_blank" rel="noopener noreferrer">
            <svg
              width="30"
              height="30"
              viewBox="0 0 25 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <g id="Github">
                <path
                  d="M12.5516 0.454773C5.92157 0.454773 0.551575 5.82477 0.551575 12.4548C0.551575 17.7648 3.98657 22.2498 8.75657 23.8398C9.35657 23.9448 9.58157 23.5848 9.58157 23.2698C9.58157 22.9848 9.56658 22.0398 9.56658 21.0348C6.55157 21.5898 5.77157 20.2998 5.53157 19.6248C5.39657 19.2798 4.81157 18.2148 4.30157 17.9298C3.88157 17.7048 3.28157 17.1498 4.28657 17.1348C5.23157 17.1198 5.90657 18.0048 6.13157 18.3648C7.21157 20.1798 8.93657 19.6698 9.62657 19.3548C9.73157 18.5748 10.0466 18.0498 10.3916 17.7498C7.72157 17.4498 4.93157 16.4148 4.93157 11.8248C4.93157 10.5198 5.39657 9.43977 6.16157 8.59977C6.04157 8.29977 5.62157 7.06977 6.28157 5.41977C6.28157 5.41977 7.28657 5.10477 9.58157 6.64977C10.5416 6.37977 11.5616 6.24477 12.5816 6.24477C13.6016 6.24477 14.6216 6.37977 15.5816 6.64977C17.8766 5.08977 18.8816 5.41977 18.8816 5.41977C19.5416 7.06977 19.1216 8.29977 19.0016 8.59977C19.7666 9.43977 20.2316 10.5048 20.2316 11.8248C20.2316 16.4298 17.4266 17.4498 14.7566 17.7498C15.1916 18.1248 15.5666 18.8448 15.5666 19.9698C15.5666 21.5748 15.5516 22.8648 15.5516 23.2698C15.5516 23.5848 15.7766 23.9598 16.3766 23.8398C18.7588 23.0355 20.8288 21.5045 22.2952 19.4621C23.7617 17.4198 24.5509 14.9691 24.5516 12.4548C24.5516 5.82477 19.1816 0.454773 12.5516 0.454773Z"
                  fill="currentColor"
                />
              </g>
            </svg>
          </a>
        </li>
        <li>
          <a href={strings.socials.twitter} target="_blank" rel="noopener noreferrer">
            <svg
              width="30"
              height="30"
              viewBox="0 0 23 19"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <g id="Twitter">
                <path
                  d="M22.869 2.41503C22.034 2.78503 21.137 3.03503 20.194 3.14803C21.167 2.56582 21.8949 1.64949 22.242 0.570028C21.3278 1.11302 20.3273 1.49522 19.284 1.70003C18.5824 0.950893 17.653 0.454354 16.6403 0.287502C15.6276 0.12065 14.5881 0.29282 13.6832 0.777281C12.7784 1.26174 12.0588 2.03139 11.6361 2.96673C11.2135 3.90207 11.1115 4.95078 11.346 5.95003C9.49367 5.85702 7.68161 5.37558 6.02741 4.53693C4.37321 3.69829 2.91383 2.52119 1.74399 1.08203C1.34399 1.77203 1.11399 2.57203 1.11399 3.42403C1.11354 4.19102 1.30242 4.94627 1.66387 5.62276C2.02531 6.29925 2.54815 6.87607 3.18599 7.30203C2.44626 7.27849 1.72286 7.07861 1.07599 6.71903V6.77903C1.07591 7.85477 1.44802 8.89741 2.12917 9.73002C2.81032 10.5626 3.75856 11.134 4.81299 11.347C4.12677 11.5327 3.40732 11.5601 2.70899 11.427C3.00648 12.3526 3.58598 13.1621 4.36635 13.742C5.14673 14.3219 6.0889 14.6432 7.06099 14.661C5.41082 15.9564 3.37287 16.6591 1.27499 16.656C0.903368 16.6561 0.532063 16.6344 0.162987 16.591C2.29246 17.9602 4.77133 18.6868 7.30299 18.684C15.873 18.684 20.558 11.586 20.558 5.43003C20.558 5.23003 20.553 5.02803 20.544 4.82803C21.4553 4.169 22.2419 3.35292 22.867 2.41803L22.869 2.41503V2.41503Z"
                  fill="currentColor"
                />
              </g>
            </svg>
          </a>
        </li>
        <li>
          <a href={strings.socials.linkedin} target="_blank" rel="noopener noreferrer">
            <svg
              width="30"
              height="30"
              viewBox="0 0 22 22"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <g id="LinkedIn">
                <path
                  fillRule="evenodd"
                  clipRule="evenodd"
                  d="M2.7206e-07 1.838C2.7206e-07 1.35053 0.193646 0.883032 0.538338 0.53834C0.88303 0.193648 1.35053 2.45031e-06 1.838 2.45031e-06H20.16C20.4016 -0.000392101 20.6409 0.0468654 20.8641 0.139069C21.0874 0.231273 21.2903 0.366612 21.4612 0.537339C21.6322 0.708065 21.7677 0.910826 21.8602 1.13401C21.9526 1.3572 22.0001 1.59643 22 1.838V20.16C22.0003 20.4016 21.9529 20.6409 21.8606 20.8642C21.7683 21.0875 21.6328 21.2904 21.462 21.4613C21.2912 21.6322 21.0884 21.7678 20.8651 21.8602C20.6419 21.9526 20.4026 22.0001 20.161 22H1.838C1.59655 22 1.35746 21.9524 1.1344 21.86C0.911335 21.7676 0.708671 21.6321 0.537984 21.4613C0.367297 21.2905 0.231932 21.0878 0.139623 20.8647C0.0473133 20.6416 -0.000131096 20.4025 2.7206e-07 20.161V1.838ZM8.708 8.388H11.687V9.884C12.117 9.024 13.217 8.25 14.87 8.25C18.039 8.25 18.79 9.963 18.79 13.106V18.928H15.583V13.822C15.583 12.032 15.153 11.022 14.061 11.022C12.546 11.022 11.916 12.111 11.916 13.822V18.928H8.708V8.388ZM3.208 18.791H6.416V8.25H3.208V18.79V18.791ZM6.875 4.812C6.88105 5.08667 6.83217 5.35979 6.73124 5.61532C6.63031 5.87084 6.47935 6.10364 6.28723 6.30003C6.09511 6.49643 5.8657 6.65248 5.61246 6.75901C5.35921 6.86554 5.08724 6.92042 4.8125 6.92042C4.53776 6.92042 4.26579 6.86554 4.01255 6.75901C3.7593 6.65248 3.52989 6.49643 3.33777 6.30003C3.14565 6.10364 2.99469 5.87084 2.89376 5.61532C2.79283 5.35979 2.74395 5.08667 2.75 4.812C2.76187 4.27286 2.98439 3.75979 3.36989 3.38269C3.75539 3.00558 4.27322 2.79442 4.8125 2.79442C5.35178 2.79442 5.86961 3.00558 6.25512 3.38269C6.64062 3.75979 6.86313 4.27286 6.875 4.812V4.812Z"
                  fill="currentColor"
                />
              </g>
            </svg>
          </a>
        </li>
        <li>
          <a href={strings.socials.instagram} target="_blank" rel="noopener noreferrer">
            <svg
              width="30"
              height="30"
              viewBox="0 0 22 22"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <g id="Instagram">
                <path
                  d="M6.465 0.066C7.638 0.012 8.012 0 11 0C13.988 0 14.362 0.013 15.534 0.066C16.706 0.119 17.506 0.306 18.206 0.577C18.939 0.854 19.604 1.287 20.154 1.847C20.714 2.396 21.146 3.06 21.422 3.794C21.694 4.494 21.88 5.294 21.934 6.464C21.988 7.639 22 8.013 22 11C22 13.988 21.987 14.362 21.934 15.535C21.881 16.705 21.694 17.505 21.422 18.205C21.146 18.9391 20.7133 19.6042 20.154 20.154C19.604 20.714 18.939 21.146 18.206 21.422C17.506 21.694 16.706 21.88 15.536 21.934C14.362 21.988 13.988 22 11 22C8.012 22 7.638 21.987 6.465 21.934C5.295 21.881 4.495 21.694 3.795 21.422C3.06092 21.146 2.39582 20.7133 1.846 20.154C1.28638 19.6047 0.853315 18.9399 0.577 18.206C0.306 17.506 0.12 16.706 0.066 15.536C0.012 14.361 0 13.987 0 11C0 8.012 0.013 7.638 0.066 6.466C0.119 5.294 0.306 4.494 0.577 3.794C0.853723 3.06008 1.28712 2.39531 1.847 1.846C2.39604 1.2865 3.06047 0.853443 3.794 0.577C4.494 0.306 5.294 0.12 6.464 0.066H6.465ZM15.445 2.046C14.285 1.993 13.937 1.982 11 1.982C8.063 1.982 7.715 1.993 6.555 2.046C5.482 2.095 4.9 2.274 4.512 2.425C3.999 2.625 3.632 2.862 3.247 3.247C2.88205 3.60205 2.60118 4.03428 2.425 4.512C2.274 4.9 2.095 5.482 2.046 6.555C1.993 7.715 1.982 8.063 1.982 11C1.982 13.937 1.993 14.285 2.046 15.445C2.095 16.518 2.274 17.1 2.425 17.488C2.601 17.965 2.882 18.398 3.247 18.753C3.602 19.118 4.035 19.399 4.512 19.575C4.9 19.726 5.482 19.905 6.555 19.954C7.715 20.007 8.062 20.018 11 20.018C13.938 20.018 14.285 20.007 15.445 19.954C16.518 19.905 17.1 19.726 17.488 19.575C18.001 19.375 18.368 19.138 18.753 18.753C19.118 18.398 19.399 17.965 19.575 17.488C19.726 17.1 19.905 16.518 19.954 15.445C20.007 14.285 20.018 13.937 20.018 11C20.018 8.063 20.007 7.715 19.954 6.555C19.905 5.482 19.726 4.9 19.575 4.512C19.375 3.999 19.138 3.632 18.753 3.247C18.3979 2.88207 17.9657 2.60121 17.488 2.425C17.1 2.274 16.518 2.095 15.445 2.046V2.046ZM9.595 14.391C10.3797 14.7176 11.2534 14.7617 12.0669 14.5157C12.8805 14.2697 13.5834 13.7489 14.0556 13.0422C14.5278 12.3356 14.7401 11.4869 14.656 10.6411C14.572 9.79534 14.197 9.00497 13.595 8.405C13.2112 8.02148 12.7472 7.72781 12.2363 7.54515C11.7255 7.36248 11.1804 7.29536 10.6405 7.34862C10.1006 7.40187 9.57915 7.57418 9.1138 7.85313C8.64846 8.13208 8.25074 8.51074 7.9493 8.96185C7.64786 9.41296 7.45019 9.92529 7.37052 10.462C7.29084 10.9986 7.33115 11.5463 7.48854 12.0655C7.64593 12.5847 7.91648 13.0626 8.28072 13.4647C8.64496 13.8668 9.09382 14.1832 9.595 14.391ZM7.002 7.002C7.52702 6.47698 8.15032 6.0605 8.8363 5.77636C9.52228 5.49222 10.2575 5.34597 11 5.34597C11.7425 5.34597 12.4777 5.49222 13.1637 5.77636C13.8497 6.0605 14.473 6.47698 14.998 7.002C15.523 7.52702 15.9395 8.15032 16.2236 8.8363C16.5078 9.52228 16.654 10.2575 16.654 11C16.654 11.7425 16.5078 12.4777 16.2236 13.1637C15.9395 13.8497 15.523 14.473 14.998 14.998C13.9377 16.0583 12.4995 16.654 11 16.654C9.50046 16.654 8.06234 16.0583 7.002 14.998C5.94166 13.9377 5.34597 12.4995 5.34597 11C5.34597 9.50046 5.94166 8.06234 7.002 7.002V7.002ZM17.908 6.188C18.0381 6.06527 18.1423 5.91768 18.2143 5.75397C18.2863 5.59027 18.3248 5.41377 18.3274 5.23493C18.33 5.05609 18.2967 4.87855 18.2295 4.71281C18.1622 4.54707 18.0624 4.39651 17.936 4.27004C17.8095 4.14357 17.6589 4.04376 17.4932 3.97652C17.3275 3.90928 17.1499 3.87598 16.9711 3.87858C16.7922 3.88119 16.6157 3.91965 16.452 3.9917C16.2883 4.06374 16.1407 4.1679 16.018 4.298C15.7793 4.55103 15.6486 4.88712 15.6537 5.23493C15.6588 5.58274 15.7992 5.91488 16.0452 6.16084C16.2911 6.40681 16.6233 6.54723 16.9711 6.5523C17.3189 6.55737 17.655 6.42669 17.908 6.188V6.188Z"
                  fill="currentColor"
                />
              </g>
            </svg>
          </a>
        </li>
      </ul>
      <div className="floating-line"></div>
    </div>
  )
}

export default FloatSocial
</file>

<file path="src/components/Footer.tsx">
'use client'

import React from 'react'
import '@/styles/footer.scss'

const Footer: React.FC = () => {
  return (
    <footer className="footer">
      <p>
        Made with 💛 by{' '}
        <a 
          href="https://github.com/imsebarz" 
          target="_blank" 
          rel="noopener noreferrer"
        >
          @imsebarz
        </a>
      </p>
    </footer>
  )
}

export default Footer
</file>

<file path="src/components/MyWork.tsx">
'use client'

import React from 'react'
import '@/styles/mywork.scss'
import Projects from '@/data/projects.json'
import type { Project as ProjectType } from '@/types'
import Project from './Project'

const { projects }: { projects: ProjectType[] } = Projects

const MyWork: React.FC = () => {
  return (
    <section className="mywork" id="mywork">
      <h1 className="title">Some other work</h1>
      <div className="mywork-container">
        {projects.map((item) => {
          if (!item.featured) {
            return <Project {...item} key={item.id} />
          }
          return null
        })}
      </div>
    </section>
  )
}

export default MyWork
</file>

<file path="src/hooks/useData.ts">
import { useState, useEffect } from 'react'
import type { Project, PersonalInfo, NavigationLinks, ContactInfo } from '@/types'

export const useProjects = () => {
  const [projects, setProjects] = useState<Project[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const loadProjects = async () => {
      try {
        const response = await import('@/data/projects.json')
        setProjects(response.projects)
      } catch (_err) {
        setError('Error loading projects')
      } finally {
        setLoading(false)
      }
    }

    loadProjects()
  }, [])

  return { projects, loading, error }
}

export const usePersonalInfo = () => {
  const [personalInfo, setPersonalInfo] = useState<PersonalInfo | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const loadPersonalInfo = async () => {
      try {
        const response = await import('@/data/aboutme.json')
        setPersonalInfo(response.default)
      } catch (_err) {
        setError('Error loading personal info')
      } finally {
        setLoading(false)
      }
    }

    loadPersonalInfo()
  }, [])

  return { personalInfo, loading, error }
}

export const useNavigation = () => {
  const [navigation, setNavigation] = useState<NavigationLinks | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const loadNavigation = async () => {
      try {
        const response = await import('@/data/nav.json')
        setNavigation(response.default)
      } catch (_err) {
        setError('Error loading navigation')
      } finally {
        setLoading(false)
      }
    }

    loadNavigation()
  }, [])

  return { navigation, loading, error }
}

export const useContact = () => {
  const [contact, setContact] = useState<ContactInfo | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const loadContact = async () => {
      try {
        const response = await import('@/data/contact.json')
        setContact(response.default)
      } catch (_err) {
        setError('Error loading contact info')
      } finally {
        setLoading(false)
      }
    }

    loadContact()
  }, [])

  return { contact, loading, error }
}
</file>

<file path="src/services/daily-filter.service.ts">
import { logger } from '@/lib/logger';

interface TodoistSection {
  id: string;
  name: string;
  project_id: string;
}

interface TodoistTask {
  id: string;
  content: string;
  description: string;
  section_id: string;
  project_id: string;
  is_completed: boolean;
  due?: {
    date: string;
    string: string;
  };
}

interface DailyFilterResult {
  success: boolean;
  day: string;
  sectionId: string | null;
  sectionName: string | null;
  tasksCount: number;
  tasks: TodoistTask[];
  projectId: string;
  filterId?: string;
  filterQuery?: string;
  filterUpdated?: boolean;
  error?: string;
}

export class DailyFilterService {
  private readonly apiUrl = 'https://api.todoist.com/rest/v2';
  private readonly token: string;
  private readonly projectId: string;
  private readonly filterName: string;

  constructor() {
    this.token = process.env.TODOIST_API_TOKEN_DAILY || process.env.TODOIST_API_TOKEN || '';
    this.projectId = process.env.TODOIST_DAILY_PROJECT_ID || '';
    this.filterName = process.env.TODOIST_DAILY_FILTER_NAME || 'Alimentacion del día';
    if (!this.token) throw new Error('TODOIST_API_TOKEN or TODOIST_API_TOKEN is required');
    if (!this.projectId) throw new Error('TODOIST_DAILY_PROJECT_ID is required');
  }

  private getCurrentDayName(): string {
    const days = ['domingo', 'lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado'];
    return days[new Date().getDay()];
  }

  private async getSections(): Promise<TodoistSection[]> {
    const response = await fetch(`${this.apiUrl}/sections?project_id=${this.projectId}`, {
      headers: { 'Authorization': `Bearer ${this.token}` },
    });
    if (!response.ok) throw new Error(`Failed to fetch sections: ${response.status} - ${response.statusText}`);
    return await response.json();
  }

  private findSectionByDay(sections: TodoistSection[], dayName: string): TodoistSection | null {
    return sections.find(section => section.name.toLowerCase().includes(dayName.toLowerCase())) || null;
  }

  private async getTasksFromSection(sectionId: string): Promise<TodoistTask[]> {
    const response = await fetch(`${this.apiUrl}/tasks?project_id=${this.projectId}&section_id=${sectionId}`, {
      headers: { 'Authorization': `Bearer ${this.token}` },
    });
    if (!response.ok) throw new Error(`Failed to fetch tasks: ${response.status} - ${response.statusText}`);
    return await response.json();
  }

  /**
   * Crea o actualiza el filtro nativo usando la API Sync v1
   */
  private async syncV1CreateOrUpdateFilter(sectionName: string): Promise<{ filterId: string; filterQuery: string; updated: boolean }> {
    const filterName = this.filterName;
    // Obtener el nombre del proyecto
    const projectInfo = await this.getProjectInfo();
    const projectName = projectInfo?.name || '';
    // El filtro debe ser #proyecto & /Seccion
    const filterQuery = `#${projectName} & /${sectionName} & !subtask`;
    const syncUrl = 'https://api.todoist.com/sync/v9/sync';
    // 1. Obtener todos los filtros
    const getRes = await fetch(syncUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        sync_token: '*',
        resource_types: '["filters"]'
      })
    });
    if (!getRes.ok) throw new Error('No se pudo obtener filtros (Sync v1)');
    const getData = await getRes.json();
    const filters = getData.filters || [];
    interface TodoistFilter {
      id: string;
      name: string;
      query: string;
      color?: string;
      favorite?: boolean;
    }
    const existing = filters.find((f: TodoistFilter) => f.name === filterName);
    if (existing) {
      if (existing.query === filterQuery) {
        return { filterId: existing.id, filterQuery, updated: false };
      }
      // Actualizar filtro
      const updateRes = await fetch(syncUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sync_token: '*',
          commands: [
            {
              type: 'filter_update',
              uuid: (globalThis.crypto?.randomUUID?.() || Math.random().toString(36).slice(2)),
              args: {
                id: existing.id,
                name: filterName,
                query: filterQuery,
                color: existing.color || 'blue',
                favorite: true
              }
            }
          ]
        })
      });
      if (!updateRes.ok) throw new Error('No se pudo actualizar el filtro (Sync v1)');
      return { filterId: existing.id, filterQuery, updated: true };
    } else {
      // Crear filtro
      const addRes = await fetch(syncUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sync_token: '*',
          commands: [
            {
              type: 'filter_add',
              uuid: (globalThis.crypto?.randomUUID?.() || Math.random().toString(36).slice(2)),
              temp_id: (globalThis.crypto?.randomUUID?.() || Math.random().toString(36).slice(2)),
              args: {
                name: filterName,
                query: filterQuery,
                color: 'blue',
                favorite: true
              }
            }
          ]
        })
      });
      if (!addRes.ok) throw new Error('No se pudo crear el filtro (Sync v1)');
      // No retorna el id directamente, así que hay que volver a consultar
      const getRes2 = await fetch(syncUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sync_token: '*',
          resource_types: '["filters"]'
        })
      });
      const getData2 = await getRes2.json();
      const created = (getData2.filters || []).find((f: TodoistFilter) => f.name === filterName && f.query === filterQuery);
      return { filterId: created?.id || '', filterQuery, updated: true };
    }
  }

  async processDailyFilter(): Promise<DailyFilterResult> {
    try {
      const currentDay = this.getCurrentDayName();
      logger.info('Processing daily filter', { day: currentDay, projectId: this.projectId });
      const sections = await this.getSections();
      logger.info('Sections found', { sectionsCount: sections.length, sections: sections.map(s => s.name) });
      const daySection = this.findSectionByDay(sections, currentDay);
      if (!daySection) {
        logger.warn('No section found for current day', { day: currentDay, availableSections: sections.map(s => s.name) });
        return {
          success: false,
          day: currentDay,
          sectionId: null,
          sectionName: null,
          tasksCount: 0,
          tasks: [],
          projectId: this.projectId,
          error: `No se encontró sección para el día: ${currentDay}`
        };
      }
      // Crear o actualizar el filtro nativo usando Sync v1
      const filterResult = await this.syncV1CreateOrUpdateFilter(daySection.name);
      const tasks = await this.getTasksFromSection(daySection.id);
      const activeTasks = tasks.filter((task: TodoistTask) => !task.is_completed);
      logger.info('Daily filter processed successfully', {
        day: currentDay,
        sectionName: daySection.name,
        totalTasks: tasks.length,
        activeTasks: activeTasks.length,
        filterId: filterResult.filterId,
        filterUpdated: filterResult.updated
      });
      return {
        success: true,
        day: currentDay,
        sectionId: daySection.id,
        sectionName: daySection.name,
        tasksCount: activeTasks.length,
        tasks: activeTasks,
        projectId: this.projectId,
        filterId: filterResult.filterId,
        filterQuery: filterResult.filterQuery,
        filterUpdated: filterResult.updated
      };
    } catch (error) {
      logger.error('Error processing daily filter', { error });
      return {
        success: false,
        day: this.getCurrentDayName(),
        sectionId: null,
        sectionName: null,
        tasksCount: 0,
        tasks: [],
        projectId: this.projectId,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  async getProjectInfo(): Promise<{ id: string; name: string } | null> {
    try {
      const response = await fetch(`${this.apiUrl}/projects/${this.projectId}`, {
        headers: { 'Authorization': `Bearer ${this.token}` },
      });
      if (!response.ok) throw new Error(`Failed to fetch project: ${response.status} - ${response.statusText}`);
      return await response.json();
    } catch (error) {
      logger.error('Error fetching project info', { error, projectId: this.projectId });

      return null;
    }
  }
}
</file>

<file path="src/styles/aboutme.scss">
@use './colors.scss';

.aboutme {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 90vh;
  max-width: 1200px;
  margin: 0 auto;
  padding: 4em 2em;
  height: auto;
  gap: 3em;

  .title {
    text-align: center;
    font-size: 3rem;
    color: colors.$black;
    border-bottom: 2px dotted colors.$green;
    padding-bottom: 0.5em;
    margin-bottom: 1em;
    font-family: var(--font-recoleta);
  }

  .aboutme-container {
    display: flex;
    width: 100%;
    max-width: 1000px;
    gap: 4em;
    align-items: flex-start;
    
    .aboutme-image {
      flex: 0 0 auto;
      width: 400px;
      
      img {
        width: 100%;
        height: auto;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }
    }
    
    .aboutme-text {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 1.5em;
      
      p {
        font-size: 1rem;
        line-height: 1.6;
        color: colors.$black;
        text-align: justify;
        margin: 0;
        
        a {
          text-decoration: none;
          color: colors.$green;
          border-bottom: 1px dotted;
          font-weight: 600;
        }
      }
      
      .technologies-title {
        font-size: 1.5rem;
        color: colors.$black;
        margin: 1em 0 0.5em 0;
        font-weight: 600;
        font-family: var(--font-recoleta);
      }
      
      .technologies-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 0.8em;
        margin-top: 0.5em;
        
        .tech-badge {
          display: inline-block;
          position: relative;
          padding: 0.4em 0.3em 0.6em;
          background: transparent;
          color: colors.$black;
          font-size: 0.9rem;
          font-weight: 500;
          white-space: nowrap;
          
          &::after {
            content: '';
            position: absolute;
            bottom: 0.2em;
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 0.6em);
            height: 1px;
            background: repeating-linear-gradient(
              to right,
              colors.$green 0,
              colors.$green 2px,
              transparent 2px,
              transparent 6px
            );
          }
        }
      }
    }
  }
}

@media screen and (max-width: 900px) {
  .aboutme {
    padding: 2em 1em;
    gap: 2em;
    
    .title {
      font-size: 2.5rem;
    }
    
    .aboutme-container {
      flex-direction: column;
      gap: 2em;
      align-items: center;
      text-align: center;
      
      .aboutme-image {
        width: 300px;
        
        img {
          width: 100%;
        }
      }
      
      .aboutme-text {
        .technologies-grid {
          justify-content: center;
        }
      }
    }
  }
}

@media screen and (max-width: 600px) {
  .aboutme {
    .title {
      font-size: 2rem;
    }
    
    .aboutme-container {
      .aboutme-image {
        width: 250px;
      }
      
      .aboutme-text {
        p {
          text-align: left;
        }
        
        .technologies-grid {
          .tech-badge {
            font-size: 0.8rem;
            padding: 0.3em 0.2em 0.5em;
            
            &::after {
              width: calc(100% - 0.4em);
            }
          }
        }
      }
    }
  }
}
</file>

<file path="src/styles/floatsocial.scss">
@use './colors.scss';

.floating-social {
  position: fixed;
  display: flex;
  flex-direction: column;
  align-items: center;
  bottom: 0;
  right: 3em;
  ul {
    list-style: none;
    li {
      margin: 1.2em 0;
      
      a {
        display: block;
        color: colors.$green;
        transition: all 0.3s ease;
        
        &:hover {
          color: colors.$pepper;
          transform: translateY(-3px);
        }
        
        svg {
          filter: brightness(1.01);
          height: 35px;
          width: auto;
          transition: inherit;
        }
      }
    }
    li::before {
      display: none;
    }
  }
  .floating-line {
    margin: 1em 0 0 0;
    width: 3px;
    height: 6em;
    background-color: colors.$green;
  }
}
</file>

<file path="jest.config.js">
/** @type {import('jest').Config} */
const config = {
  testEnvironment: 'node',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testMatch: [
    '**/__tests__/**/*.{js,ts}',
    '**/?(*.)+(spec|test).{js,ts}'
  ],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  extensionsToTreatAsEsm: ['.jsx'],
  transform: {
    '^.+\\.(ts|tsx)$': ['ts-jest', {
      useESM: true
    }]
  },
  coverageDirectory: 'coverage',
  collectCoverageFrom: [
    'src/**/*.{js,ts}',
    '!src/**/*.d.ts',
    '!src/**/*.config.{js,ts}',
  ],
  coverageReporters: ['text', 'lcov', 'html'],
  testTimeout: 10000,
  forceExit: true,
  detectOpenHandles: true
};

export default config;
</file>

<file path="README.md">
# Sebastian Ruiz - Personal Portfolio

A modern, responsive portfolio website built with Next.js, TypeScript, and SCSS. Features smooth animations, clean design, and optimized performance.

## 🚀 Features

- **Modern Tech Stack**: Next.js 15, React 19, TypeScript, SCSS
- **Responsive Design**: Mobile-first approach with optimized layouts
- **Smooth Animations**: Framer Motion for engaging user interactions
- **Performance Optimized**: Image optimization, lazy loading, and efficient bundling
- **SEO Friendly**: Meta tags, structured data, and accessibility features
- **Clean Code**: TypeScript interfaces, custom hooks, and reusable components

## 🛠️ Tech Stack

- **Framework**: Next.js 15 with App Router
- **Language**: TypeScript
- **Styling**: SCSS with CSS custom properties
- **Animations**: Framer Motion
- **Package Manager**: npm
- **Deployment**: Vercel

## 📁 Project Structure

```
src/
├── app/                    # Next.js App Router
├── components/             # React components
│   ├── common/            # Reusable components (Icon, etc.)
│   └── ...                # Feature-specific components
├── config/                # App configuration and constants
├── data/                  # JSON data files
├── hooks/                 # Custom React hooks
├── styles/                # SCSS stylesheets
├── types/                 # TypeScript type definitions
└── utils/                 # Utility functions and helpers
```

## 🚀 Getting Started

### Prerequisites

- Node.js 18+ 
- npm or yarn

### Installation

1. Clone the repository:
```bash
git clone https://github.com/imsebarz/personal-website.git
cd personal-website
```

2. Install dependencies:
```bash
npm install
```

3. Run the development server:
```bash
npm run dev
```

4. Open [http://localhost:3000](http://localhost:3000) in your browser

### Build for Production

```bash
npm run build
npm start
```

## 📦 Scripts

- `npm run dev` - Start development server
- `npm run build` - Build for production
- `npm run start` - Start production server
- `npm run lint` - Run ESLint
- `npm run type-check` - Run TypeScript compiler

## 🎨 Key Features

### Component Architecture
- **Reusable Components**: Icon component for consistent SVG usage
- **Custom Hooks**: Data fetching hooks for clean component logic
- **TypeScript**: Full type safety throughout the application

### Performance Optimizations
- **Image Optimization**: Next.js Image component with WebP format
- **Code Splitting**: Automatic code splitting with Next.js
- **CSS Variables**: Consistent theming and easier maintenance
- **Animation Performance**: Optimized Framer Motion configurations

### Accessibility
- **Semantic HTML**: Proper heading hierarchy and landmarks
- **Focus Management**: Keyboard navigation support
- **Alt Text**: Descriptive alt text for all images
- **ARIA Labels**: Screen reader friendly components

## 🌟 Sections

1. **Hero** - Introduction with animated greeting
2. **About Me** - Personal background and skills
3. **Featured Projects** - Highlighted work with details
4. **My Work** - Project gallery with tags and links
5. **Contact** - Get in touch section
6. **Footer** - Social links and credits

## 🔧 Configuration

### Environment Variables
Create a `.env.local` file for environment-specific configurations:

```env
# Add your environment variables here
NEXT_PUBLIC_SITE_URL=https://yourdomain.com
```

## 🔗 Notion-Todoist Integration

This project includes a powerful integration between Notion and Todoist with the following features:

### ✨ Key Features
- **Dynamic Project Creation**: Automatically creates Todoist projects based on Notion workspace names
- **Webhook Processing**: Handles Notion webhooks for real-time task synchronization
- **AI Enhancement**: Optional OpenAI integration for task content improvement
- **Bidirectional Sync**: Task completion sync between Notion and Todoist
- **Workspace Organization**: Tasks are organized by workspace with automatic tagging

### 🚀 Dynamic Project Creation (New Feature)
Instead of using a hardcoded `TODOIST_PROJECT_ID`, the system now:
1. Detects the workspace name from Notion webhooks
2. Creates/finds projects using the workspace name directly
3. Falls back to default project if creation fails
4. Automatically organizes tasks by workspace

### 📋 Required Environment Variables
```env
# Notion Configuration
NOTION_TOKEN=your_default_notion_token
NOTION_VERIFICATION_TOKEN=your_verification_token
NOTION_USER_ID=your_user_id

# Multi-Workspace Support
# Format: NOTION_TOKEN_[WORKSPACE_NAME_UPPERCASE_WITH_UNDERSCORES]
NOTION_TOKEN_PERSONAL=your_personal_workspace_token
NOTION_TOKEN_MY_COMPANY=your_company_workspace_token

# Todoist Configuration  
TODOIST_API_TOKEN=your_todoist_api_token
TODOIST_PROJECT_ID=your_fallback_project_id  # Optional: used as fallback

# Optional: OpenAI Enhancement
OPENAI_API_KEY=your_openai_api_key
ENABLE_AI_ENHANCEMENT=true
```

### 🏢 Multi-Workspace Support (New Feature!)
The integration now supports **multiple Notion workspaces** automatically:

1. **Automatic Workspace Detection**: Each webhook includes the workspace name
2. **Workspace-Specific Tokens**: Use different integration tokens per workspace
3. **Project Organization**: Each workspace gets its own Todoist project
4. **Backward Compatibility**: Works with existing single-workspace setups

#### Setup for Multiple Workspaces:
1. Create separate Notion integrations for each workspace
2. Set environment variables following the pattern: `NOTION_TOKEN_[WORKSPACE_NAME]`
3. Share pages with the workspace-specific integration
4. Webhooks will automatically use the correct token based on workspace name

**Example**: For workspace "Corabella Pets", set `NOTION_TOKEN_CORABELLA_PETS=your_token`

### 📚 Documentation
- [Multi-Workspace Setup Guide](./docs/multiple-workspaces-setup.md) ⭐ **New!**
- [Dynamic Project Creation Guide](./docs/dynamic-project-creation.md)
- [Webhook Configuration](./docs/webhook-vercel-fix.md)

### Customization
- **Colors**: Edit `src/styles/colors.scss`
- **Fonts**: Update font imports in `src/app/layout.tsx`
- **Content**: Modify JSON files in `src/data/`
- **Animations**: Adjust settings in `src/utils/animation.ts`

## 📱 Responsive Design

The website is fully responsive with breakpoints:
- **Mobile**: < 600px
- **Tablet**: 600px - 900px  
- **Desktop**: > 900px

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch: `git checkout -b feature-name`
3. Commit changes: `git commit -m 'Add feature'`
4. Push to branch: `git push origin feature-name`
5. Submit a pull request

## 📄 License

This project is open source and available under the [MIT License](LICENSE).

## 📧 Contact

- **Email**: imsebarz@gmail.com
- **LinkedIn**: [imsebarz](https://linkedin.com/in/imsebarz)
- **GitHub**: [imsebarz](https://github.com/imsebarz)
- **Portfolio**: [imsebarz.vercel.app](https://imsebarz.vercel.app)

---

Made with 💛 by Sebastian Ruiz
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import localFont from 'next/font/local'
import '../styles/globals.scss'

const inter = Inter({ subsets: ['latin'] })

const recoleta = localFont({
  src: '../../public/fonts/Recoleta.otf',
  variable: '--font-recoleta',
  display: 'swap',
})

export const metadata: Metadata = {
  title: 'Sebarz | Web Developer',
  description: 'Sebastian Ruiz - Full Stack Web Developer Portfolio',
  keywords: ['web developer', 'full stack', 'react', 'javascript', 'portfolio'],
  authors: [{ name: 'Sebastian Ruiz' }],
  creator: 'Sebastian Ruiz',
  metadataBase: new URL('https://imsebarz.vercel.app'),
  openGraph: {
    type: 'website',
    locale: 'en_US',
    url: 'https://imsebarz.vercel.app',
    title: 'Sebarz | Web Developer',
    description: 'Sebastian Ruiz - Full Stack Web Developer Portfolio',
    siteName: 'Sebarz Portfolio',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'Sebarz | Web Developer',
    description: 'Sebastian Ruiz - Full Stack Web Developer Portfolio',
  },
  icons: {
    icon: [
      { url: '/favicon-16x16.png', sizes: '16x16', type: 'image/png' },
      { url: '/favicon-32x32.png', sizes: '32x32', type: 'image/png' },
    ],
    apple: [
      { url: '/apple-touch-icon.png', sizes: '180x180', type: 'image/png' },
    ],
    other: [
      { url: '/android-chrome-192x192.png', sizes: '192x192', type: 'image/png' },
      { url: '/android-chrome-512x512.png', sizes: '512x512', type: 'image/png' },
    ],
  },
  manifest: '/site.webmanifest',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={`${inter.className} ${recoleta.variable}`}>
        {children}
      </body>
    </html>
  )
}
</file>

<file path="src/components/AboutMe.tsx">
'use client'

import React, { useEffect } from 'react'
import { useInView } from 'react-intersection-observer'
import { motion, useAnimation } from 'framer-motion'
import Image from 'next/image'
import '@/styles/aboutme.scss'
import { ContainerVariants } from '@/lib/animation'
import strings from '@/data/aboutme.json'

const AboutMe: React.FC = () => {
  const [ref, inView] = useInView()
  const animation = useAnimation()

  useEffect(() => {
    if (inView) {
      animation.start('visible')
    } else {
      animation.start('hidden')
    }
  }, [inView, animation])

  return (
    <motion.section className="aboutme" id="aboutme" ref={ref}>
      <motion.h1
        className="title"
        animate={animation}
        variants={ContainerVariants}
        initial="hidden"
      >
        {strings.aboutMeTitle}
      </motion.h1>
      <motion.div
        className="aboutme-container"
        animate={animation}
        variants={ContainerVariants}
        initial="hidden"
      >
        <motion.div className="aboutme-image" variants={ContainerVariants}>
          <Image 
            src="/images/sebas.webp" 
            alt="Sebastian Ruiz" 
            width={400}
            height={500}
            style={{ objectFit: 'cover' }}
          />
        </motion.div>
        <div className="aboutme-text">
          <motion.p variants={ContainerVariants} dangerouslySetInnerHTML={{ __html: strings.aboutMeText1 }} />
          <motion.p variants={ContainerVariants} dangerouslySetInnerHTML={{ __html: strings.aboutMeText2 }} />
          <motion.p variants={ContainerVariants} dangerouslySetInnerHTML={{ __html: strings.aboutMeText3 }} />
          <motion.p variants={ContainerVariants} dangerouslySetInnerHTML={{ __html: strings.aboutMeText4 }} />
          <motion.p variants={ContainerVariants} dangerouslySetInnerHTML={{ __html: strings.aboutMeText5 }} />
          
          <motion.h3 variants={ContainerVariants} className="technologies-title">
            {strings.someTechnologiesTitle}
          </motion.h3>
          <motion.div variants={ContainerVariants} className="technologies-grid">
            {strings.technologies.map((tech: string, index: number) => (
              <motion.span key={index} className="tech-badge">{tech}</motion.span>
            ))}
          </motion.div>
        </div>
      </motion.div>
    </motion.section>
  )
}

export default AboutMe
</file>

<file path="src/components/FeaturedProjects.tsx">
'use client'

import React, { useEffect } from 'react'
import { motion, useAnimation } from 'framer-motion'
import { useInView } from 'react-intersection-observer'
import '@/styles/featuredprojects.scss'
import { ContainerVariants } from '@/lib/animation'
import Projects from '@/data/projects.json'
import type { Project } from '@/types'
import FeaturedProject from './FeaturedProject'

const { projects }: { projects: Project[] } = Projects

const FeaturedProjects: React.FC = () => {
  const [ref, inView] = useInView()
  const animation = useAnimation()

  useEffect(() => {
    if (inView) {
      animation.start('visible')
    } else {
      animation.start('hidden')
    }
  }, [inView, animation])

  return (
    <section className="featuredProjects" id="featuredProjects" ref={ref}>
      <motion.h1
        className="title"
        variants={ContainerVariants}
        initial="hidden"
        animate={animation}
      >
        Featured Projects
      </motion.h1>
      <motion.div
        className="featuredProjects-container"
        variants={ContainerVariants}
        initial="hidden"
        animate={animation}
      >
        {projects.map((item, index) => {
          if (item.featured) {
            return <FeaturedProject {...item} key={item.id} index={index} />
          }
          return null
        })}
      </motion.div>
    </section>
  )
}

export default FeaturedProjects
</file>

<file path="src/lib/config.ts">
/**
 * Configuración centralizada de la aplicación
 */

export const config = {
  // Notion configuration
  notion: {
    userId: process.env.NOTION_USER_ID,
    webhookSecret: process.env.NOTION_WEBHOOK_SECRET,
  },
  
  // Todoist configuration
  todoist: {
    apiToken: process.env.TODOIST_API_TOKEN,
    projectId: process.env.TODOIST_PROJECT_ID, // Optional: fallback project when workspace-specific project creation fails
    baseUrl: 'https://api.todoist.com/rest/v2',
    webhookSecret: process.env.TODOIST_WEBHOOK_SECRET,
    clientId: process.env.TODOIST_CLIENT_ID,
    clientSecret: process.env.TODOIST_CLIENT_SECRET,
  },
  
  // OpenAI configuration
  openai: {
    apiKey: process.env.OPENAI_API_KEY,
    enabled: process.env.ENABLE_AI_ENHANCEMENT === 'true',
  },
  
  // Webhook configuration
  webhooks: {
    debounceTime: 10000, // 10 seconds - reduced for serverless compatibility
    maxRetries: 3,
    retryDelay: 1000, // 1 second
  },
  
  // Environment
  isDevelopment: process.env.NODE_ENV === 'development',
  isProduction: process.env.NODE_ENV === 'production',
} as const;

// Type-safe environment validation
export function validateEnvironment() {
  const required = {
    TODOIST_API_TOKEN: config.todoist.apiToken,
  };
  
  const optional = {
    NOTION_USER_ID: config.notion.userId,
    TODOIST_PROJECT_ID: config.todoist.projectId,
    OPENAI_API_KEY: config.openai.apiKey,
  };
  
  // Check required variables
  for (const [key, value] of Object.entries(required)) {
    if (!value) {
      throw new Error(`Missing required environment variable: ${key}`);
    }
  }
  
  // Log optional variables status
  if (config.isDevelopment) {
    console.log('🔧 Configuration status:');
    for (const [key, value] of Object.entries(optional)) {
      console.log(`  ${key}: ${value ? '✅ Set' : '❌ Not set'}`);
    }
  }
}
</file>

<file path="src/services/webhooks/notion-webhook.service.ts">
/**
 * Servicio principal para manejar webhooks de Notion
 */

import { NotionWebhookPayload } from '@/types/notion-todoist';
import { logger } from '@/lib/logger';
import { config } from '@/lib/config';
import { ValidationError } from '@/middleware/error-handler';
import { 
  isValidNotionWebhook, 
  shouldProcessEvent,
  getEventAction
} from '@/utils/notion-webhook-validator';
import { isUserMentioned } from '@/utils/notion-client';
import { NotionTodoistService } from './notion-todoist.service';

// Event debouncing management
const recentlyProcessed = new Map<string, number>();
const pendingEvents = new Map<string, { 
  payload: NotionWebhookPayload; 
  workspaceName?: string; 
  timeoutId: NodeJS.Timeout;
}>();

export class NotionWebhookService {
  private notionTodoistService: NotionTodoistService;

  constructor() {
    this.notionTodoistService = new NotionTodoistService();
  }

  /**
   * Procesa un webhook de Notion
   */
  async processWebhook(
    payload: NotionWebhookPayload,
    headers: Record<string, string | null>
  ): Promise<{
    message: string;
    pageId?: string;
    eventAction?: 'create' | 'update' | 'skip';
    debounceTimeMs?: number;
  }> {
    // 1. Validar webhook
    this.validateWebhook(payload, headers);

    // 2. Manejar verificación
    if ('verification_token' in payload) {
      return this.handleVerification(payload.verification_token!);
    }

    // 3. Extraer pageId
    const pageId = this.extractPageId(payload);
    if (!pageId) {
      throw new ValidationError('Invalid payload: missing page ID');
    }

    // 4. Validar evento
    this.validateEvent(payload, pageId);

    // 5. Procesar eventos pendientes antes de manejar el nuevo evento
    await this.processPendingEventsIfNeeded();

    // 6. Implementar debouncing mejorado para Vercel
    return this.handleEventWithDebounce(payload, pageId);
  }

  /**
   * Valida que el webhook proviene de Notion
   */
  private validateWebhook(
    payload: NotionWebhookPayload,
    headers: Record<string, string | null>
  ): void {
    const userAgent = headers['user-agent'];
    const hasNotionSignature = !!headers['x-notion-signature'];
    
    if (!isValidNotionWebhook(userAgent, hasNotionSignature)) {
      throw new ValidationError('Invalid webhook - not from Notion');
    }

    logger.webhookReceived(payload);
  }

  /**
   * Maneja la verificación inicial de Notion
   */
  private handleVerification(token: string): {
    message: string;
    verification_token?: string;
  } {
    logger.info('Notion verification received', { token });
    return {
      message: 'Verification successful',
      verification_token: token,
    };
  }

  /**
   * Extrae el ID de la página del payload
   */
  private extractPageId(payload: NotionWebhookPayload): string | null {
    return payload.entity?.id || payload.page?.id || null;
  }

  /**
   * Valida que el evento debe ser procesado
   */
  private validateEvent(payload: NotionWebhookPayload, pageId: string): void {
    // Verificar que es una página
    if (payload.entity?.type !== 'page' && !payload.page) {
      throw new ValidationError('Event ignored - not a page');
    }

    // Verificar si el evento debe ser procesado
    if (!shouldProcessEvent(payload.type)) {
      if (payload.type === 'page.deleted') {
        logger.info('Page deleted - ignoring event', { pageId });
        throw new ValidationError('Event ignored - page deleted');
      } else {
        logger.info('Event ignored - not relevant', { 
          eventType: payload.type,
          pageId 
        });
        throw new ValidationError(`Event ${payload.type} ignored`);
      }
    }
  }

  /**
   * Maneja el evento con debouncing adaptado para Vercel
   */
  private async handleEventWithDebounce(
    payload: NotionWebhookPayload,
    pageId: string
  ): Promise<{
    message: string;
    pageId: string;
    eventAction: 'create' | 'update' | 'skip';
    debounceTimeMs: number;
  }> {
    const now = Date.now();
    const lastProcessed = recentlyProcessed.get(pageId);
    
    // Cancelar evento pendiente anterior si existe
    const existingPendingEvent = pendingEvents.get(pageId);
    if (existingPendingEvent) {
      clearTimeout(existingPendingEvent.timeoutId);
      logger.info('Canceling previous event, updating with latest', { pageId });
    }
    
    // Verificar si necesitamos debounce o podemos procesar inmediatamente
    const needsDebounce = lastProcessed && (now - lastProcessed) < config.webhooks.debounceTime;
    
    if (needsDebounce) {
      const timeSince = Math.round((now - lastProcessed) / 1000);
      logger.info('Page recently processed, scheduling latest event', { 
        pageId, 
        timeSinceLastProcess: timeSince 
      });
      
      // En lugar de setTimeout, guardamos el evento para el próximo webhook
      pendingEvents.set(pageId, {
        payload,
        workspaceName: payload.workspace_name,
        timeoutId: setTimeout(() => {}, 0) // Placeholder
      });
      
      // Limpiar entradas antiguas
      this.cleanupOldEntries(now);
      
      const eventAction = getEventAction(payload.type);
      
      return {
        message: 'Event debounced - will be processed on next webhook or after cooldown',
        pageId,
        eventAction,
        debounceTimeMs: config.webhooks.debounceTime,
      };
    } else {
      // Procesar inmediatamente si no hay conflicto de debounce
      logger.info('Processing event immediately - no recent processing detected', { pageId });
      
      // Marcar como procesado antes de procesar para evitar duplicados
      recentlyProcessed.set(pageId, now);
      
      // Procesar el evento inmediatamente
      try {
        await this.processDeferredEvent(payload, pageId);
        
        const eventAction = getEventAction(payload.type);
        return {
          message: 'Event processed successfully',
          pageId,
          eventAction,
          debounceTimeMs: 0,
        };
      } catch (error) {
        // Si falla, remover de recentlyProcessed para permitir reintento
        recentlyProcessed.delete(pageId);
        throw error;
      }
    }
  }

  /**
   * Procesa el evento después del debounce
   */
  private async processDeferredEvent(
    payload: NotionWebhookPayload,
    pageId: string
  ): Promise<void> {
    try {
      logger.info('Processing final event for page', { pageId });
      
      // Remover de eventos pendientes
      pendingEvents.delete(pageId);
      
      // Marcar como procesado
      recentlyProcessed.set(pageId, Date.now());
      
      // Verificar mención de usuario si está configurado
      if (config.notion.userId) {
        const isMentioned = await isUserMentioned(pageId, config.notion.userId, payload.workspace_name);
        if (!isMentioned) {
          logger.info('User not mentioned in page - checking for existing task to remove', { pageId });
          
          // Verificar si existe una tarea en Todoist para esta página
          const result = await this.notionTodoistService.handleMentionRemoval(pageId);
          if (result.taskDeleted) {
            logger.info('Task deleted from Todoist due to mention removal', { 
              pageId, 
              taskId: result.taskId 
            });
          } else {
            logger.info('No existing task found to delete', { pageId });
          }
          return;
        }
      }
      
      // Procesar la página
      const eventAction = getEventAction(payload.type);
      const result = await this.notionTodoistService.processPage(
        pageId, 
        payload.workspace_name, 
        eventAction
      );
      
      if (result.success) {
        const actionText = eventAction === 'update' ? 'updated' : 'processed';
        logger.webhookProcessed(pageId, actionText);
      } else {
        logger.error('Error processing page', new Error(result.error || 'Unknown error'), {
          pageId,
          action: eventAction
        });
      }
    } catch (error) {
      logger.error('Error in deferred processing', error as Error, { pageId });
      pendingEvents.delete(pageId);
    }
  }

  /**
   * Procesa eventos pendientes que han superado su tiempo de debounce
   */
  private async processPendingEventsIfNeeded(): Promise<void> {
    const now = Date.now();
    const eventsToProcess: Array<{ pageId: string; payload: NotionWebhookPayload }> = [];
    
    // Identificar eventos que ya pueden ser procesados
    const pendingEntries = Array.from(pendingEvents.entries());
    for (const [pageId, eventData] of pendingEntries) {
      const lastProcessed = recentlyProcessed.get(pageId);
      const timeSinceLastProcess = lastProcessed ? now - lastProcessed : Infinity;
      
      if (timeSinceLastProcess >= config.webhooks.debounceTime) {
        eventsToProcess.push({ pageId, payload: eventData.payload });
        clearTimeout(eventData.timeoutId);
        pendingEvents.delete(pageId);
      }
    }
    
    // Procesar eventos pendientes
    for (const { pageId, payload } of eventsToProcess) {
      try {
        logger.info('Processing pending event that exceeded debounce time', { pageId });
        await this.processDeferredEvent(payload, pageId);
      } catch (error) {
        logger.error('Error processing pending event', error as Error, { pageId });
      }
    }
  }

  /**
   * Limpia entradas antiguas del mapa de procesamiento reciente
   */
  private cleanupOldEntries(now: number): void {
    const entriesToDelete: string[] = [];
    const recentEntries = Array.from(recentlyProcessed.entries());
    for (const [id, timestamp] of recentEntries) {
      if (now - timestamp > config.webhooks.debounceTime * 2) {
        entriesToDelete.push(id);
      }
    }
    entriesToDelete.forEach(id => recentlyProcessed.delete(id));
  }

  /**
   * Obtiene estadísticas del servicio
   */
  getStats(): {
    currentlyTrackedPages: number;
    pendingEvents: number;
  } {
    return {
      currentlyTrackedPages: recentlyProcessed.size,
      pendingEvents: pendingEvents.size,
    };
  }

  /**
   * Limpia todos los timeouts pendientes y resetea el estado del servicio
   * Útil para testing y cleanup
   */
  cleanup(): void {
    // Cancelar todos los timeouts pendientes
    pendingEvents.forEach(event => {
      clearTimeout(event.timeoutId);
    });
    
    // Limpiar los mapas
    pendingEvents.clear();
    recentlyProcessed.clear();
    
    logger.info('Service cleanup completed', {
      message: 'All pending timeouts cleared and state reset'
    });
  }
}
</file>

<file path="src/services/index.ts">
/**
 * Exportaciones centralizadas para servicios
 */

export { NotionWebhookService } from './webhooks/notion-webhook.service';
export { NotionTodoistService } from './webhooks/notion-todoist.service';
export { TodoistWebhookService } from './webhooks/todoist-webhook.service';
export { HealthCheckService } from './health-check.service';
export { DailyFilterService } from './daily-filter.service';
export { MealPlanService } from './meal-plan.service';
</file>

<file path="src/styles/hero.scss">
@use './colors.scss';

.hero {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
  min-height: 100vh;
  max-width: 1200px;
  color: colors.$mint;
  height: auto;
  margin-top: 3em;
  margin-bottom: 0;
  gap: 2em;
  .hero-bg {
    position: absolute;
    width: 100%;
    height: 100%;
    left: 0px;
    top:0;
    object-fit: cover;
    z-index: -1;
  }
  .hero-info {
    display: flex;
    flex-direction: column;
    margin-right: 3em;
    width: 30%;
    min-width: 250px;
    flex-grow: 1;
    gap: 10px;

    button {
      width: 15em;
      margin-top: 2em;
      height: 4em;
      color: colors.$mint;
      background-color: colors.$green;
      border: 1.5px solid colors.$mint;
      border-radius: 10px;
      font-weight: 500;
      font-family: "Roboto";
    }

    button:hover {
      background-color: colors.$mint;
      border-color: colors.$green;
      color: colors.$green;
      transition: background 0.3s ease;
    }

    h1 {
      font-size: 70px;
      color: colors.$black;
      font-weight: 900;
      font-family: var(--font-recoleta);
    }
    h2 {
      font-size: 35px;
      color: colors.$pepper;
      font-family: var(--font-recoleta);
    }
    p {
      font-size: 30px;
      color: colors.$pepper;
    }

    span {
      font-weight: 900;
    }
  }
  #hero-img {
    width: 90%;
    min-width: 240px;
    height: auto;
  }
}

@media screen and (max-width: 905px) {
  .hero {
    flex-direction: column-reverse;
    justify-content: center;
    margin-top: 7em;
    .hero-info {
      width: 100%;
      place-items: center;
      text-align: center;
      margin: 0px auto;
      max-height: fit-content;
    }
    img {
      width: 50%;
      height: auto;
    }
    .hero-bg{
      height: 1000px;
    }
  }
}
</file>

<file path="src/styles/nav.scss">
@use "./colors.scss";

.nav {
  position: fixed;
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: space-between;
  padding: 0.8em 10em;
  background-color: rgba(colors.$black, 0.8);
  color: colors.$mint;
  font-weight: 500;
  font-size: 17px;
  z-index: 11;
  .nav-links {
    width: 50%;
    opacity: 1;
    list-style: none;
    display: flex;
    justify-content: space-between;
    align-items: center;
    li {
      a {
        color: colors.$mint;
        text-decoration: none;
      }
    }
    li::before {
      display: none;
    }
  }
  a {
    text-decoration: none;
  }
  h1 {
    color: colors.$mint;
  }
  button {
    width: 10em;
    height: 3.5em;
    color: colors.$green;
    background-color: colors.$mint;
    border: 1.5px dotted colors.$green;
    border-radius: 10px;
    font-weight: 500;
    font-family: "Roboto";
  }

  button:hover {
    cursor: pointer;
  }

  .hamburger {
    display: none;
  }

  .hamburger.closed {
    svg {
      #top,
      #middle,
      #bottom {
        transform: rotate(0deg) translate(0px, 0px);
        transition: all 0.1s ease;
      }
      path {
        fill: colors.$mint;
      }
    }
  }

  .hamburger.open {
    svg {
      #top {
        transform: rotate(45deg) translate(15%, -20%);
        transition: all 0.1s ease;
        transform-origin: top left;
      }
      #middle {
        transition: all 0.1s ease;
        opacity: 0;
      }
      #bottom {
        transition: all 0.1s ease;
        transform-origin: top left;
        transform: rotate(-45deg) translate(-45%, -15%);
      }
    }
  }

  .sidebar {
    position: fixed;
    height: 100vh;
    display: flex;
    align-items: center;
    width: 65vw;
    min-width: 250px;
    padding: 2em;
    top: 0;
    right: -100%;
    background: colors.$green;
    z-index: 10;
    transition: all 0.2s ease;
    .aside-links {
      place-content: center;
      display: flex;
      flex-direction: column;
      height: 60%;
      width: 100%;
      justify-content: space-between;
      align-items: center;
      li {
        list-style: none;
        a {
          color: colors.$mint;
          text-decoration: none;
        }
      }
      li::before {
        display: none;
      }
    }
  }
}

@media screen and (max-width: 900px) {
  .nav {
    padding: 0.8em 2em;
    .nav-links {
      display: none;
    }
    .hamburger {
      display: flex;
      place-items: center;
      z-index: 20;
      svg {
        height: 25px;
        width: auto;
      }
    }
    .sidebar {
      .aside-links {
        font-size: 24px;
      }
      button {
        font-size: 22px;
      }
      .aside-social {
        display: flex;
        width: 100%;
        justify-content: center;
        gap: 7%;
        min-height: 80px;
        svg {
          width: 25px;
          height: auto;
          path {
            fill: colors.$mint;
          }
        }
      }
    }
  }
}

@media screen and (min-width: 900px) {
  .sidebar {
    display: none !important;
  }
}
</file>

<file path="src/types/notion-todoist.ts">
// Interfaces para la integración Notion-Todoist basadas en la documentación oficial

export interface NotionWebhookPayload {
  // Campos de verificación
  verification_token?: string;  // Para verificación inicial del endpoint
  
  // Campos de eventos reales (formato actual de la documentación)
  id?: string;                  // ID único del evento
  timestamp?: string;           // Timestamp del evento
  workspace_id?: string;        // ID del workspace
  workspace_name?: string;      // Nombre del workspace
  subscription_id?: string;     // ID de la suscripción
  integration_id?: string;      // ID de la integración
  type?: string;               // Tipo de evento (page.created, page.content_updated, etc.)
  attempt_number?: number;      // Número de intento de entrega
  
  // Autores del cambio
  authors?: Array<{
    id: string;
    type: string;
  }>;
  
  // Entidad afectada (página, base de datos, etc.)
  entity?: {
    id: string;
    type: string;  // "page", "database", "comment", etc.
  };
  
  // Datos adicionales del evento
  data?: {
    parent?: {
      id: string;
      type: string;
    };
    updated_blocks?: Array<{
      id: string;
      type: string;
    }>;
  };
  
  // Campos legacy para retrocompatibilidad
  object?: string;              
  event_ts?: string;            
  event_id?: string;            
  event_type?: string;          
  user_id?: string;            
  
  // Para retrocompatibilidad con formatos anteriores
  page?: {
    id: string;
    created_time: string;
    last_edited_time: string;
    created_by: {
      object: string;
      id: string;
    };
    last_edited_by: {
      object: string;
      id: string;
    };
    cover?: unknown;
    icon?: unknown;
    parent: {
      type: string;
      database_id?: string;
      page_id?: string;
    };
    archived: boolean;
    properties: {
      [key: string]: unknown;
    };
    url: string;
    public_url?: string;
  };
  
  properties?: {
    [key: string]: unknown;
  };
}

// Interfaces para Todoist Webhooks
export interface TodoistWebhookPayload {
  event_name: string;           // Tipo de evento: item:completed, item:added, etc.
  user_id: string;             // ID del usuario que ejecutó la acción
  event_data: TodoistEventData; // Datos del evento específico
  initiator: TodoistInitiator;  // Usuario que inició la acción
  triggered_at: string;        // Timestamp del evento
  version: string;             // Versión del webhook
  event_data_extra?: {         // Información extra opcional
    old_item?: TodoistEventData;
    update_intent?: string;    // item_updated, item_completed, item_uncompleted
  };
}

export interface TodoistEventData {
  id: string;                  // ID de la tarea
  content: string;             // Contenido/título de la tarea
  description: string;         // Descripción de la tarea
  project_id: string;          // ID del proyecto
  section_id?: string | null;  // ID de la sección
  parent_id?: string | null;   // ID de la tarea padre
  order: number;               // Orden de la tarea
  labels: string[];            // Labels/etiquetas
  priority: number;            // Prioridad (1-4)
  due?: {                      // Fecha de vencimiento
    date: string;
    timezone?: string;
    string: string;
    lang: string;
    is_recurring: boolean;
  } | null;
  url: string;                 // URL de la tarea en Todoist
  comment_count: number;       // Número de comentarios
  created_at: string;          // Fecha de creación
  creator_id: string;          // ID del creador
  assignee_id?: string | null; // ID del asignado
  assigner_id?: string | null; // ID del que asignó
  is_completed: boolean;       // Si está completada
  completed_at?: string | null;// Fecha de completado
  added_at: string;           // Fecha de adición
  added_by_uid: string;       // ID del usuario que agregó
  assigned_by_uid?: string | null; // ID del usuario que asignó
  responsible_uid?: string | null; // ID del responsable
  checked: boolean;           // Si está marcada como completada
  child_order: number;        // Orden entre tareas hijas
  collapsed: boolean;         // Si está colapsada
  deadline?: string | null;   // Fecha límite
  is_deleted: boolean;        // Si está eliminada
  user_id: string;           // ID del usuario
}

export interface TodoistInitiator {
  email: string;              // Email del usuario
  full_name: string;          // Nombre completo
  id: string;                // ID del usuario
  image_id?: string;         // ID de la imagen de perfil
  is_premium: boolean;       // Si es usuario premium
}

export interface TodoistTask {
  content: string;
  description?: string;
  project_id?: string;
  section_id?: string;
  parent_id?: string;
  order?: number;
  labels?: string[];
  priority?: number;
  due_string?: string;
  due_date?: string;
  due_datetime?: string;
  due_lang?: string;
  assignee_id?: string;
}

export interface TodoistCreateTaskResponse {
  id: string;
  assigner_id?: string;
  assignee_id?: string;
  project_id: string;
  section_id?: string;
  parent_id?: string;
  order: number;
  content: string;
  description: string;
  is_completed: boolean;
  labels: string[];
  priority: number;
  comment_count: number;
  is_shared: boolean;
  created_at: string;
  due?: {
    date: string;
    is_recurring: boolean;
    datetime?: string;
    string: string;
    timezone?: string;
  };
  url: string;
}

export interface NotionPageContent {
  title: string;
  content: string;
  url: string;
  priority?: number;
  dueDate?: string;
  assignee?: string;
  tags?: string[];
}

export interface OpenAIEnhancement {
  enhancedTitle: string;
  enhancedDescription: string;
  suggestedPriority: number;
  suggestedLabels: string[];
  suggestedDueDate?: string;
}

export interface ProcessingResult {
  success: boolean;
  todoistTaskId?: string;
  taskId?: string;  // Alias para todoistTaskId
  notionPageId?: string;
  enhancedWithAI?: boolean;
  action?: 'created' | 'updated' | 'completed';
  title?: string;
  message?: string;
  error?: string;
}
</file>

<file path="src/utils/notion-webhook-validator.ts">
import crypto from 'crypto';

/**
 * Validates Notion webhook signatures using HMAC-SHA256
 * @param signature - The signature from x-notion-signature header
 * @param body - The raw request body
 * @param secret - The webhook secret from Notion
 * @returns boolean indicating if the signature is valid
 */
export function validateNotionWebhookSignature(
  signature: string | null,
  body: string,
  secret: string
): boolean {
  if (!signature || !secret) {
    return false;
  }

  // Remove 'sha256=' prefix if present
  const cleanSignature = signature.replace('sha256=', '');
  
  // Create HMAC using the webhook secret
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(body, 'utf8')
    .digest('hex');
  
  // Use timingSafeEqual to prevent timing attacks
  try {
    return crypto.timingSafeEqual(
      Buffer.from(cleanSignature, 'hex'),
      Buffer.from(expectedSignature, 'hex')
    );
  } catch (_error) {
    return false;
  }
}

/**
 * Checks if the request appears to come from Notion based on headers
 * @param userAgent - The user-agent header
 * @param hasSignature - Whether the request has a notion signature
 * @returns boolean indicating if it looks like a Notion webhook
 */
export function isValidNotionWebhook(
  userAgent: string | null,
  hasSignature: boolean
): boolean {
  // Basado en logs reales: Notion usa 'notion-api' como user-agent
  // También permitimos requests con signature válida
  return userAgent === 'notion-api' || hasSignature;
}

/**
 * Determines if an event type should trigger task processing (creation or update)
 * @param eventType - The type of Notion event
 * @returns boolean indicating if the event should be processed
 */
export function shouldProcessEvent(eventType: string | undefined): boolean {
  const relevantEvents = [
    'page.created',
    'page.updated',           // Evento tradicional de actualización
    'page.content_updated',   // Evento real encontrado en logs
    'page.property_updated',  // Actualizaciones de propiedades
    'page.properties_updated' // Variante real del evento encontrada en logs
  ];
  
  return relevantEvents.includes(eventType || '');
}

/**
 * Determines if an event type should create a new task or update an existing one
 * @param eventType - The type of Notion event
 * @returns 'create' | 'update' indicating the action to take
 */
export function getEventAction(eventType: string | undefined): 'create' | 'update' {
  const updateEvents = [
    'page.updated',
    'page.content_updated',
    'page.property_updated',
    'page.properties_updated'
  ];
  
  return updateEvents.includes(eventType || '') ? 'update' : 'create';
}
</file>

<file path="src/utils/openai-client.ts">
import OpenAI from 'openai';
import { NotionPageContent, OpenAIEnhancement } from '@/types/notion-todoist';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function enhanceTaskWithAI(pageContent: NotionPageContent): Promise<OpenAIEnhancement> {
  const userPrompt = `
Analiza el siguiente contenido de una página de Notion y mejora la información para crear una tarea en Todoist:

Título: ${pageContent.title}
Contenido: ${pageContent.content}
URL: ${pageContent.url}
Prioridad actual: ${pageContent.priority}
Fecha de vencimiento: ${pageContent.dueDate || 'No especificada'}
Asignado: ${pageContent.assignee || 'No especificado'}
Etiquetas: ${pageContent.tags?.join(', ') || 'Ninguna'}

Por favor, proporciona:
1. Un título mejorado y más claro para la tarea
2. Una descripción CORTA Y CONCISA (máximo 2-3 líneas) que resuma lo esencial
3. Una prioridad sugerida (1-4, donde 4 es la más alta)
4. Etiquetas sugeridas relevantes (SOLO usa: nombre del proyecto, nombre de la tabla/base de datos, o etiquetas existentes en la respuesta original de Notion)
5. Una fecha de vencimiento sugerida si no hay una (formato YYYY-MM-DD)

IMPORTANTE: 
- La descripción debe ser BREVE y DIRECTA, sin pasos detallados ni explicaciones extensas
- Incluye únicamente el objetivo principal y contexto mínimo necesario
- No inventes subtareas ni dividas la tarea principal
- Para las etiquetas, ÚNICAMENTE usa información que ya existe en los datos de Notion proporcionados

Responde en formato JSON con la siguiente estructura:
{
  "enhancedTitle": "título mejorado",
  "enhancedDescription": "descripción breve y concisa (máximo 2-3 líneas)",
  "suggestedPriority": número_entre_1_y_4,
  "suggestedLabels": ["etiqueta1", "etiqueta2"],
  "suggestedDueDate": "YYYY-MM-DD o null si no es necesaria"
}
`;

  try {
    const response = await openai.responses.create({
      model: 'gpt-4.1-mini',
      instructions: 'Eres un asistente experto en productividad que ayuda a optimizar tareas y proyectos. Responde únicamente con JSON válido.',
      input: userPrompt,
      text: {
        format: { type: 'json_object' }
      },
      max_output_tokens: 500,
    });

    const content = response.output_text;
    if (!content) {
      throw new Error('No se recibió respuesta de OpenAI');
    }

    return parseOpenAIResponse(content, pageContent);
  } catch (error: unknown) {
    // Mostrar mensaje específico según el tipo de error
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const errorObj = error as any;
    if (errorObj?.status === 429) {
      // Cuota de OpenAI excedida - usando contenido original
    } else if (errorObj?.status === 401) {
      // Token de OpenAI inválido - usando contenido original
    } else {
      // Error de OpenAI - usando contenido original
    }
    
    // Fallback si falla OpenAI
    return {
      enhancedTitle: pageContent.title,
      enhancedDescription: `${pageContent.content.length > 100 ? pageContent.content.substring(0, 100) + '...' : pageContent.content}\n\n🔗 Ver en Notion: ${pageContent.url}`,
      suggestedPriority: pageContent.priority || 2,
      suggestedLabels: pageContent.tags && pageContent.tags.length > 0 ? pageContent.tags : ['notion'],
      suggestedDueDate: pageContent.dueDate,
    };
  }
}

function parseOpenAIResponse(content: string, pageContent: NotionPageContent): OpenAIEnhancement {
  try {
    const parsed = JSON.parse(content);
    return {
      enhancedTitle: parsed.enhancedTitle || pageContent.title,
      enhancedDescription: parsed.enhancedDescription || pageContent.content,
      suggestedPriority: Math.min(Math.max(parsed.suggestedPriority || pageContent.priority || 1, 1), 4),
      suggestedLabels: Array.isArray(parsed.suggestedLabels) ? parsed.suggestedLabels : pageContent.tags || [],
      suggestedDueDate: parsed.suggestedDueDate === 'null' ? undefined : parsed.suggestedDueDate,
    };
  } catch (_parseError) {
    // Fallback con los datos originales
    return {
      enhancedTitle: pageContent.title,
      enhancedDescription: `${pageContent.content}\n\n🔗 Ver en Notion: ${pageContent.url}`,
      suggestedPriority: pageContent.priority || 2,
      suggestedLabels: pageContent.tags && pageContent.tags.length > 0 ? pageContent.tags : ['notion'],
      suggestedDueDate: pageContent.dueDate,
    };
  }
}
</file>

<file path="__tests__/webhook.test.js">
/**
 * Tests para webhook de Notion basados en escenarios reales
 * Enfoque: Simple, atómico y fiel a los casos de uso reales
 */

// Mock del webhook handler - simulamos la nueva lógica que procesa el último evento
const createMockWebhookHandler = () => {
  const recentlyProcessed = new Map();
  const pendingEvents = new Map();
  const mockTodoistTasks = new Map(); // Simular base de datos de tareas de Todoist
  const DEBOUNCE_TIME = 1000; // Reducido para tests más rápidos

  // Función auxiliar para determinar si es creación o actualización
  const getEventAction = (eventType) => {
    const updateEvents = [
      'page.updated',
      'page.content_updated',
      'page.property_updated',
      'page.properties_updated'
    ];
    return updateEvents.includes(eventType || '') ? 'update' : 'create';
  };

  // Mock de función para encontrar tarea existente
  const findTaskByNotionUrl = (pageId) => {
    return mockTodoistTasks.get(pageId) || null;
  };

  // Mock de función para crear tarea
  const createTodoistTask = (pageId, taskData) => {
    const taskId = `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const task = { id: taskId, ...taskData, pageId };
    mockTodoistTasks.set(pageId, task);
    return task;
  };

  // Mock de función para actualizar tarea
  const updateTodoistTask = (pageId, taskData) => {
    const existingTask = mockTodoistTasks.get(pageId);
    if (existingTask) {
      const updatedTask = { ...existingTask, ...taskData, updated: true };
      mockTodoistTasks.set(pageId, updatedTask);
      return updatedTask;
    }
    return null;
  };

  const handler = async (request) => {
    const payload = await request.json();
    
    // Manejo de verificación
    if (payload.verification_token) {
      return {
        status: 200,
        data: { verification_token: payload.verification_token }
      };
    }

    // Verificar headers
    const userAgent = request.headers.get('user-agent');
    const hasSignature = !!request.headers.get('x-notion-signature');
    
    if (userAgent !== 'notion-api' || !hasSignature) {
      return {
        status: 400,
        data: { error: 'Webhook no válido - no proviene de Notion' }
      };
    }

    // Verificar que es una página
    const pageId = payload.entity?.id || payload.page?.id;
    if (!pageId || (payload.entity?.type !== 'page' && !payload.page)) {
      return {
        status: 200,
        data: { message: 'Evento ignorado - no es una página' }
      };
    }

    // Verificar eventos de páginas eliminadas
    if (payload.type === 'page.deleted') {
      return {
        status: 200,
        data: { message: 'Evento ignorado - página eliminada' }
      };
    }

    // Verificar eventos relevantes para procesamiento
    const relevantEvents = [
      'page.created',
      'page.updated',
      'page.content_updated',
      'page.property_updated',
      'page.properties_updated'
    ];
    
    if (!relevantEvents.includes(payload.type)) {
      return {
        status: 200,
        data: { message: `Evento ${payload.type} ignorado - no relevante` }
      };
    }

    // Nueva lógica de debounce: procesar el último evento
    const now = Date.now();
    
    // Si ya existe un evento pendiente, cancelarlo
    const existingPendingEvent = pendingEvents.get(pageId);
    if (existingPendingEvent) {
      clearTimeout(existingPendingEvent.timeoutId);
    }
    
    // Crear nuevo timeout para procesar este evento (el más reciente)
    const timeoutId = setTimeout(async () => {
      // Simular procesamiento del evento final
      pendingEvents.delete(pageId);
      recentlyProcessed.set(pageId, Date.now());
      
      // Determinar si es creación o actualización
      const eventAction = getEventAction(payload.type);
      
      if (eventAction === 'update') {
        // Buscar tarea existente
        const existingTask = findTaskByNotionUrl(pageId);
        if (existingTask) {
          // Actualizar tarea existente
          updateTodoistTask(pageId, {
            content: `Updated content for ${pageId}`,
            description: `Updated via ${payload.type}`,
            updated_at: new Date().toISOString()
          });
        } else {
          // No se encontró tarea existente, crear nueva
          createTodoistTask(pageId, {
            content: `New task for ${pageId}`,
            description: `Created via ${payload.type} (fallback)`,
            created_at: new Date().toISOString()
          });
        }
      } else {
        // Crear nueva tarea
        createTodoistTask(pageId, {
          content: `New task for ${pageId}`,
          description: `Created via ${payload.type}`,
          created_at: new Date().toISOString()
        });
      }
    }, DEBOUNCE_TIME);
    
    // Guardar el evento pendiente
    pendingEvents.set(pageId, {
      payload,
      timeoutId,
      timestamp: now
    });

    // Retornar respuesta inmediata
    return {
      status: 200,
      data: { 
        message: 'Evento programado para procesamiento (se procesará el más reciente)',
        pageId,
        eventAction: getEventAction(payload.type),
        debounceTimeMs: DEBOUNCE_TIME
      }
    };
  };

  // Exponer funciones auxiliares para tests
  handler.getTasksMap = () => mockTodoistTasks;
  handler.getTasks = () => Array.from(mockTodoistTasks.values());
  handler.getTaskByPageId = (pageId) => mockTodoistTasks.get(pageId);
  handler.clearTasks = () => mockTodoistTasks.clear();
  handler.cleanup = () => {
    // Limpiar timeouts pendientes
    pendingEvents.forEach(event => {
      if (event.timeoutId) {
        clearTimeout(event.timeoutId);
      }
    });
    pendingEvents.clear();
    recentlyProcessed.clear();
    mockTodoistTasks.clear();
  };

  return handler;
};

// Mock request
const createMockRequest = (payload = null) => ({
  json: jest.fn().mockResolvedValue(payload),
  headers: {
    get: jest.fn((header) => {
      const headers = {
        'user-agent': 'notion-api',
        'x-notion-signature': 'sha256=test-signature',
        'content-type': 'application/json',
      };
      return headers[header] || null;
    })
  }
});

// Payloads basados en logs reales
const realPayloads = {
  pageDeleted: {
    id: "f426b1e2-c5de-41a6-84e1-1aa3edaf8fd7",
    timestamp: "2025-07-15T20:25:38.394Z",
    workspace_id: "bcd7dac8-d5d8-4726-ad5a-f6a0e1ad9ef1",
    workspace_name: "Corabella Pets",
    subscription_id: "231d872b-594c-8122-963e-0099eb119522",
    integration_id: "230d872b-594c-8060-8665-0037427fe4f8",
    authors: [{
      id: "79d3b102-9821-4d8e-bf2b-1e94a65d5120",
      type: "person"
    }],
    attempt_number: 1,
    entity: {
      id: "2311ad4d-650d-8012-95cf-f4bbd3581f4a",
      type: "page"
    },
    type: "page.deleted",
    data: {
      parent: {
        id: "1f61ad4d-650d-80e0-b231-d9b12ffea832",
        type: "database"
      }
    }
  },

  pageContentUpdated: {
    id: "80aeb0fc-dd26-44b6-b742-d0f47c3f978c",
    timestamp: "2025-07-15T20:25:40.869Z",
    workspace_id: "bcd7dac8-d5d8-4726-ad5a-f6a0e1ad9ef1",
    workspace_name: "Corabella Pets",
    subscription_id: "231d872b-594c-8122-963e-0099eb119522",
    integration_id: "230d872b-594c-8060-8665-0037427fe4f8",
    authors: [{
      id: "79d3b102-9821-4d8e-bf2b-1e94a65d5120",
      type: "person"
    }],
    attempt_number: 1,
    entity: {
      id: "2311ad4d-650d-8034-a3bf-c882d00b435a",
      type: "page"
    },
    type: "page.content_updated",
    data: {
      parent: {
        id: "1f61ad4d-650d-80e0-b231-d9b12ffea832",
        type: "database"
      },
      updated_blocks: [
        { id: "2311ad4d-650d-8039-809f-c4941f3f0d9d", type: "block" },
        { id: "2311ad4d-650d-8091-97e1-df44b75c765e", type: "block" }
      ]
    }
  },

  pageCreated: {
    id: "a9d20b68-b722-46a3-8cf9-8153eb70c9dc",
    timestamp: "2025-07-15T20:25:39.546Z",
    workspace_id: "bcd7dac8-d5d8-4726-ad5a-f6a0e1ad9ef1",
    workspace_name: "Corabella Pets",
    subscription_id: "231d872b-594c-8122-963e-0099eb119522",
    integration_id: "230d872b-594c-8060-8665-0037427fe4f8",
    authors: [{
      id: "79d3b102-9821-4d8e-bf2b-1e94a65d5120",
      type: "person"
    }],
    attempt_number: 1,
    entity: {
      id: "2311ad4d-650d-8034-a3bf-c882d00b435a",
      type: "page"
    },
    type: "page.created",
    data: {
      parent: {
        id: "1f61ad4d-650d-80e0-b231-d9b12ffea832",
        type: "database"
      }
    }
  },

  pagePropertiesUpdated: {
    id: "33173d5b-b4fc-4976-96eb-8e7a4941410e",
    timestamp: "2025-07-15T21:40:48.566Z",
    workspace_id: "bcd7dac8-d5d8-4726-ad5a-f6a0e1ad9ef1",
    workspace_name: "Corabella Pets",
    subscription_id: "231d872b-594c-8122-963e-0099eb119522",
    integration_id: "230d872b-594c-8060-8665-0037427fe4f8",
    authors: [{
      id: "79d3b102-9821-4d8e-bf2b-1e94a65d5120",
      type: "person"
    }],
    attempt_number: 1,
    entity: {
      id: "2311ad4d-650d-803e-8470-d503ff8e7985",
      type: "page"
    },
    type: "page.properties_updated",
    data: {
      parent: {
        id: "1f61ad4d-650d-80e0-b231-d9b12ffea832",
        type: "database"
      },
      updated_properties: [
        "Vun%7C"
      ]
    }
  },

  verification: {
    verification_token: "test-verification-token-123"
  }
};

describe('Notion Webhook - Escenarios Reales', () => {
  let webhookHandler;
  let mockRequest;

  beforeEach(() => {
    webhookHandler = createMockWebhookHandler();
    mockRequest = createMockRequest();
  });

  afterEach(() => {
    // Limpiar timeouts pendientes para evitar warnings de Jest
    if (webhookHandler && webhookHandler.cleanup) {
      webhookHandler.cleanup();
    }
  });

  describe('Verificación de endpoint', () => {
    it('debe responder correctamente a verificación de Notion', async () => {
      mockRequest.json.mockResolvedValue(realPayloads.verification);

      const response = await webhookHandler(mockRequest);

      expect(response.status).toBe(200);
      expect(response.data).toEqual({
        verification_token: 'test-verification-token-123'
      });
    });
  });

  describe('Páginas eliminadas', () => {
    it('debe ignorar eventos de página eliminada', async () => {
      mockRequest.json.mockResolvedValue(realPayloads.pageDeleted);

      const response = await webhookHandler(mockRequest);

      expect(response.status).toBe(200);
      expect(response.data.message).toContain('página eliminada');
    });
  });

  describe('Prevención de duplicados - Procesa último evento', () => {
    it('debe programar el primer evento y reprogramar con eventos posteriores', async () => {
      // Primer request - debe programarse
      mockRequest.json.mockResolvedValueOnce(realPayloads.pageContentUpdated);
      const firstResponse = await webhookHandler(mockRequest);
      
      expect(firstResponse.status).toBe(200);
      expect(firstResponse.data.message).toContain('programado para procesamiento');
      expect(firstResponse.data.pageId).toBe('2311ad4d-650d-8034-a3bf-c882d00b435a');

      // Segundo request inmediato - debe cancelar el anterior y programar este
      mockRequest.json.mockResolvedValueOnce({
        ...realPayloads.pageCreated,
        entity: { id: '2311ad4d-650d-8034-a3bf-c882d00b435a', type: 'page' } // Same pageId
      });
      const secondResponse = await webhookHandler(mockRequest);
      
      expect(secondResponse.status).toBe(200);
      expect(secondResponse.data.message).toContain('programado para procesamiento');
      expect(secondResponse.data.pageId).toBe('2311ad4d-650d-8034-a3bf-c882d00b435a');
    });
  });

  describe('Headers de Notion', () => {
    it('debe validar headers correctos de Notion', async () => {
      // Mock headers incorretos
      mockRequest.headers.get.mockImplementation((header) => {
        const headers = {
          'user-agent': 'invalid-agent',
          'x-notion-signature': null,
        };
        return headers[header] || null;
      });
      
      mockRequest.json.mockResolvedValue(realPayloads.pageCreated);

      const response = await webhookHandler(mockRequest);

      expect(response.status).toBe(400);
      expect(response.data.error).toContain('no válido');
    });

    it('debe aceptar headers válidos de Notion', async () => {
      mockRequest.json.mockResolvedValue(realPayloads.verification);

      const response = await webhookHandler(mockRequest);

      expect(response.status).toBe(200);
    });
  });

  describe('Eventos no relevantes', () => {
    it('debe ignorar eventos que no son páginas', async () => {
      const nonPagePayload = {
        ...realPayloads.pageCreated,
        entity: { id: 'test-id', type: 'database' }
      };
      
      mockRequest.json.mockResolvedValue(nonPagePayload);

      const response = await webhookHandler(mockRequest);

      expect(response.status).toBe(200);
      expect(response.data.message).toContain('no es una página');
    });
  });

  describe('Manejo de errores', () => {
    it('debe manejar payload inválido', async () => {
      mockRequest.json.mockRejectedValue(new Error('Invalid JSON'));

      try {
        await webhookHandler(mockRequest);
      } catch (error) {
        expect(error.message).toContain('Invalid JSON');
      }
    });
  });

  describe('Secuencia de eventos reales', () => {
    it('debe manejar secuencia: content_updated -> page.created', async () => {
      // Simular el primer evento (content_updated)
      mockRequest.json.mockResolvedValueOnce(realPayloads.pageContentUpdated);
      const firstResponse = await webhookHandler(mockRequest);
      
      // Luego el segundo evento (page.created) - debe reprogramar el procesamiento
      mockRequest.json.mockResolvedValueOnce(realPayloads.pageCreated);
      const secondResponse = await webhookHandler(mockRequest);

      expect(firstResponse.status).toBe(200);
      expect(firstResponse.data.message).toContain('programado para procesamiento');
      expect(secondResponse.status).toBe(200);
      expect(secondResponse.data.message).toContain('programado para procesamiento');
    });
  });

  // Tests específicos para la nueva funcionalidad de actualización
  describe('Funcionalidad de actualización de tareas', () => {
    beforeEach(() => {
      webhookHandler.clearTasks(); // Limpiar tareas antes de cada test
    });

    it('debe procesar solo el último evento cuando se reciben múltiples eventos de la misma página', async () => {
      const pageId = 'test-page-123';

      // Simular múltiples eventos en rápida sucesión
      const events = [
        { ...realPayloads.pageCreated, entity: { id: pageId, type: 'page' }, type: 'page.created' },
        { ...realPayloads.pageUpdated, entity: { id: pageId, type: 'page' }, type: 'page.updated' },
        { ...realPayloads.pagePropertiesUpdated, entity: { id: pageId, type: 'page' }, type: 'page.properties_updated' }
      ];

      // Enviar todos los eventos
      const responses = [];
      for (const event of events) {
        mockRequest.json.mockResolvedValueOnce(event);
        const response = await webhookHandler(mockRequest);
        responses.push(response);
      }

      // Todos deberían devolver 200
      responses.forEach(response => {
        expect(response.status).toBe(200);
        expect(response.data.message).toContain('Evento programado para procesamiento');
      });

      // El último evento debería indicar actualización
      expect(responses[responses.length - 1].data.eventAction).toBe('update');

      // Esperar a que se procese el evento final
      await new Promise(resolve => setTimeout(resolve, 1200));

      // Verificar que se creó/actualizó la tarea
      const task = webhookHandler.getTaskByPageId(pageId);
      expect(task).toBeDefined();
      expect(task.description).toContain('page.properties_updated');
    });

    it('debe manejar correctamente eventos page.properties_updated', async () => {
      const pageId = realPayloads.pagePropertiesUpdated.entity.id;

      // Primero crear una tarea (simular que ya existe)
      mockRequest.json.mockResolvedValueOnce({
        ...realPayloads.pageCreated,
        entity: { id: pageId, type: 'page' },
        type: 'page.created'
      });
      const createResponse = await webhookHandler(mockRequest);
      
      expect(createResponse.status).toBe(200);
      await new Promise(resolve => setTimeout(resolve, 1200));

      // Verificar que se creó la tarea inicial
      let task = webhookHandler.getTaskByPageId(pageId);
      expect(task).toBeDefined();
      expect(task.updated).toBeUndefined();

      // Ahora enviar evento de properties_updated
      mockRequest.json.mockResolvedValueOnce(realPayloads.pagePropertiesUpdated);
      const updateResponse = await webhookHandler(mockRequest);
      
      expect(updateResponse.status).toBe(200);
      expect(updateResponse.data.eventAction).toBe('update');
      
      // Esperar a que se procese
      await new Promise(resolve => setTimeout(resolve, 1200));

      // Verificar que se actualizó la tarea existente
      task = webhookHandler.getTaskByPageId(pageId);
      expect(task).toBeDefined();
      expect(task.updated).toBe(true);
      expect(task.description).toContain('page.properties_updated');
    });

    it('debe crear nueva tarea cuando no se encuentra tarea existente para actualización', async () => {
      const pageId = 'non-existent-page';

      // Enviar evento de actualización para página sin tarea existente
      mockRequest.json.mockResolvedValueOnce({
        ...realPayloads.pagePropertiesUpdated,
        entity: { id: pageId, type: 'page' },
        type: 'page.properties_updated'
      });
      const response = await webhookHandler(mockRequest);
      
      expect(response.status).toBe(200);
      expect(response.data.eventAction).toBe('update');
      
      // Esperar a que se procese
      await new Promise(resolve => setTimeout(resolve, 1200));

      // Verificar que se creó nueva tarea (fallback)
      const task = webhookHandler.getTaskByPageId(pageId);
      expect(task).toBeDefined();
      expect(task.description).toContain('fallback');
    });

    it('debe distinguir correctamente entre eventos de creación y actualización', async () => {
      const createEvents = ['page.created'];
      const updateEvents = ['page.updated', 'page.content_updated', 'page.property_updated', 'page.properties_updated'];

      // Test eventos de creación
      for (const eventType of createEvents) {
        mockRequest.json.mockResolvedValueOnce({
          type: eventType,
          entity: { id: `page-${eventType}`, type: 'page' }
        });
        const response = await webhookHandler(mockRequest);
        expect(response.data.eventAction).toBe('create');
      }

      // Test eventos de actualización
      for (const eventType of updateEvents) {
        mockRequest.json.mockResolvedValueOnce({
          type: eventType,
          entity: { id: `page-${eventType}`, type: 'page' }
        });
        const response = await webhookHandler(mockRequest);
        expect(response.data.eventAction).toBe('update');
      }
    });

    it('debe ignorar eventos no relevantes', async () => {
      const irrelevantEvents = [
        { type: 'database.created', entity: { id: 'test-db', type: 'database' } },
        { type: 'database.updated', entity: { id: 'test-db', type: 'database' } },
        { type: 'page.deleted', entity: { id: 'test-page', type: 'page' } }
      ];
      
      for (const event of irrelevantEvents) {
        mockRequest.json.mockResolvedValueOnce(event);
        const response = await webhookHandler(mockRequest);
        
        expect(response.status).toBe(200);
        if (event.type === 'page.deleted') {
          expect(response.data.message).toContain('página eliminada');
        } else if (event.entity.type !== 'page') {
          expect(response.data.message).toContain('no es una página');
        } else {
          expect(response.data.message).toContain('no relevante');
        }
      }
    });

    it('debe manejar secuencia completa: crear -> actualizar -> actualizar propiedades', async () => {
      const pageId = 'full-lifecycle-page';

      // 1. Crear página
      mockRequest.json.mockResolvedValueOnce({
        type: 'page.created',
        entity: { id: pageId, type: 'page' }
      });
      const createResponse = await webhookHandler(mockRequest);
      expect(createResponse.data.eventAction).toBe('create');
      
      await new Promise(resolve => setTimeout(resolve, 1200));
      let task = webhookHandler.getTaskByPageId(pageId);
      expect(task).toBeDefined();
      expect(task.updated).toBeUndefined();

      // 2. Actualizar contenido
      mockRequest.json.mockResolvedValueOnce({
        type: 'page.content_updated',
        entity: { id: pageId, type: 'page' }
      });
      const updateResponse = await webhookHandler(mockRequest);
      expect(updateResponse.data.eventAction).toBe('update');
      
      await new Promise(resolve => setTimeout(resolve, 1200));
      task = webhookHandler.getTaskByPageId(pageId);
      expect(task.updated).toBe(true);
      expect(task.description).toContain('page.content_updated');

      // 3. Actualizar propiedades
      mockRequest.json.mockResolvedValueOnce({
        type: 'page.properties_updated',
        entity: { id: pageId, type: 'page' }
      });
      const propsResponse = await webhookHandler(mockRequest);
      expect(propsResponse.data.eventAction).toBe('update');
      
      await new Promise(resolve => setTimeout(resolve, 1200));
      task = webhookHandler.getTaskByPageId(pageId);
      expect(task.updated).toBe(true);
      expect(task.description).toContain('page.properties_updated');
    });

    it('debe completar tarea cuando el estado de Notion cambia a Listo', async () => {
      const pageId = 'completion-test-page';

      // 1. Crear página inicialmente
      mockRequest.json.mockResolvedValueOnce({
        type: 'page.created',
        entity: { id: pageId, type: 'page' }
      });
      const createResponse = await webhookHandler(mockRequest);
      expect(createResponse.status).toBe(200);
      
      await new Promise(resolve => setTimeout(resolve, 1200));
      const task = webhookHandler.getTaskByPageId(pageId);
      expect(task).toBeDefined();
      expect(task.completed).toBeUndefined();

      // 2. Simular actualización con estado "Listo"
      mockRequest.json.mockResolvedValueOnce({
        type: 'page.properties_updated',
        entity: { id: pageId, type: 'page' },
        data: {
          updated_properties: ['Status']
        }
      });

      const response = await webhookHandler(mockRequest);
      expect(response.status).toBe(200);
      expect(response.data.eventAction).toBe('update');
      
      // En un test real con el webhook real, verificaríamos que se completó la tarea
      // Para este mock, simplemente verificamos que el evento se procesó correctamente
    });
  });
});
</file>

<file path="src/components/FeaturedProject.tsx">
'use client'

import { motion, useAnimation } from 'framer-motion'
import Image from 'next/image'
import React, { useEffect } from 'react'
import { useInView } from 'react-intersection-observer'
import '@/styles/featuredproject.scss'
import { ContainerVariants } from '@/lib/animation'
import type { Project } from '@/types'

interface FeaturedProjectProps extends Project {
  index: number
}

const FeaturedProject: React.FC<FeaturedProjectProps> = ({
  name,
  description,
  tags,
  githubRepo,
  demo,
  img,
  index,
}) => {
  const [ref, inView] = useInView()
  const animation = useAnimation()

  useEffect(() => {
    if (inView) {
      animation.start('visible')
    } else {
      animation.start('hidden')
    }
  }, [inView, animation])

  const actualDirection = index % 2 === 0 ? 'left' : 'right'

  return (
    <motion.div
      className={`ftProject ${actualDirection}`}
      ref={ref}
      variants={ContainerVariants}
      initial="hidden"
      animate={animation}
    >
      <div className="ftProject-image">
        <a href={demo} target="_blank" rel="noopener noreferrer">
          <Image 
            src={`/images/${img}`} 
            alt={name}
            width={600}
            height={400}
            style={{ objectFit: 'cover' }}
          />
        </a>
      </div>
      <div className="ftProject-content">
        <h1>{name}</h1>
        <div className="desc">
          <p>{description}</p>
        </div>
        <ul className="tags">
          {tags.map((tag, tagIndex) => (
            <li key={tagIndex}>{tag}</li>
          ))}
        </ul>
        <div className="ftProject-links">
          {githubRepo && (
            <a href={githubRepo} target="_blank" rel="noopener noreferrer">
              <svg
                width="28"
                height="28"
                viewBox="0 0 25 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <g id="Github">
                  <path
                    d="M12.5516 0.454773C5.92157 0.454773 0.551575 5.82477 0.551575 12.4548C0.551575 17.7648 3.98657 22.2498 8.75657 23.8398C9.35657 23.9448 9.58157 23.5848 9.58157 23.2698C9.58157 22.9848 9.56658 22.0398 9.56658 21.0348C6.55157 21.5898 5.77157 20.2998 5.53157 19.6248C5.39657 19.2798 4.81157 18.2148 4.30157 17.9298C3.88157 17.7048 3.28157 17.1498 4.28657 17.1348C5.23157 17.1198 5.90657 18.0048 6.13157 18.3648C7.21157 20.1798 8.93657 19.6698 9.62657 19.3548C9.73157 18.5748 10.0466 18.0498 10.3916 17.7498C7.72157 17.4498 4.93157 16.4148 4.93157 11.8248C4.93157 10.5198 5.39657 9.43977 6.16157 8.59977C6.04157 8.29977 5.62157 7.06977 6.28157 5.41977C6.28157 5.41977 7.28657 5.10477 9.58157 6.64977C10.5416 6.37977 11.5616 6.24477 12.5816 6.24477C13.6016 6.24477 14.6216 6.37977 15.5816 6.64977C17.8766 5.08977 18.8816 5.41977 18.8816 5.41977C19.5416 7.06977 19.1216 8.29977 19.0016 8.59977C19.7666 9.43977 20.2316 10.5048 20.2316 11.8248C20.2316 16.4298 17.4266 17.4498 14.7566 17.7498C15.1916 18.1248 15.5666 18.8448 15.5666 19.9698C15.5666 21.5748 15.5516 22.8648 15.5516 23.2698C15.5516 23.5848 15.7766 23.9598 16.3766 23.8398C18.7588 23.0355 20.8288 21.5045 22.2952 19.4621C23.7617 17.4198 24.5509 14.9691 24.5516 12.4548C24.5516 5.82477 19.1816 0.454773 12.5516 0.454773Z"
                    fill="currentColor"
                  />
                </g>
              </svg>
            </a>
          )}
          {demo && (
            <a href={demo} target="_blank" rel="noopener noreferrer">
              <svg
                width="28"
                height="28"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M18 13V19C18 19.5304 17.7893 20.0391 17.4142 20.4142C17.0391 20.7893 16.5304 21 16 21H5C4.46957 21 3.96086 20.7893 3.58579 20.4142C3.21071 20.0391 3 19.5304 3 19V8C3 7.46957 3.21071 6.96086 3.58579 6.58579C3.96086 6.21071 4.46957 6 5 6H11"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
                <path
                  d="M15 3H21V9"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
                <path
                  d="M10 14L21 3"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
            </a>
          )}
        </div>
      </div>
    </motion.div>
  )
}

export default FeaturedProject
</file>

<file path="src/components/Hero.tsx">
'use client'

import React, { useEffect } from 'react'
import { motion } from 'framer-motion'
import Image from 'next/image'
import '@/styles/hero.scss'
import { ContainerVariants } from '@/lib/animation'
import strings from '@/data/aboutme.json'

const Hero: React.FC = () => {
  useEffect(() => {
    const hero = document.querySelector('.hero') as HTMLElement
    function handleResize() {
      if (hero) {
        // Height is handled by CSS
      }
    }
    setTimeout(() => {
      handleResize()
    }, 0)
    window.addEventListener('resize', handleResize)
    
    return () => {
      window.removeEventListener('resize', handleResize)
    }
  }, [])

  return (
    <section className="hero">
      <Image 
        className="hero-bg" 
        src="/images/wave-bg.svg" 
        alt="Sebarz Background" 
        fill
        style={{ objectFit: 'cover' }}
        priority
      />
      <motion.div
        className="hero-info"
        variants={ContainerVariants}
        initial="hidden"
        animate="visible"
      >
        <motion.p variants={ContainerVariants}>
          {strings.hero.greeting}
        </motion.p>
        <motion.h1 variants={ContainerVariants}>
          {strings.hero.name}
        </motion.h1>
        <motion.h2 
          variants={ContainerVariants} 
          dangerouslySetInnerHTML={{ __html: strings.hero.description }} 
        />
        <motion.a href="#featuredProjects">
          <motion.button variants={ContainerVariants}>
            {strings.hero.buttonText}
          </motion.button>
        </motion.a>
      </motion.div>
      <motion.div
        variants={ContainerVariants}
        initial="hidden"
        animate="visible"
      >
        <Image
          src="/images/hero.webp"
          id="hero-img"
          alt="Sebarz Profile Photo"
          width={500}
          height={600}
          priority
        />
      </motion.div>
    </section>
  )
}

export default Hero
</file>

<file path="src/components/Project.tsx">
'use client'

import { motion, useAnimation } from 'framer-motion'
import React, { useEffect } from 'react'
import { useInView } from 'react-intersection-observer'
import '@/styles/project.scss'
import { ContainerVariants } from '@/lib/animation'
import type { Project as ProjectType } from '@/types'

const Project: React.FC<ProjectType> = ({ name, description, tags, githubRepo, demo }) => {
  const [ref, inView] = useInView()
  const animation = useAnimation()

  useEffect(() => {
    if (inView) {
      animation.start('visible')
    } else {
      animation.start('hidden')
    }
  }, [inView, animation])

  return (
    <motion.div
      className="project"
      ref={ref}
      variants={ContainerVariants}
      initial="hidden"
      animate={animation}
    >
      <div className="project-header">
        <svg
          width="36"
          height="32"
          id="folder"
          viewBox="0 0 23 21"
          fill="#04a175"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M21.5928 17.8992V7.89919C21.5928 7.36875 21.3821 6.86004 21.007 6.48497C20.6319 6.1099 20.1232 5.89919 19.5928 5.89919H12.8288C12.4573 5.89917 12.0931 5.79569 11.7771 5.60034C11.4612 5.40499 11.2058 5.1255 11.0398 4.79319L10.1458 3.00519C9.97964 2.67272 9.72415 2.39312 9.40797 2.19776C9.0918 2.00241 8.72744 1.89901 8.35577 1.89919H3.59277C3.06234 1.89919 2.55363 2.1099 2.17856 2.48497C1.80349 2.86004 1.59277 3.36875 1.59277 3.89919V17.8992C1.59277 18.4296 1.80349 18.9383 2.17856 19.3134C2.55363 19.6885 3.06234 19.8992 3.59277 19.8992H19.5928C20.1232 19.8992 20.6319 19.6885 21.007 19.3134C21.3821 18.9383 21.5928 18.4296 21.5928 17.8992Z"
            stroke="black"
            strokeWidth="1.2"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
        </svg>
        <div className="project-links">
          {githubRepo && (
            <a href={githubRepo} target="_blank" rel="noopener noreferrer">
              <svg
                width="28"
                height="28"
                viewBox="0 0 25 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <g id="Github">
                  <path
                    d="M12.5516 0.454773C5.92157 0.454773 0.551575 5.82477 0.551575 12.4548C0.551575 17.7648 3.98657 22.2498 8.75657 23.8398C9.35657 23.9448 9.58157 23.5848 9.58157 23.2698C9.58157 22.9848 9.56658 22.0398 9.56658 21.0348C6.55157 21.5898 5.77157 20.2998 5.53157 19.6248C5.39657 19.2798 4.81157 18.2148 4.30157 17.9298C3.88157 17.7048 3.28157 17.1498 4.28657 17.1348C5.23157 17.1198 5.90657 18.0048 6.13157 18.3648C7.21157 20.1798 8.93657 19.6698 9.62657 19.3548C9.73157 18.5748 10.0466 18.0498 10.3916 17.7498C7.72157 17.4498 4.93157 16.4148 4.93157 11.8248C4.93157 10.5198 5.39657 9.43977 6.16157 8.59977C6.04157 8.29977 5.62157 7.06977 6.28157 5.41977C6.28157 5.41977 7.28657 5.10477 9.58157 6.64977C10.5416 6.37977 11.5616 6.24477 12.5816 6.24477C13.6016 6.24477 14.6216 6.37977 15.5816 6.64977C17.8766 5.08977 18.8816 5.41977 18.8816 5.41977C19.5416 7.06977 19.1216 8.29977 19.0016 8.59977C19.7666 9.43977 20.2316 10.5048 20.2316 11.8248C20.2316 16.4298 17.4266 17.4498 14.7566 17.7498C15.1916 18.1248 15.5666 18.8448 15.5666 19.9698C15.5666 21.5748 15.5516 22.8648 15.5516 23.2698C15.5516 23.5848 15.7766 23.9598 16.3766 23.8398C18.7588 23.0355 20.8288 21.5045 22.2952 19.4621C23.7617 17.4198 24.5509 14.9691 24.5516 12.4548C24.5516 5.82477 19.1816 0.454773 12.5516 0.454773Z"
                    fill="currentColor"
                  />
                </g>
              </svg>
            </a>
          )}
          {demo && (
            <a href={demo} target="_blank" rel="noopener noreferrer">
              <svg
                width="28"
                height="28"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M18 13V19C18 19.5304 17.7893 20.0391 17.4142 20.4142C17.0391 20.7893 16.5304 21 16 21H5C4.46957 21 3.96086 20.7893 3.58579 20.4142C3.21071 20.0391 3 19.5304 3 19V8C3 7.46957 3.21071 6.96086 3.58579 6.58579C3.96086 6.21071 4.46957 6 5 6H11"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
                <path
                  d="M15 3H21V9"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
                <path
                  d="M10 14L21 3"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              </svg>
            </a>
          )}
        </div>
      </div>
      <h3 className="project-title">{name}</h3>
      <p className="project-description">{description}</p>
      <ul className="project-tags">
        {tags.map((tag, index) => (
          <li key={index}>{tag}</li>
        ))}
      </ul>
    </motion.div>
  )
}

export default Project
</file>

<file path="src/services/webhooks/notion-todoist.service.ts">
/**
 * Servicio para la integración Notion-Todoist
 */

import { ProcessingResult, TodoistCreateTaskResponse } from '@/types/notion-todoist';
import { logger } from '@/lib/logger';
import { config } from '@/lib/config';
import { getNotionPageContent, getNotionPageStatus } from '@/utils/notion-client';
import { 
  createTodoistTask, 
  updateTodoistTask, 
  findTaskByNotionUrl, 
  formatDateForTodoist, 
  completeTodoistTask,
  deleteTodoistTask,
  findOrCreateProjectByWorkspace
} from '@/utils/todoist-client';
import { enhanceTaskWithAI } from '@/utils/openai-client';
import { createWorkspaceTag, combineTagsWithWorkspace } from '@/utils/tag-helpers';

export class NotionTodoistService {
  
  /**
   * Maneja la eliminación de una tarea cuando se quita la mención del usuario
   */
  async handleMentionRemoval(pageId: string): Promise<{
    taskDeleted: boolean;
    taskId?: string;
    error?: string;
  }> {
    try {
      logger.info('Checking for existing Todoist task to delete', { pageId });
      
      // Buscar tarea existente en Todoist (sin filtrar por proyecto específico)
      const existingTask = await findTaskByNotionUrl(pageId);
      
      if (!existingTask) {
        logger.info('No existing task found for mention removal', { pageId });
        return { taskDeleted: false };
      }
      
      logger.info('Found existing task, proceeding with deletion', { 
        pageId,
        taskId: existingTask.id 
      });
      
      // Eliminar la tarea de Todoist
      await deleteTodoistTask(existingTask.id);
      
      logger.info('Task successfully deleted from Todoist due to mention removal', { 
        pageId,
        taskId: existingTask.id 
      });
      
      return { 
        taskDeleted: true, 
        taskId: existingTask.id 
      };
    } catch (error) {
      logger.error('Error handling mention removal', error as Error, { pageId });
      return {
        taskDeleted: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Procesa una página de Notion y crea/actualiza tarea en Todoist
   */
  async processPage(
    pageId: string, 
    workspaceName?: string, 
    action: 'create' | 'update' = 'create'
  ): Promise<ProcessingResult> {
    try {
      logger.info(`${action === 'update' ? 'Updating' : 'Creating'} task for page`, { 
        pageId, 
        action, 
        workspaceName 
      });
      
      // Si es una actualización, buscar tarea existente
      if (action === 'update') {
        // Buscar en todos los proyectos, no solo en el configurado
        const existingTask = await findTaskByNotionUrl(pageId);
        if (existingTask) {
          logger.info('Existing task found', { taskId: existingTask.id, pageId });
          return await this.updateExistingTask(existingTask, pageId, workspaceName);
        } else {
          logger.info('No existing task found, creating new task', { pageId });
          // Si no encuentra la tarea existente, crear una nueva
          action = 'create';
        }
      }

      // Crear nueva tarea
      return await this.createNewTask(pageId, workspaceName);
    } catch (error) {
      logger.error('Error processing Notion page', error as Error, { pageId, action });
      return {
        success: false,
        notionPageId: pageId,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Crea una nueva tarea en Todoist
   */
  private async createNewTask(
    pageId: string, 
    workspaceName?: string
  ): Promise<ProcessingResult> {
    logger.info('Getting Notion page content', { pageId });
    const pageContent = await getNotionPageContent(pageId, workspaceName);

    let finalContent = pageContent;
    let enhancedWithAI = false;

    // Enriquecer con IA si está habilitado
    if (config.openai.enabled && config.openai.apiKey) {
      try {
        logger.info('Enhancing task with AI');
        const aiEnhancement = await enhanceTaskWithAI(pageContent);
        
        finalContent = {
          ...pageContent,
          title: pageContent.title, // Mantener título original, sin AI enhancement
          content: aiEnhancement.enhancedDescription,
          priority: aiEnhancement.suggestedPriority,
          tags: aiEnhancement.suggestedLabels,
          dueDate: aiEnhancement.suggestedDueDate || pageContent.dueDate,
        };
        
        enhancedWithAI = true;
        logger.info('Task enhanced with AI successfully (keeping original title)');
      } catch (aiError) {
        logger.warn('Error enhancing with AI, continuing without improvements', { 
          error: aiError 
        });
      }
    }

    logger.info('Creating task in Todoist');
    
    const { allTags, workspaceTag } = this.prepareTags(finalContent.tags, workspaceName);
    
    logger.info('Tags prepared for task', { 
      tags: allTags, 
      workspace: workspaceTag || 'none' 
    });
    
    // Determinar el proyecto de destino
    let projectId = config.todoist.projectId; // Fallback al proyecto por defecto
    
    if (workspaceName) {
      try {
        logger.info('Finding or creating project for workspace', { workspaceName });
        projectId = await findOrCreateProjectByWorkspace(workspaceName);
        logger.info('Using project for workspace', { 
          workspaceName, 
          projectId,
          isDefault: projectId === config.todoist.projectId 
        });
      } catch (error) {
        logger.warn('Failed to create workspace project, using default', { 
          workspaceName, 
          error: error instanceof Error ? error.message : 'Unknown error',
          fallbackProjectId: config.todoist.projectId 
        });
      }
    }
    
    const todoistTask = {
      content: finalContent.title,
      description: this.createTaskDescription(finalContent, workspaceName),
      project_id: projectId,
      priority: finalContent.priority || 2,
      labels: allTags,
      ...(finalContent.dueDate && {
        due_date: formatDateForTodoist(finalContent.dueDate),
      }),
    };

    const todoistResponse = await createTodoistTask(todoistTask);
    
    logger.info('Task created successfully in Todoist', { 
      taskId: todoistResponse.id,
      pageId 
    });

    return {
      success: true,
      todoistTaskId: todoistResponse.id,
      notionPageId: pageId,
      enhancedWithAI,
    };
  }

  /**
   * Actualiza una tarea existente en Todoist
   */
  private async updateExistingTask(
    existingTask: TodoistCreateTaskResponse, 
    pageId: string, 
    workspaceName?: string
  ): Promise<ProcessingResult> {
    logger.info('Getting updated Notion page content', { pageId });
    const pageContent = await getNotionPageContent(pageId, workspaceName);
    
    // Verificar el estado de la página
    logger.info('Checking page status');
    const pageStatus = await getNotionPageStatus(pageId, workspaceName);
    logger.info('Page status retrieved', { status: pageStatus });
    
    // Si el estado indica completado, completar la tarea en Todoist
    const completedStatuses = ['Listo', 'Done', 'Completed', 'Completado', 'Terminado', 'Finished'];
    if (pageStatus && completedStatuses.includes(pageStatus)) {
      return await this.completeTask(existingTask, pageId, pageStatus, pageContent, workspaceName);
    }

    // Actualizar tarea normal
    return await this.updateTaskContent(existingTask, pageId, pageContent, workspaceName);
  }

  /**
   * Completa una tarea en Todoist
   */
  private async completeTask(
    existingTask: TodoistCreateTaskResponse,
    pageId: string,
    pageStatus: string,
    pageContent: { title: string },
    workspaceName?: string
  ): Promise<ProcessingResult> {
    logger.info(`Page marked as "${pageStatus}" - completing task in Todoist`, {
      pageId,
      taskId: existingTask.id,
      status: pageStatus
    });
    
    try {
      await completeTodoistTask(existingTask.id);
      logger.info('Task completed successfully in Todoist', { 
        taskId: existingTask.id 
      });
      
      return {
        success: true,
        action: 'completed',
        taskId: existingTask.id,
        title: pageContent.title,
        message: `Task marked as completed in Todoist (status: ${pageStatus})`
      };
    } catch (error) {
      logger.error('Error completing task in Todoist', error as Error, {
        taskId: existingTask.id,
        pageId
      });
      // Continuar con actualización normal si no se puede completar
      const fullPageContent = await getNotionPageContent(pageId, workspaceName);
      return await this.updateTaskContent(existingTask, pageId, fullPageContent, workspaceName);
    }
  }

  /**
   * Actualiza el contenido de una tarea
   */
  private async updateTaskContent(
    existingTask: TodoistCreateTaskResponse,
    pageId: string,
    pageContent: { title: string; content: string; url: string; tags?: string[]; priority?: number; dueDate?: string },
    workspaceName?: string
  ): Promise<ProcessingResult> {
    let finalContent = pageContent;
    let enhancedWithAI = false;

    // Enriquecer con IA si está habilitado
    if (config.openai.enabled && config.openai.apiKey) {
      try {
        logger.info('Enhancing task update with AI');
        const aiEnhancement = await enhanceTaskWithAI(pageContent);
        
        finalContent = {
          ...pageContent,
          title: pageContent.title, // Mantener título original, sin AI enhancement
          content: aiEnhancement.enhancedDescription,
          priority: aiEnhancement.suggestedPriority,
          tags: aiEnhancement.suggestedLabels,
          dueDate: aiEnhancement.suggestedDueDate || pageContent.dueDate,
        };
        
        enhancedWithAI = true;
        logger.info('Task update enhanced with AI successfully (keeping original title)');
      } catch (aiError) {
        logger.warn('Error enhancing update with AI, continuing without improvements', {
          error: aiError
        });
      }
    }

    logger.info('Updating task in Todoist');
    
    const { allTags } = this.prepareTags(finalContent.tags, workspaceName);
    
    logger.info('Tags updated for task', { 
      tags: allTags,
      workspace: workspaceName || 'none'
    });
    
    const updates = {
      content: finalContent.title,
      description: this.createTaskDescription(finalContent, workspaceName),
      priority: finalContent.priority || 2,
      labels: allTags,
      ...(finalContent.dueDate && {
        due_date: formatDateForTodoist(finalContent.dueDate),
      }),
    };

    await updateTodoistTask(existingTask.id, updates);
    
    logger.info('Task updated successfully in Todoist', { 
      taskId: existingTask.id 
    });

    return {
      success: true,
      todoistTaskId: existingTask.id,
      notionPageId: pageId,
      enhancedWithAI,
    };
  }

  /**
   * Prepara las tags para la tarea
   */
  private prepareTags(
    contentTags: string[] | undefined, 
    workspaceName?: string
  ): { allTags: string[]; workspaceTag: string } {
    const baseTags = contentTags || ['notion'];
    const workspaceTag = workspaceName ? createWorkspaceTag(workspaceName) : '';
    const allTags = workspaceTag 
      ? combineTagsWithWorkspace(baseTags, workspaceTag)
      : baseTags;
    
    return { allTags, workspaceTag };
  }

  /**
   * Crea la descripción de la tarea
   */
  private createTaskDescription(content: { content: string; url: string }, workspaceName?: string): string {
    const baseDescription = `${content.content}\n\n🔗 Ver en Notion: ${content.url}`;
    return workspaceName 
      ? `${baseDescription}\n📁 Workspace: ${workspaceName}`
      : baseDescription;
  }
}
</file>

<file path=".env.example">
# Configuración para Notion-Todoist Integration

# Token de acceso de Notion (obligatorio)
# Ve a https://www.notion.so/my-integrations para crear un token
NOTION_TOKEN=secret_xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
NOTION_TOKEN_[YOUR_WORKSPACE_NAME]=your_new_integration_token

# Token de verificación de webhooks de Notion (opcional pero recomendado)
# Se obtiene durante la verificación inicial del webhook
NOTION_VERIFICATION_TOKEN=secret_tMrlL1qK5vuQAh1b6cZGhFChZTSYJlce98V0pYn7yBl

# Secret para validar firmas de webhooks de Notion (recomendado para producción)
# Este es el webhook secret que configuras en Notion para firmar las requests
NOTION_WEBHOOK_SECRET=your_webhook_secret_here

# Token de API de Todoist (obligatorio)
# Ve a https://todoist.com/prefs/integrations para obtener tu token
TODOIST_API_TOKEN=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

# Configuración de webhooks de Todoist (para sincronización inversa)
# Secret para validar webhooks de Todoist (recomendado para producción)
TODOIST_WEBHOOK_SECRET=your_todoist_webhook_secret_here

# Client ID de tu app de Todoist (para configurar webhooks)
TODOIST_CLIENT_ID=5a8fa2b5dcde4451b9285b33498251f8

# Client Secret de tu app de Todoist (para configurar webhooks)
TODOIST_CLIENT_SECRET=0baf8fd9fc794ec683b3a3d664829fac

TODOIST_VERIFICATION_TOKEN=tu_token_de_verificacion

# ID de tu usuario en Notion (opcional)
# Si se configura, solo se crearán tareas cuando seas mencionado
# Para obtenerlo, puedes usar la API de Notion o dejarlo vacío para procesar todas las páginas
NOTION_USER_ID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx

# ID del proyecto de Todoist donde se crearán las tareas (opcional)
# NUEVO: Ahora se crean proyectos dinámicamente por workspace de Notion
# Este ID se usa como fallback cuando falla la creación automática de proyectos
TODOIST_PROJECT_ID=2xxxxxxxxx

# Clave de API de OpenAI (opcional)
# Si se configura, las tareas se enriquecerán con IA
OPENAI_API_KEY=sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

# Habilitar enriquecimiento con IA (opcional, por defecto false)
ENABLE_AI_ENHANCEMENT=true

# URL de tu aplicación para webhooks (se usa en scripts de prueba)
# En desarrollo: http://localhost:3000
# En producción: https://tu-dominio.vercel.app
APP_URL=http://localhost:3000
</file>

<file path="src/styles/globals.scss">
@use "./colors.scss";
@import url("https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700;900&display=swap");

:root {
  --font-recoleta: 'Recoleta', 'Roboto', sans-serif;
  --font-roboto: 'Roboto', sans-serif;
  
  --spacing-xs: 0.5em;
  --spacing-sm: 1em;
  --spacing-md: 2em;
  --spacing-lg: 3em;
  --spacing-xl: 4em;
  --spacing-xxl: 6em;
  
  --transition-fast: all 0.2s ease;
  --transition-normal: all 0.3s ease;
  --transition-slow: all 0.5s ease;
  
  --font-size-sm: 0.875rem;
  --font-size-base: 1rem;
  --font-size-lg: 1.125rem;
  --font-size-xl: 1.5rem;
  --font-size-2xl: 2rem;
  --font-size-3xl: 3rem;
  
  --radius-sm: 5px;
  --radius-md: 10px;
  --radius-lg: 15px;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html {
  overflow-x: hidden;
  scroll-behavior: smooth;
}

body {
  overflow-x: hidden;
  background-color: colors.$mint;
  font-family: var(--font-recoleta);
  font-weight: 300;
  line-height: 1.6;
}

::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: colors.$mint;
}

::-webkit-scrollbar-thumb {
  background: colors.$green;
  border-radius: 1px;
}

::-webkit-scrollbar-thumb:hover {
  background: colors.$black;
}

main {
  margin: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 0 var(--spacing-md);
}

h1 {
  font-size: var(--font-size-2xl);
  font-weight: 700;
  font-family: var(--font-recoleta);
  color: colors.$black;
}

h2 {
  font-size: var(--font-size-xl);
  font-weight: 600;
  font-family: var(--font-recoleta);
  color: colors.$black;
}

h3 {
  font-size: var(--font-size-lg);
  font-weight: 500;
  font-family: var(--font-recoleta);
  color: colors.$black;
}

p {
  font-size: var(--font-size-base);
  font-family: var(--font-roboto);
  color: colors.$black;
}

a {
  text-decoration: none;
  color: inherit;
  transition: var(--transition-normal);
  
  &:hover {
    color: colors.$green;
  }
}

button {
  cursor: pointer;
  border: none;
  outline: none;
  transition: var(--transition-normal);
  font-family: var(--font-roboto);
  
  &:focus-visible {
    outline: 2px solid colors.$green;
    outline-offset: 2px;
  }
}

section {
  margin: var(--spacing-xl) 0;
}

section.contact {
  margin: var(--spacing-xxl) 0;
}

.title {
  border-bottom: colors.$green 2px dotted;
  font-size: var(--font-size-3xl);
  font-weight: 700;
  font-family: var(--font-recoleta);
  color: colors.$black;
}

.tags {
  li {
    border-bottom: colors.$green 2px dotted;
  }
}

.mywork-container,
.featuredProjects-container,
.aboutme-container {
  overflow: visible;
}

.mywork {
  overflow: visible;
}

ul, ol {
  overflow: visible;
}

.project {
  overflow: visible;
}

.project-links,
.ftProject-links {
  a {
    svg:hover {
      path {
        fill: colors.$green;
      }
    }
  }
}

svg {
  path {
    fill: colors.$green;
  }
}

@media screen and (max-width: 900px) {
  .floating-social,
  .floating-mail {
    display: none;
  }
  
  main {
    padding: 0 var(--spacing-sm);
  }
  
  .title {
    font-size: 2.5rem;
  }
}

@media screen and (max-width: 600px) {
  .title {
    font-size: 2rem;
  }
}
</file>

<file path="src/utils/todoist-client.ts">
import axios from 'axios';
import { TodoistTask, TodoistCreateTaskResponse } from '@/types/notion-todoist';

const TODOIST_API_URL = 'https://api.todoist.com/rest/v2';

export async function createTodoistTask(task: TodoistTask): Promise<TodoistCreateTaskResponse> {
  try {
    const response = await axios.post<TodoistCreateTaskResponse>(
      `${TODOIST_API_URL}/tasks`,
      task,
      {
        headers: {
          'Authorization': `Bearer ${process.env.TODOIST_API_TOKEN}`,
          'Content-Type': 'application/json',
        },
      }
    );

    return response.data;
  } catch (error) {
    if (axios.isAxiosError(error)) {
      throw new Error(`Error de Todoist: ${error.response?.status} - ${error.response?.data}`);
    }
    throw new Error('Error desconocido al crear tarea en Todoist');
  }
}

export async function updateTodoistTask(taskId: string, updates: Partial<TodoistTask>): Promise<void> {
  try {
    await axios.post(
      `${TODOIST_API_URL}/tasks/${taskId}`,
      updates,
      {
        headers: {
          'Authorization': `Bearer ${process.env.TODOIST_API_TOKEN}`,
          'Content-Type': 'application/json',
        },
      }
    );
  } catch (error) {
    if (axios.isAxiosError(error)) {
      throw new Error(`Error actualizando tarea en Todoist: ${error.response?.status} - ${error.response?.data}`);
    }
    throw new Error('Error desconocido al actualizar tarea en Todoist');
  }
}

export async function completeTodoistTask(taskId: string): Promise<void> {
  try {
    await axios.post(
      `${TODOIST_API_URL}/tasks/${taskId}/close`,
      {},
      {
        headers: {
          'Authorization': `Bearer ${process.env.TODOIST_API_TOKEN}`,
          'Content-Type': 'application/json',
        },
      }
    );
  } catch (error) {
    if (axios.isAxiosError(error)) {
      throw new Error(`Error completando tarea en Todoist: ${error.response?.status} - ${error.response?.data}`);
    }
    throw new Error('Error desconocido al completar tarea en Todoist');
  }
}

export async function deleteTodoistTask(taskId: string): Promise<void> {
  try {
    await axios.delete(
      `${TODOIST_API_URL}/tasks/${taskId}`,
      {
        headers: {
          'Authorization': `Bearer ${process.env.TODOIST_API_TOKEN}`,
        },
      }
    );
  } catch (error) {
    if (axios.isAxiosError(error)) {
      throw new Error(`Error eliminando tarea en Todoist: ${error.response?.status} - ${error.response?.data}`);
    }
    throw new Error('Error desconocido al eliminar tarea en Todoist');
  }
}

export async function findTaskByNotionUrl(notionPageId: string, projectId?: string): Promise<TodoistCreateTaskResponse | null> {
  try {
    const params: Record<string, string> = {};
    if (projectId) {
      params.project_id = projectId;
    }

    const response = await axios.get<TodoistCreateTaskResponse[]>(
      `${TODOIST_API_URL}/tasks`,
      {
        headers: {
          'Authorization': `Bearer ${process.env.TODOIST_API_TOKEN}`,
        },
        params,
      }
    );

    // Buscar tarea que contenga el pageId de Notion en la descripción
    // Buscar el ID de página de Notion sin guiones (formato limpio) y con guiones
    const cleanPageId = notionPageId.replace(/-/g, '');
    
    const task = response.data.find(task => {
      if (!task.description) return false;
      
      // Buscar en múltiples formatos:
      // 1. URL completa con notion.so
      // 2. URL completa con www.notion.so  
      // 3. Solo el pageId con guiones
      // 4. Solo el pageId sin guiones (clean)
      return task.description.includes(`notion.so/${notionPageId}`) ||
             task.description.includes(`www.notion.so/${notionPageId}`) ||
             task.description.includes(`notion.so/${cleanPageId}`) ||
             task.description.includes(`www.notion.so/${cleanPageId}`) ||
             task.description.includes(notionPageId) ||
             task.description.includes(cleanPageId);
    });

    return task || null;
  } catch (error) {
    console.error('Error buscando tarea en Todoist:', error);
    return null;
  }
}

export async function getProjects(): Promise<Array<{ id: string; name: string }>> {
  try {
    const response = await axios.get(`${TODOIST_API_URL}/projects`, {
      headers: {
        'Authorization': `Bearer ${process.env.TODOIST_API_TOKEN}`,
      },
    });

    return response.data.map((project: { id: string; name: string }) => ({
      id: project.id,
      name: project.name,
    }));
  } catch (_error) {
    return [];
  }
}

/**
 * Encuentra o crea un proyecto de Todoist basado en el nombre del workspace
 */
export async function findOrCreateProjectByWorkspace(workspaceName: string): Promise<string> {
  try {
    // Usar el nombre del workspace directamente como nombre de proyecto
    
    // Buscar proyecto existente
    const projects = await getProjects();
    const existingProject = projects.find(project => 
      project.name.toLowerCase() === workspaceName.toLowerCase()
    );
    
    if (existingProject) {
      return existingProject.id;
    }
    
    // Crear nuevo proyecto si no existe
    const newProject = await createTodoistProject(workspaceName);
    return newProject.id;
  } catch (error) {
    console.warn('Error managing Todoist project, falling back to default:', error);
    // Si hay error, usar el proyecto por defecto si está configurado
    return process.env.TODOIST_PROJECT_ID || '';
  }
}

/**
 * Crea un nuevo proyecto en Todoist
 */
export async function createTodoistProject(name: string): Promise<{ id: string; name: string }> {
  try {
    const response = await axios.post(
      `${TODOIST_API_URL}/projects`,
      { name },
      {
        headers: {
          'Authorization': `Bearer ${process.env.TODOIST_API_TOKEN}`,
          'Content-Type': 'application/json',
        },
      }
    );

    return {
      id: response.data.id,
      name: response.data.name,
    };
  } catch (error) {
    if (axios.isAxiosError(error)) {
      throw new Error(`Error creando proyecto en Todoist: ${error.response?.status} - ${error.response?.data}`);
    }
    throw new Error('Error desconocido al crear proyecto en Todoist');
  }
}

export function formatDateForTodoist(date: string): string {
  // Convierte fecha ISO a formato que entiende Todoist
  const dateObj = new Date(date);
  return dateObj.toISOString().split('T')[0]; // YYYY-MM-DD
}
</file>

<file path=".gitignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Build outputs
.next/
out/
dist/
build/

# Production builds
*.tgz
*.tar.gz

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE files
.vscode/
.idea/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
*.csv

# Logs
logs/
*.log
webhook-logs/

# Coverage directory
coverage/
*.lcov

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# TypeScript
*.tsbuildinfo
next-env.d.ts

# Vercel
.vercel

# Backup files
*.backup
</file>

<file path="src/styles/project.scss">
@use './colors.scss';
@use './mixins.scss';

.project {
  height: 100%;
  @include mixins.flex-container(column, nowrap, 1.5em);
  @include mixins.no-scroll;
  width: 100%;
  min-height: 350px;
  max-width: 100%;
  border: 1.8px dotted colors.$green;
  background-color: colors.$mint;
  padding: 1.5em;
  justify-content: space-between;
  @include mixins.smooth-transition(all, 0.33s);
  border-radius: 5px;
  .project-header {
    display: flex;
    width: 100%;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 1em;
    
    #folder {
      path {
        fill: colors.$green;
      }
    }
    
    .project-links {
      display: flex;
      gap: 0.8em;
      
      a {
        color: colors.$green;
        @include mixins.smooth-transition(all, 0.3s);
        
        &:hover {
          color: colors.$black;
          transform: translateY(-2px);
        }
        
        svg {
          width: 28px;
          height: 28px;
        }
      }
    }
  }

  .project-title {
    font-size: 1.25em;
    font-weight: bold;
    color: colors.$green;
    margin-bottom: 0.8em;
    line-height: 1.3;
  }
  
  .project-description {
    font-size: 0.95em;
    color: colors.$pepper;
    margin-bottom: 1.2em;
    line-height: 1.5;
    flex-grow: 1;
  }

  .project-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.6em;
    margin-top: auto;
    list-style: none;
    
    li {
      background-color: rgba(4, 161, 117, 0.1);
      color: colors.$green;
      font-size: 0.8em;
      font-weight: 500;
      padding: 0.4em 0.8em;
      border-radius: 12px;
      border: 1px solid rgba(4, 161, 117, 0.2);
      white-space: nowrap;
      @include mixins.smooth-transition(all, 0.2s);
      
      &:hover {
        background-color: rgba(4, 161, 117, 0.15);
        border-color: rgba(4, 161, 117, 0.4);
        transform: translateY(-1px);
      }
    }
  }
}

.project:hover {
  transform: translateY(-5px);
  box-shadow: 0 8px 25px rgba(0, 71, 71, 0.15);
  
  h3 {
    color: colors.$green;
  }
}
</file>

<file path="src/utils/notion-client.ts">
import { Client } from '@notionhq/client';
import { NotionPageContent } from '@/types/notion-todoist';
import { logger } from '@/lib/logger';

// Interfaces para tipos de Notion
interface NotionRichText {
  type: string;
  mention?: {
    type: string;
    user: {
      id: string;
    };
  };
}

interface _NotionPeopleProperty {
  type: 'people';
  people: Array<{ id: string; type: string }>;
}

interface _NotionRichTextProperty {
  type: 'rich_text';
  rich_text: NotionRichText[];
}

interface _NotionTitleProperty {
  type: 'title';
  title: NotionRichText[];
}

// Multiple workspace support
const getNotionClient = (workspaceName?: string): Client => {
  // If workspace name is provided, try to get workspace-specific token
  if (workspaceName) {
    const workspaceTokenKey = `NOTION_TOKEN_${workspaceName.toUpperCase().replace(/[\s-]/g, '_')}`;
    const workspaceToken = process.env[workspaceTokenKey];
    
    if (workspaceToken) {
      logger.info(`Using workspace-specific token for ${workspaceName}`, { workspaceTokenKey });
      return new Client({ auth: workspaceToken });
    } else {
      logger.warn(`No workspace-specific token found for ${workspaceName}, using default`, { 
        workspaceTokenKey,
        workspaceName 
      });
    }
  }
  
  // Fallback to default token
  return new Client({
    auth: process.env.NOTION_TOKEN,
  });
};

// Keep original client for backward compatibility (commented out since not used)
// const notion = getNotionClient();

export async function getNotionPageContent(pageId: string, workspaceName?: string): Promise<NotionPageContent> {
  try {
    // Get workspace-specific client
    const notionClient = getNotionClient(workspaceName);
    
    // Obtener información de la página
    const page = await notionClient.pages.retrieve({ page_id: pageId });
    
    // Obtener el contenido de la página
    const blocks = await notionClient.blocks.children.list({
      block_id: pageId,
    });

    // Extraer título y contenido
    let title = 'Nueva tarea desde Notion';
    let content = '';
    let priority = 1;
    let dueDate: string | undefined;
    let assignee: string | undefined;
    let tags: string[] = [];

    // Extraer propiedades de la página

    // Procesar propiedades de la página
    if ('properties' in page && page.properties) {
      // Extraer título (puede estar en diferentes propiedades dependiendo de la configuración)
      const titleProperty = Object.values(page.properties).find(
        (prop) => prop.type === 'title'
      );
      
      if (titleProperty && titleProperty.type === 'title' && titleProperty.title[0]) {
        title = titleProperty.title[0].plain_text;
      }

      // Extraer otras propiedades relevantes
      Object.entries(page.properties).forEach(([key, property]) => {
        if (property.type === 'select' && property.select?.name) {
          if (key.toLowerCase().includes('priority') || key.toLowerCase().includes('prioridad')) {
            const priorityValue = property.select.name.toLowerCase();
            if (priorityValue.includes('high') || priorityValue.includes('alta')) priority = 4;
            else if (priorityValue.includes('medium') || priorityValue.includes('media')) priority = 3;
            else if (priorityValue.includes('low') || priorityValue.includes('baja')) priority = 2;
          }
        }

        if (property.type === 'date' && property.date?.start) {
          dueDate = property.date.start;
        }

        if (property.type === 'people' && property.people.length > 0) {
          const user = property.people[0];
          if ('name' in user && user.name) {
            assignee = user.name;
          } else {
            assignee = user.id;
          }
        }

        if (property.type === 'multi_select' && property.multi_select.length > 0) {
          tags = property.multi_select.map(tag => tag.name);
        }
      });
    }

    // Procesar contenido de bloques
    if (blocks.results.length > 0) {
      content = blocks.results
        .map((block) => {
          if ('type' in block) {
            switch (block.type) {
              case 'paragraph':
                return block.paragraph.rich_text
                  .map((text) => text.plain_text)
                  .join('');
              case 'heading_1':
                return `# ${block.heading_1.rich_text
                  .map((text) => text.plain_text)
                  .join('')}`;
              case 'heading_2':
                return `## ${block.heading_2.rich_text
                  .map((text) => text.plain_text)
                  .join('')}`;
              case 'heading_3':
                return `### ${block.heading_3.rich_text
                  .map((text) => text.plain_text)
                  .join('')}`;
              case 'bulleted_list_item':
                return `• ${block.bulleted_list_item.rich_text
                  .map((text) => text.plain_text)
                  .join('')}`;
              case 'numbered_list_item':
                return `1. ${block.numbered_list_item.rich_text
                  .map((text) => text.plain_text)
                  .join('')}`;
              case 'to_do':
                const checked = block.to_do.checked ? '✅' : '☐';
                return `${checked} ${block.to_do.rich_text
                  .map((text) => text.plain_text)
                  .join('')}`;
              default:
                return '';
            }
          }
          return '';
        })
        .filter(text => text.length > 0)
        .join('\n');
    }

    return {
      title,
      content: content || 'Contenido extraído desde Notion',
      url: 'url' in page ? page.url : `https://notion.so/${pageId}`,
      priority,
      dueDate,
      assignee,
      tags,
    };
  } catch (_error) {
    throw new Error('No se pudo obtener el contenido de la página de Notion');
  }
}

export async function isUserMentioned(pageId: string, userId: string, workspaceName?: string): Promise<boolean> {
  try {
    // Get workspace-specific client
    const notionClient = getNotionClient(workspaceName);
    
    // 1. Verificar menciones en las propiedades de la página
    const page = await notionClient.pages.retrieve({ page_id: pageId });
    
    if ('properties' in page && page.properties) {
      // Buscar menciones en las propiedades de la página
      const hasMentionInProperties = Object.values(page.properties).some((property) => {
        // Verificar propiedades de tipo "people"
        if (property.type === 'people' && property.people.length > 0) {
          return property.people.some(person => person.id === userId);
        }
        
        // Verificar propiedades de texto rico que pueden contener menciones
        if (property.type === 'rich_text' && property.rich_text.length > 0) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return property.rich_text.some((text: any) => {
            if (text.type === 'mention' && text.mention?.type === 'user' && text.mention?.user?.id) {
              return text.mention.user.id === userId;
            }
            return false;
          });
        }
        
        // Verificar propiedades de título que pueden contener menciones
        if (property.type === 'title' && property.title.length > 0) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return property.title.some((text: any) => {
            if (text.type === 'mention' && text.mention?.type === 'user' && text.mention?.user?.id) {
              return text.mention.user.id === userId;
            }
            return false;
          });
        }
        
        return false;
      });
      
      if (hasMentionInProperties) {
        return true;
      }
    }

    // 2. Verificar menciones en el contenido de bloques (método original)
    const blocks = await notionClient.blocks.children.list({
      block_id: pageId,
    });

    const hasMentionInContent = blocks.results.some((block) => {
      if ('type' in block) {
        const checkRichText = (richTextArray: unknown[]) => {
          return richTextArray.some((text: unknown) => {
            if (typeof text === 'object' && text !== null && 'type' in text && 'mention' in text) {
              const textObj = text as { type: string; mention: { type: string; user: { id: string } } };
              if (textObj.type === 'mention' && textObj.mention.type === 'user') {
                return textObj.mention.user.id === userId;
              }
            }
            return false;
          });
        };

        switch (block.type) {
          case 'paragraph':
            return checkRichText(block.paragraph.rich_text);
          case 'heading_1':
            return checkRichText(block.heading_1.rich_text);
          case 'heading_2':
            return checkRichText(block.heading_2.rich_text);
          case 'heading_3':
            return checkRichText(block.heading_3.rich_text);
          case 'bulleted_list_item':
            return checkRichText(block.bulleted_list_item.rich_text);
          case 'numbered_list_item':
            return checkRichText(block.numbered_list_item.rich_text);
          case 'to_do':
            return checkRichText(block.to_do.rich_text);
          default:
            return false;
        }
      }
      return false;
    });

    if (hasMentionInContent) {
      return true;
    }

    return false;
  } catch (_error) {
    return false;
  }
}

export async function getNotionPageStatus(pageId: string, workspaceName?: string): Promise<string | null> {
  try {
    const notionClient = getNotionClient(workspaceName);
    const page = await notionClient.pages.retrieve({ page_id: pageId });
    
    if ('properties' in page) {
      // Buscar propiedades de estado comunes
      const statusProperties = ['Status', 'Estado', 'state', 'status'];
      
      for (const propName of statusProperties) {
        const property = page.properties[propName];
        if (property && property.type === 'status') {
          return property.status?.name || null;
        }
        if (property && property.type === 'select') {
          return property.select?.name || null;
        }
      }
    }
    
    return null;
  } catch (error) {
    console.error('Error obteniendo estado de página de Notion:', error);
    return null;
  }
}

export async function updateNotionPageStatus(pageId: string, status: string, workspaceName?: string): Promise<void> {
  try {
    const notionClient = getNotionClient(workspaceName);
    const page = await notionClient.pages.retrieve({ page_id: pageId });
    
    if ('properties' in page) {
      // Buscar propiedades de estado comunes
      const statusProperties = ['Status', 'Estado', 'state', 'status'];
      let statusPropertyName: string | null = null;
      let statusPropertyType: string | null = null;
      
      for (const propName of statusProperties) {
        const property = page.properties[propName];
        if (property && (property.type === 'status' || property.type === 'select')) {
          statusPropertyName = propName;
          statusPropertyType = property.type;
          break;
        }
      }
      
      if (statusPropertyName && statusPropertyType && 'parent' in page && page.parent.type === 'database_id') {
        // Obtener el schema del database para conocer las opciones disponibles
        const database = await notionClient.databases.retrieve({ database_id: page.parent.database_id });
        const statusProperty = database.properties[statusPropertyName];
        
        let availableOptions: string[] = [];
        
        if (statusProperty && statusProperty.type === 'status' && 'status' in statusProperty) {
          availableOptions = statusProperty.status.options.map(option => option.name);
        } else if (statusProperty && statusProperty.type === 'select' && 'select' in statusProperty) {
          availableOptions = statusProperty.select.options.map(option => option.name);
        }
        
        logger.info('Available status options from database', {
          pageId,
          statusProperty: statusPropertyName,
          availableOptions,
          requestedStatus: status
        });
        
        // Intentar primero con el estado solicitado
        let targetStatus = status;
        
        // Si el estado solicitado no está disponible, buscar el más apropiado
        if (!availableOptions.includes(status)) {
          const bestMatch = findBestStatusMatch(status, availableOptions);
          
          if (!bestMatch) {
            throw new Error(`No suitable status found. Requested: "${status}". Available options: ${availableOptions.join(', ')}`);
          }
          
          targetStatus = bestMatch;
          
          logger.info(`Status "${status}" not available, using "${targetStatus}" instead`, {
            pageId,
            requestedStatus: status,
            selectedStatus: targetStatus,
            availableOptions
          });
        }
        
        const updatePayload = {
          page_id: pageId,
          properties: {} as Record<string, unknown>
        };
        
        if (statusPropertyType === 'status') {
          updatePayload.properties[statusPropertyName] = {
            status: {
              name: targetStatus
            }
          };
        } else if (statusPropertyType === 'select') {
          updatePayload.properties[statusPropertyName] = {
            select: {
              name: targetStatus
            }
          };
        }
        
        // TypeScript assertion necesaria debido a los tipos complejos de Notion API
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        await notionClient.pages.update(updatePayload as any);
        
        logger.info(`Successfully updated Notion page status`, {
          pageId,
          statusProperty: statusPropertyName,
          propertyType: statusPropertyType,
          newStatus: targetStatus
        });
      } else {
        throw new Error('No se encontró una propiedad de estado en la página de Notion o la página no pertenece a una base de datos');
      }
    }
  } catch (error) {
    console.error('Error actualizando estado de página de Notion:', error);
    throw new Error('No se pudo actualizar el estado de la página en Notion');
  }
}

/**
 * Encuentra el mejor estado coincidente de las opciones disponibles
 */
function findBestStatusMatch(requestedStatus: string, availableOptions: string[]): string | null {
  // Mapas de estados por categorías
  const statusMaps = {
    completed: [
      'Completado', 'Completed', 'Done', 'Finished', 'Complete', 
      'Listo', 'Terminado', 'Finalizado', 'Cerrado', 'Closed'
    ],
    inProgress: [
      'En progreso', 'In Progress', 'Todo', 'Doing', 'En curso', 
      'Pendiente', 'Not started', 'Sin empezar', 'Open', 'Abierto', 
      'Active', 'Working', 'Trabajando'
    ],
    pending: [
      'Pendiente', 'Pending', 'Todo', 'To do', 'Sin empezar', 
      'Not started', 'Backlog', 'Open', 'Abierto'
    ]
  };
  
  // Determinar la categoría del estado solicitado
  let targetCategory: string[] = [];
  
  for (const [_category, statuses] of Object.entries(statusMaps)) {
    if (statuses.some(s => s.toLowerCase() === requestedStatus.toLowerCase())) {
      targetCategory = statuses;
      break;
    }
  }
  
  // Si no encontramos categoría, usar una búsqueda más amplia
  if (targetCategory.length === 0) {
    if (requestedStatus.toLowerCase().includes('complet') || 
        requestedStatus.toLowerCase().includes('done') || 
        requestedStatus.toLowerCase().includes('finish')) {
      targetCategory = statusMaps.completed;
    } else if (requestedStatus.toLowerCase().includes('progress') || 
               requestedStatus.toLowerCase().includes('doing') || 
               requestedStatus.toLowerCase().includes('curso')) {
      targetCategory = statusMaps.inProgress;
    } else {
      targetCategory = statusMaps.pending;
    }
  }
  
  // Buscar la mejor coincidencia en las opciones disponibles
  for (const possibleStatus of targetCategory) {
    const match = availableOptions.find(option => 
      option.toLowerCase() === possibleStatus.toLowerCase()
    );
    if (match) {
      return match;
    }
  }
  
  // Si no hay coincidencia exacta, buscar coincidencias parciales
  for (const possibleStatus of targetCategory) {
    const match = availableOptions.find(option => 
      option.toLowerCase().includes(possibleStatus.toLowerCase()) ||
      possibleStatus.toLowerCase().includes(option.toLowerCase())
    );
    if (match) {
      return match;
    }
  }
  
  // Como último recurso, devolver la primera opción disponible
  return availableOptions.length > 0 ? availableOptions[0] : null;
}

export async function findNotionPageByTodoistTaskId(_todoistTaskId: string): Promise<string | null> {
  try {
    // Buscar en la base de datos usando la URL de la tarea de Todoist
    // Nota: Esta función requiere que tengas acceso a una base de datos donde se almacenen las relaciones
    // O que busques en las descripciones de las páginas el ID de la tarea de Todoist
    
    // Por ahora, implementaremos una búsqueda básica
    // En una implementación más robusta, deberías mantener una base de datos de relaciones
    
    return null; // Placeholder - se implementará según la estructura específica de tu Notion
  } catch (error) {
    console.error('Error buscando página de Notion por ID de tarea de Todoist:', error);
    return null;
  }
}
</file>

<file path="scripts/test-webhook.js">
#!/usr/bin/env node

/**
 * Script de testing para webhooks de Notion - Enfoque simple y práctico
 * Basado en escenarios reales observados en los logs
 * 
 * Uso:
 * npm run test:webhook                    # Test básico del endpoint
 * npm run test:webhook -- --real         # Tests con payloads reales
 * npm run test:webhook -- --sequence     # Test de secuencia de eventos
 * npm run test:webhook -- --mentions     # Test de eliminación de menciones
 * npm run test:webhook -- --update       # Test de actualización de propiedades
 * npm run test:webhook -- --logs         # Ver logs recientes
 * npm run test:webhook -- --stats        # Ver estadísticas
 */

import https from 'https';
import http from 'http';

const BASE_URL = process.env.NEXTAUTH_URL || 'http://localhost:3000';
const WEBHOOK_URL = `${BASE_URL}/api/notion-webhook`;

// Colores para output
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  reset: '\x1b[0m',
  bold: '\x1b[1m'
};

function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

// Payloads basados en logs reales del usuario
const realPayloads = {
  verification: {
    verification_token: "test-verification-token-12345"
  },

  pageDeleted: {
    id: "f426b1e2-c5de-41a6-84e1-1aa3edaf8fd7",
    timestamp: "2025-07-15T20:25:38.394Z",
    workspace_id: "bcd7dac8-d5d8-4726-ad5a-f6a0e1ad9ef1",
    workspace_name: "Corabella Pets",
    subscription_id: "231d872b-594c-8122-963e-0099eb119522",
    integration_id: "230d872b-594c-8060-8665-0037427fe4f8",
    authors: [{ id: "79d3b102-9821-4d8e-bf2b-1e94a65d5120", type: "person" }],
    attempt_number: 1,
    entity: { id: "2311ad4d-650d-8012-95cf-f4bbd3581f4a", type: "page" },
    type: "page.deleted",
    data: {
      parent: { id: "1f61ad4d-650d-80e0-b231-d9b12ffea832", type: "database" }
    }
  },

  pageContentUpdated: {
    id: "80aeb0fc-dd26-44b6-b742-d0f47c3f978c",
    timestamp: "2025-07-15T20:25:40.869Z",
    workspace_id: "bcd7dac8-d5d8-4726-ad5a-f6a0e1ad9ef1",
    workspace_name: "Corabella Pets",
    subscription_id: "231d872b-594c-8122-963e-0099eb119522",
    integration_id: "230d872b-594c-8060-8665-0037427fe4f8",
    authors: [{ id: "79d3b102-9821-4d8e-bf2b-1e94a65d5120", type: "person" }],
    attempt_number: 1,
    entity: { id: "2311ad4d-650d-8034-a3bf-c882d00b435a", type: "page" },
    type: "page.content_updated",
    data: {
      parent: { id: "1f61ad4d-650d-80e0-b231-d9b12ffea832", type: "database" },
      updated_blocks: [
        { id: "2311ad4d-650d-8039-809f-c4941f3f0d9d", type: "block" },
        { id: "2311ad4d-650d-8091-97e1-df44b75c765e", type: "block" }
      ]
    }
  },

  pageCreated: {
    id: "a9d20b68-b722-46a3-8cf9-8153eb70c9dc",
    timestamp: "2025-07-15T20:25:39.546Z",
    workspace_id: "bcd7dac8-d5d8-4726-ad5a-f6a0e1ad9ef1",
    workspace_name: "Corabella Pets",
    subscription_id: "231d872b-594c-8122-963e-0099eb119522",
    integration_id: "230d872b-594c-8060-8665-0037427fe4f8",
    authors: [{ id: "79d3b102-9821-4d8e-bf2b-1e94a65d5120", type: "person" }],
    attempt_number: 1,
    entity: { id: "2311ad4d-650d-8034-a3bf-c882d00b435a", type: "page" },
    type: "page.created",
    data: {
      parent: { id: "1f61ad4d-650d-80e0-b231-d9b12ffea832", type: "database" }
    }
  },

  pagePropertiesUpdated: {
    id: "33173d5b-b4fc-4976-96eb-8e7a4941410e",
    timestamp: "2025-07-15T21:40:48.566Z",
    workspace_id: "bcd7dac8-d5d8-4726-ad5a-f6a0e1ad9ef1",
    workspace_name: "Corabella Pets",
    subscription_id: "231d872b-594c-8122-963e-0099eb119522",
    integration_id: "230d872b-594c-8060-8665-0037427fe4f8",
    authors: [{ id: "79d3b102-9821-4d8e-bf2b-1e94a65d5120", type: "person" }],
    attempt_number: 1,
    entity: { id: "2311ad4d-650d-803e-8470-d503ff8e7985", type: "page" },
    type: "page.properties_updated",
    data: {
      parent: { id: "1f61ad4d-650d-80e0-b231-d9b12ffea832", type: "database" },
      updated_properties: ["Vun%7C"]
    }
  },

  pageStatusCompleted: {
    id: "44284e6c-c6fd-5087-a7fc-9f8b5f952521",
    timestamp: "2025-07-15T22:30:00.000Z",
    workspace_id: "bcd7dac8-d5d8-4726-ad5a-f6a0e1ad9ef1",
    workspace_name: "Corabella Pets",
    subscription_id: "231d872b-594c-8122-963e-0099eb119522",
    integration_id: "230d872b-594c-8060-8665-0037427fe4f8",
    authors: [{ id: "79d3b102-9821-4d8e-bf2b-1e94a65d5120", type: "person" }],
    attempt_number: 1,
    entity: { id: "3311ad4d-650d-805f-9580-e604ff9f8f96", type: "page" },
    type: "page.properties_updated",
    data: {
      parent: { id: "1f61ad4d-650d-80e0-b231-d9b12ffea832", type: "database" },
      updated_properties: ["Status"]
    }
  }
};

async function makeRequest(url, options = {}) {
  return new Promise((resolve, reject) => {
    const protocol = url.startsWith('https:') ? https : http;
    
    const req = protocol.request(url, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'notion-api',
        'X-Notion-Signature': 'sha256=test-signature',
        ...options.headers
      },
      ...options
    }, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          const parsedData = JSON.parse(data);
          resolve({
            status: res.statusCode,
            data: parsedData,
            headers: res.headers
          });
        } catch (_error) {
          resolve({
            status: res.statusCode,
            data: data,
            headers: res.headers
          });
        }
      });
    });

    req.on('error', reject);
    
    if (options.body) {
      req.write(JSON.stringify(options.body));
    }
    
    req.end();
  });
}

async function testWebhookEndpoint() {
  log('🔍 Verificando que el endpoint del webhook esté funcionando...', colors.cyan);
  
  try {
    const response = await makeRequest(WEBHOOK_URL);
    
    if (response.status === 200) {
      log('✅ Endpoint del webhook funcionando correctamente', colors.green);
      log(`📊 Configuración actual:`, colors.blue);
      console.log(JSON.stringify(response.data, null, 2));
      return true;
    } else {
      log(`❌ Error en endpoint: ${response.status}`, colors.red);
      return false;
    }
  } catch (error) {
    log(`❌ Error conectando al webhook: ${error.message}`, colors.red);
    return false;
  }
}

async function testVerification() {
  log('🔐 Testeando verificación de Notion...', colors.cyan);
  
  try {
    const response = await makeRequest(WEBHOOK_URL, {
      method: 'POST',
      body: realPayloads.verification
    });

    if (response.status === 200 && response.data.verification_token) {
      log('✅ Verificación de Notion funcionando', colors.green);
      return true;
    } else {
      log(`❌ Error en verificación: ${response.status}`, colors.red);
      console.log(response.data);
      return false;
    }
  } catch (error) {
    log(`❌ Error en verificación: ${error.message}`, colors.red);
    return false;
  }
}

async function testPageDeleted() {
  log('🗑️ Testeando evento de página eliminada...', colors.cyan);
  
  try {
    const response = await makeRequest(WEBHOOK_URL, {
      method: 'POST',
      body: realPayloads.pageDeleted
    });

    // La nueva API devuelve 400 para eventos no válidos con formato estandarizado
    if (response.status === 400 && 
        response.data.error?.message?.includes('page deleted')) {
      log('✅ Página eliminada ignorada correctamente', colors.green);
      return true;
    } else {
      log(`❌ Error manejando página eliminada: ${response.status}`, colors.red);
      console.log(response.data);
      return false;
    }
  } catch (error) {
    log(`❌ Error en test de página eliminada: ${error.message}`, colors.red);
    return false;
  }
}

async function testDuplicateProtection() {
  log('⏳ Testeando protección contra duplicados...', colors.cyan);
  
  try {
    // Primer evento
    const response1 = await makeRequest(WEBHOOK_URL, {
      method: 'POST',
      body: realPayloads.pageContentUpdated
    });

    // Segundo evento inmediato (mismo pageId)
    const response2 = await makeRequest(WEBHOOK_URL, {
      method: 'POST',
      body: realPayloads.pageCreated
    });

    // Con el nuevo sistema de debounce, ambos eventos deberían devolver 200
    // y el mensaje debería indicar que están programados para procesamiento
    if (response1.status === 200 && response2.status === 200 && 
        response1.data.message?.includes('Event scheduled for processing') &&
        response2.data.message?.includes('Event scheduled for processing')) {
      log('✅ Protección contra duplicados funcionando (sistema de debounce)', colors.green);
      return true;
    } else {
      log(`❌ Protección contra duplicados falló`, colors.red);
      console.log('Primer response:', response1.data);
      console.log('Segundo response:', response2.data);
      return false;
    }
  } catch (error) {
    log(`❌ Error en test de duplicados: ${error.message}`, colors.red);
    return false;
  }
}

async function testPagePropertiesUpdated() {
  log('📝 Testeando evento de propiedades actualizadas...', colors.cyan);
  
  try {
    const response = await makeRequest(WEBHOOK_URL, {
      method: 'POST',
      body: realPayloads.pagePropertiesUpdated
    });

    if (response.status === 200 && response.data.message?.includes('Event scheduled for processing')) {
      log('✅ Evento de propiedades actualizadas procesado correctamente', colors.green);
      log(`   📄 Página: ${response.data.pageId}`, colors.blue);
      log(`   ⏰ Debounce: ${response.data.debounceTimeMs}ms`, colors.blue);
      return true;
    } else {
      log(`❌ Error procesando evento de propiedades actualizadas: ${response.status}`, colors.red);
      console.log(response.data);
      return false;
    }
  } catch (error) {
    log(`❌ Error en test de propiedades actualizadas: ${error.message}`, colors.red);
    return false;
  }
}

async function testUpdateSequence() {
  log('🔄 Testeando secuencia de creación y actualización...', colors.cyan);
  
  try {
    // Primer evento: crear página
    log('  📤 Enviando: page.created', colors.blue);
    const createResponse = await makeRequest(WEBHOOK_URL, {
      method: 'POST',
      body: realPayloads.pageCreated
    });

    // Esperar un poco
    await new Promise(resolve => setTimeout(resolve, 200));

    // Segundo evento: actualizar propiedades de la misma página
    log('  📤 Enviando: page.properties_updated (misma página)', colors.blue);
    const updateResponse = await makeRequest(WEBHOOK_URL, {
      method: 'POST',
      body: {
        ...realPayloads.pagePropertiesUpdated,
        entity: { id: realPayloads.pageCreated.entity.id, type: 'page' } // Misma página
      }
    });

    const results = [
      { event: 'page.created', status: createResponse.status, message: createResponse.data.message },
      { event: 'page.properties_updated', status: updateResponse.status, message: updateResponse.data.message }
    ];

    log('📊 Resultados de la secuencia creación -> actualización:', colors.blue);
    results.forEach((result, index) => {
      const color = result.status === 200 ? colors.green : colors.red;
      log(`  ${index + 1}. ${result.event}: ${result.status} - ${result.message}`, color);
    });

    // Verificar que ambos eventos fueron programados para procesamiento
    const allProcessed = results.every(r => r.status === 200 && r.message?.includes('Event scheduled for processing'));

    if (allProcessed) {
      log('✅ Secuencia de creación -> actualización manejada correctamente', colors.green);
      return true;
    } else {
      log('❌ Secuencia de creación -> actualización no manejada como esperado', colors.red);
      return false;
    }
  } catch (error) {
    log(`❌ Error en test de secuencia de actualización: ${error.message}`, colors.red);
    return false;
  }
}

async function testTaskCompletion() {
  log('✅ Testeando completado automático de tareas...', colors.cyan);
  
  try {
    // Simular cambio de estado a completado
    const response = await makeRequest(WEBHOOK_URL, {
      method: 'POST',
      body: realPayloads.pageStatusCompleted
    });

    if (response.status === 200) {
      log('✅ Evento de completado procesado correctamente', colors.green);
      log(`   📄 Página: ${realPayloads.pageStatusCompleted.entity.id}`);
      log(`   🔄 Tipo: ${realPayloads.pageStatusCompleted.type}`);
      log(`   ⏰ Debounce: ${response.data.debounceTimeMs || 60000}ms`);
      
      // En el webhook real, aquí se completaría la tarea en Todoist
      // El test verifica que el evento se procese correctamente
      return true;
    } else {
      log(`❌ Error procesando evento de completado: ${response.status}`, colors.red);
      console.log('Response:', response.data);
      return false;
    }
  } catch (error) {
    log(`❌ Error en test de completado: ${error.message}`, colors.red);
    return false;
  }
}

async function testMentionRemoval() {
  log('🗑️  Testeando eliminación de tareas cuando se quita la mención...', colors.cyan);
  
  try {
    // Test 1: Simular página donde se quitó la mención
    log('  📋 Test 1: Página sin mención del usuario', colors.blue);
    const response1 = await makeRequest(WEBHOOK_URL, {
      method: 'POST',
      body: {
        id: 'test-mention-removal-1',
        timestamp: new Date().toISOString(),
        workspace_id: 'test-workspace',
        workspace_name: 'Test Workspace',
        type: 'page.updated',
        entity: {
          id: 'test-page-mention-removed',
          type: 'page'
        }
      }
    });

    if (response1.status === 200) {
      log('✅ Evento de actualización procesado correctamente', colors.green);
      log(`   📄 Página: test-page-mention-removed`);
      log(`   🔄 Acción: ${response1.data.eventAction}`);
      log(`   ⏰ Debounce: ${response1.data.debounceTimeMs || 0}ms`);
      
      // Test 2: Verificar que el sistema maneja correctamente cuando no hay tarea que eliminar
      log('  📋 Test 2: Página nueva sin tarea asociada', colors.blue);
      const response2 = await makeRequest(WEBHOOK_URL, {
        method: 'POST',
        body: {
          id: 'test-mention-removal-2',
          timestamp: new Date().toISOString(),
          workspace_id: 'test-workspace',
          workspace_name: 'Test Workspace',  
          type: 'page.updated',
          entity: {
            id: 'test-page-no-existing-task',
            type: 'page'
          }
        }
      });

      if (response2.status === 200) {
        log('✅ Manejo correcto de página sin tarea asociada', colors.green);
        log(`   📄 Página: test-page-no-existing-task`);
        log(`   🔄 Resultado: ${response2.data.message}`);
        
        log('✅ Tests de eliminación de menciones completados', colors.green);
        log('   • Sistema detecta cuando se quita la mención', colors.reset);
        log('   • Maneja correctamente páginas sin tareas asociadas', colors.reset);
        log('   • Funcionalidad lista para entorno de producción', colors.reset);
        
        return true;
      } else {
        log(`❌ Error en test 2: ${response2.status}`, colors.red);
        return false;
      }
    } else {
      log(`❌ Error en test 1: ${response1.status}`, colors.red);
      console.log('Response:', response1.data);
      return false;
    }
  } catch (error) {
    log(`❌ Error en test de eliminación de menciones: ${error.message}`, colors.red);
    return false;
  }
}

async function testSequenceScenario() {
  log('📝 Testeando secuencia real de eventos (content_updated -> page.created)...', colors.cyan);
  
  try {
    // Simular la secuencia exacta del log
    const events = [
      { payload: realPayloads.pageContentUpdated, description: 'page.content_updated' },
      { payload: realPayloads.pageCreated, description: 'page.created (mismo pageId)' }
    ];

    const results = [];
    
    for (let i = 0; i < events.length; i++) {
      const event = events[i];
      log(`  📤 Enviando: ${event.description}`, colors.blue);
      
      const response = await makeRequest(WEBHOOK_URL, {
        method: 'POST',
        body: event.payload
      });
      
      results.push({
        event: event.description,
        status: response.status,
        message: response.data.message || 'OK',
        success: response.data.success
      });
      
      // Esperar un poco entre eventos para simular timing real
      if (i < events.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    log('� Resultados de la secuencia:', colors.blue);
    results.forEach((result, index) => {
      const color = result.status === 200 ? colors.green : colors.red;
      log(`  ${index + 1}. ${result.event}: ${result.status} - ${result.message}`, color);
    });

    // Verificar que la secuencia es correcta (ambos eventos son programados para procesamiento)
    const expectedPattern = results[0].status === 200 && 
                           results[1].status === 200 && 
                           results[0].message?.includes('Event scheduled for processing') &&
                           results[1].message?.includes('Event scheduled for processing');

    if (expectedPattern) {
      log('✅ Secuencia de eventos manejada correctamente', colors.green);
      return true;
    } else {
      log('❌ Secuencia de eventos no manejada como esperado', colors.red);
      return false;
    }
  } catch (error) {
    log(`❌ Error en test de secuencia: ${error.message}`, colors.red);
    return false;
  }
}

async function runRealScenarioTests() {
  log('🧪 Ejecutando tests basados en escenarios reales...', colors.cyan);
  
  const tests = [
    { name: 'Verificación de Notion', fn: testVerification },
    { name: 'Página eliminada', fn: testPageDeleted },
    { name: 'Protección duplicados', fn: testDuplicateProtection },
    { name: 'Propiedades actualizadas', fn: testPagePropertiesUpdated },
    { name: 'Secuencia creación/actualización', fn: testUpdateSequence },
    { name: 'Completado automático de tareas', fn: testTaskCompletion },
    { name: 'Eliminación por remoción de mención', fn: testMentionRemoval },
    { name: 'Secuencia de eventos', fn: testSequenceScenario }
  ];

  const results = [];
  
  for (const test of tests) {
    log(`\n🔍 Ejecutando: ${test.name}`, colors.bold);
    const startTime = Date.now();
    const passed = await test.fn();
    const duration = Date.now() - startTime;
    
    results.push({
      name: test.name,
      passed,
      duration
    });
  }

  // Resumen
  log('\n📊 Resumen de Tests:', colors.bold);
  const passed = results.filter(r => r.passed).length;
  const total = results.length;
  
  log(`Total: ${total} | Pasaron: ${passed} | Fallaron: ${total - passed}`);
  log(`Tasa de éxito: ${((passed / total) * 100).toFixed(1)}%`);
  
  results.forEach(result => {
    const color = result.passed ? colors.green : colors.red;
    const status = result.passed ? '✅' : '❌';
    log(`${status} ${result.name} (${result.duration}ms)`, color);
  });
  
  return passed === total;
}

async function main() {
  const args = process.argv.slice(2);
  
  log('🎯 Notion Webhook Tester - Escenarios Reales', colors.bold + colors.cyan);
  log('===============================================\n');
  
  // Verificar que el endpoint esté funcionando
  const endpointOk = await testWebhookEndpoint();
  if (!endpointOk) {
    log('\n❌ El endpoint del webhook no está funcionando. Verifica que el servidor esté corriendo.', colors.red);
    process.exit(1);
  }
  
  log(''); // Línea en blanco
  
  if (args.includes('--help') || args.includes('-h')) {
    log('Uso:', colors.bold);
    log('  npm run test:webhook                    # Test básico del endpoint');
    log('  npm run test:webhook -- --real         # Tests con payloads reales');
    log('  npm run test:webhook -- --sequence     # Test de secuencia de eventos');
    log('  npm run test:webhook -- --mentions     # Test de eliminación de menciones');
    log('  npm run test:webhook -- --update       # Test de actualización de propiedades');
    log('  npm run test:webhook -- --logs         # Ver logs recientes');
    log('  npm run test:webhook -- --stats        # Ver estadísticas');
    return;
  }
  
  if (args.includes('--real')) {
    const success = await runRealScenarioTests();
    process.exit(success ? 0 : 1);
  } else if (args.includes('--sequence')) {
    const success = await testSequenceScenario();
    process.exit(success ? 0 : 1);
  } else if (args.includes('--mentions')) {
    const success = await testMentionRemoval();
    process.exit(success ? 0 : 1);
  } else if (args.includes('--update')) {
    const success = await testUpdateSequence();
    process.exit(success ? 0 : 1);
  } else if (args.includes('--logs')) {
    await showLogs();
  } else if (args.includes('--stats')) {
    await showStats();
  } else {
    // Test básico por defecto
    log('✅ Endpoint funcionando correctamente.', colors.green);
    log('💡 Para tests más detallados:', colors.blue);
    log('  --real      Tests con payloads reales');
    log('  --sequence  Test de secuencia de eventos');
    log('  --mentions  Test de eliminación de menciones');
    log('  --help      Ver todas las opciones');
  }
}

main().catch(error => {
  log(`❌ Error fatal: ${error.message}`, colors.red);
  process.exit(1);
});
</file>

<file path="src/app/api/notion-webhook/route.ts">
/**
 * API Route para webhooks de Notion
 * Refactorizada para mejor arquitectura y mantenibilidad
 */

import { NextRequest, NextResponse } from 'next/server';
import { withErrorHandler } from '@/middleware/error-handler';
import { createSuccessResponse, createWebhookResponse } from '@/lib/api-response';
import { logger } from '@/lib/logger';
import { validateEnvironment } from '@/lib/config';
import { NotionWebhookService } from '@/services/webhooks/notion-webhook.service';
import { HealthCheckService } from '@/services/health-check.service';

// Validar configuración al inicio
validateEnvironment();

// Servicios
const webhookService = new NotionWebhookService();
const healthService = new HealthCheckService();

/**
 * POST - Procesar webhook de Notion
 */
const handlePost = withErrorHandler(async (request: NextRequest): Promise<NextResponse> => {
  // Extraer payload y headers
  const payload = await request.json();
  const headers = {
    'notion-version': request.headers.get('notion-version'),
    'user-agent': request.headers.get('user-agent'),
    'content-type': request.headers.get('content-type'),
    'x-notion-signature': request.headers.get('x-notion-signature'),
  };

  logger.info('Processing webhook request', { 
    hasPayload: !!payload,
    userAgent: headers['user-agent'],
    hasSignature: !!headers['x-notion-signature']
  });

  // Procesar webhook
  const result = await webhookService.processWebhook(payload, headers);
  
  // Si es verificación, retornar formato especial
  if ('verification_token' in result) {
    return NextResponse.json({
      verification_token: result.verification_token
    });
  }

  // Retornar respuesta estándar
  const response = createWebhookResponse(result.message, {
    pageId: result.pageId,
    eventAction: result.eventAction,
    debounceTimeMs: result.debounceTimeMs,
  });

  return NextResponse.json(response);
});

/**
 * GET - Health check
 */
const handleGet = withErrorHandler(async (): Promise<NextResponse> => {
  const healthStatus = healthService.getHealthStatus();
  const stats = webhookService.getStats();
  
  const response = createSuccessResponse({
    ...healthStatus,
    stats,
  });

  return NextResponse.json(response);
});

// Exportar handlers
export const POST = handlePost;
export const GET = handleGet;
</file>

<file path="package.json">
{
  "name": "imsebarz",
  "version": "1.0.0",
  "description": "Sebastian Ruiz - Personal Portfolio Website",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "type-check": "tsc --noEmit",
    "type-check:watch": "tsc --noEmit --watch",
    "clean": "rm -rf .next out",
    "analyze": "ANALYZE=true npm run build",
    "preview": "npm run build && npm run start",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:webhook": "node scripts/test-webhook.js",
    "test:webhook:real": "node scripts/test-webhook.js --real",
    "test:webhook:sequence": "node scripts/test-webhook.js --sequence",
    "test:webhook:mentions": "node scripts/test-webhook.js --mentions",
    "test:webhook:vercel": "node scripts/test-vercel-webhook.js",
    "test:projects": "node scripts/test-dynamic-projects.js",
    "test:projects:cleanup": "node scripts/test-dynamic-projects.js --cleanup"
  },
  "dependencies": {
    "@notionhq/client": "^4.0.1",
    "axios": "^1.10.0",
    "framer-motion": "^12.23.5",
    "next": "^15.3.5",
    "openai": "^5.9.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-intersection-observer": "^9.16.0",
    "sass": "^1.89.2"
  },
  "devDependencies": {
    "@babel/core": "^7.24.0",
    "@babel/preset-env": "^7.24.0",
    "@babel/preset-react": "^7.27.1",
    "@babel/preset-typescript": "^7.27.1",
    "@types/jest": "^29.5.12",
    "@types/node": "^24.0.13",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "babel-jest": "^29.7.0",
    "eslint": "^8.57.1",
    "eslint-config-next": "^15.3.5",
    "jest": "^29.7.0",
    "jest-environment-node": "^29.7.0",
    "ts-jest": "^29.1.2",
    "typescript": "^5.8.3"
  }
}
</file>

</files>
